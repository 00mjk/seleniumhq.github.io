<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>服务网格 4 on Selenium 文档</title><link>https://www.selenium.dev/documentation/zh-cn/grid/grid_4/</link><description>Recent content in 服务网格 4 on Selenium 文档</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><copyright>2013-{year}</copyright><atom:link href="https://www.selenium.dev/documentation/zh-cn/grid/grid_4/index.xml" rel="self" type="application/rss+xml"/><item><title>GraphQL查询支持</title><link>https://www.selenium.dev/documentation/zh-cn/grid/grid_4/graphql_support/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/zh-cn/grid/grid_4/graphql_support/</guid><description>GraphQL 是一种用于API的查询语言, 也是用于使用现有数据完成这些查询的运行时. 其仅仅是使用户能够准确地获取所需.
枚举 枚举是表示字段的可能值的集合.
例如, Node对象具有一个称为status的字段. 状态是一个枚举 (特别是Status类型) , 因为它可能是UP , DRAINING 或 UNAVAILABLE.
标量 标量是基本类型的值: Int, Float, String, Boolean, 或 ID.
在调用GraphQL API时, 必须指定嵌套子字段, 直到只返回标量.
模式的结构 网格模式的结构如下:
{ session(id: &amp;#34;&amp;lt;session-id&amp;gt;&amp;#34;) : { id, capabilities, startTime, uri, nodeId, nodeUri, sessionDurationMillis slot : { id, stereotype, lastStarted } } grid: { uri, totalSlots, usedSlots, sessionCount, nodes : [ { id, uri, status, maxSession, sessions : [ { id, capabilities, startTime, uri, nodeId, nodeUri, sessionDurationMillis slot : { id, stereotype, lastStarted } } ] capabilities, } ] } } 查询 GraphQL 查询GraphQL的最佳方法是使用curl请求.</description></item><item><title>服务网格的组件</title><link>https://www.selenium.dev/documentation/zh-cn/grid/grid_4/components_of_a_grid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/zh-cn/grid/grid_4/components_of_a_grid/</guid><description>Router 路由器负责将请求转发到正确的组件.
它是网格的入口,所有外部请求都将借此被网格接收. 路由器的行为取决于请求. 如果是新的会话请求, 则路由器会将其转发到分发服务器 (将在其中处理并创建新的会话). 如果请求属于存量会话,则路由器会将会话ID发送到会话集合, 会话集合将返回会话正在运行的节点. 此后, 路由器会将请求转发到节点.
路由器旨在通过将请求发送到能够更好地处理请求的组件, 来平衡网格中的负载, 从而避免过程中任何组件无谓地过载.
Distributor 分发器知道所有节点及其功能. 它的主要作用是接收新的会话请求 并找到可以在其中创建会话的适当节点. 创建会话后, 分发器在会话集合中存储会话ID与正在执行会话的节点之间的关系.
Node 一个节点可以在网格中出现多次. 每个节点负责管理其运行机器的可用浏览器的插槽.
节点通过事件总线将其自身注册到分发服务器, 并且将其配置作为注册消息的组成部分一起发送.
默认情况下, 节点会自动注册运行它的计算机路径上所有可用的浏览器驱动程序. 它还为基于Chromium的浏览器和Firefox的每个可用的CPU都创建插槽. 对于Safari和Internet Explorer, 则仅创建一个插槽。 通过特定的配置, 它可以在Docker容器中运行会话. 您可以在下一 章节 中查看更多配置详细信息.
节点仅执行接收到的命令, 它不进行评估、做出判断或控制任何事情. 运行节点的计算机不需要与其他组件具有相同的操作系统. 例如, Windows节点可以具有将Internet Explorer作为浏览器选项的功能, 而在Linux或Mac上则无法实现.
Session Map 会话集合是一种数据存储的形式, 用于保存会话ID和会话正在运行的节点的信息. 它在将请求转发到节点的过程中为路由器提供支持. 路由器将向会话集合询问与会话ID关联的节点. 当以完全分布式模式启动Grid时, Session Map是应该启动的第一个组件.
Event Bus 事件总线作为一种通讯的路径, 服务于节点、分发服务器和会话集合之间. 网格通过消息进行大部分内部通信, 从而避免了昂贵的HTTP调用.
Roles in Grid 在网格3中, 组件是集线器和节点, 可以通过以独立模式启动网格来一起运行它们. Grid 4中提供了相同的概念, 可以通过对上述某些组件进行分组来运行集线器, 也可以在独立模式下一起运行所有组件.
Hub 集线器是以下组件的结合:</description></item><item><title>配置自己的服务网格</title><link>https://www.selenium.dev/documentation/zh-cn/grid/grid_4/setting_up_your_own_grid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/zh-cn/grid/grid_4/setting_up_your_own_grid/</guid><description>Page being translated from English to Chinese. Do you speak Chinese? Help us to translate it by sending us pull requests!
Different Modes of Grid setup in Selenium 4: Standalone Hub and Node Distributed Docker Standalone Mode: The new Selenium Server Jar contains everything you&amp;rsquo;d need to run a grid. It is also the easiest mode to spin up a Selenium Grid. By default the server will be listening on http://localhost:4444, and that&amp;rsquo;s the URL you should point your RemoteWebDriver tests.</description></item></channel></rss>