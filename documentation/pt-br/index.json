[{"uri":"https://www.selenium.dev/documentation/pt-br/worst_practices/two_factor_authentication/","title":"Autenticação de Dois Fatores (2FA)","tags":[],"description":"","content":"A autenticação de dois fatores, conhecida como 2FA, é um mecanismo de autorização onde a senha de uso único (OTP) é gerada usando aplicativos móveis \u0026ldquo;Autenticadores\u0026rdquo;, como \u0026ldquo;Google Authenticator\u0026rdquo;, \u0026ldquo;Microsoft Authenticator\u0026rdquo; etc., ou por SMS, e-mail para autenticação. Automatizar isso perfeitamente e consistentemente é um grande desafio no Selenium. Existem algumas maneiras para automatizar este processo. Mas essa será outra camada em cima de nossos testes Selenium e não protegidos também. Portanto, você pode evitar a automação do 2FA.\nExistem algumas opções para contornar as verificações 2FA:\n Desative 2FA para determinados usuários no ambiente de teste, para que você possa usar essas credenciais de usuário na automação. Desative 2FA em seu ambiente de teste. Desative 2FA se você fizer o login de determinados IPs. Dessa forma, podemos configurar nosso teste os IPs da máquina para evitar isso.  "},{"uri":"https://www.selenium.dev/documentation/pt-br/worst_practices/captchas/","title":"Captchas","tags":[],"description":"","content":"CAPTCHA, abreviação de Completely Automated Public Turing test to tell Computers and Humans Apart, foi projetado explicitamente para impedir a automação, portanto, não tente! Existem duas estratégias principais para contornar as verificações CAPTCHA:\n Desative CAPTCHAs em seu ambiente de teste Adicione um hook para permitir que os testes ignorem o CAPTCHA  "},{"uri":"https://www.selenium.dev/documentation/pt-br/getting_started/","title":"Começando","tags":[],"description":"","content":"Começando Se você é um usuário novo de Selenium, temos alguns recursos que podem te ajudar a agilizar o seu aprendizado.\n Tour rápido  WebDriver IDE Grid    "},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/grid_3/components_of_a_grid/","title":"Componentes","tags":[],"description":"","content":"Hub  Intermediário e gerente Aceita solicitações para executar testes Recebe instruções do cliente e as executa remotamente nos nós Gerencia tópicos  Um Hub é um ponto central para onde todos os seus testes são enviados. Cada Selenium Grid consiste em exatamente um hub. O hub precisa estar acessível dos respectivos clientes (ou seja, servidor de CI, máquina do desenvolvedor etc.) O hub irá conectar um ou mais nós aos quais os testes serão delegados.\nNós  Onde vivem os navegadores Registra-se no hub e comunica seus recursos Recebe solicitações do hub e as executa  Nodes são diferentes instâncias do Selenium que executarão testes em sistemas de computador individuais. Pode haver muitos nós em uma grade. As máquinas que são nós não precisam ser da mesma plataforma ou ter a mesma seleção de navegador do hub ou de outros nós. Um nó no Windows pode ter a capacidade de oferecer o Internet Explorer como uma opção de navegador, considerando que isso não seria possível no Linux ou Mac.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/grid_4/components_of_a_grid/","title":"Componentes","tags":[],"description":"","content":"Roteador O roteador se encarrega de encaminhar a solicitação para o componente correto.\nÉ o ponto de entrada da Grid, todas as solicitações externas serão recebidas por ele. O roteador se comporta de maneira diferente dependendo da solicitação. Se for uma nova sessão, o roteador irá encaminhá-la para o enfileirador de sessão, que irá adicioná-la a nova fila de sessão. O Enfileirador de Sessão irá disparar um evento através do Event Bus. O Distribuidor (onde a criação da nova sessão será tratada) irá receber o evento e pesquisar o Enfileirador de Sessão para obter a nova solicitação de sessão. Se a solicitação pertencer a uma sessão existente, o roteador irá enviar a ID da sessão para o Mapa da Sessão, e o Mapa da Sessão irá retornar o Nó onde a sessão está rodando. Depois disso, o roteador irá encaminhar a solicitação ao Nó.\nO Roteador visa equilibrar a carga na Rede, enviando as solicitações para o componente que é capaz de lidar melhor com eles, sem sobrecarregar nenhum componente que não é necessário no processo.\nDistribuidor O Distribuidor está ciente de todos os nós e suas capacidades. Seu papel principal é receber um novo pedido de sessão e encontrar um Nó adequado onde a sessão pode ser criada. Depois que a sessão é criada, o Distribuidor armazena no Mapa da Sessão a relação entre o ID da sessão e o nó onde a sessão está sendo executada.\nNó Um Nó pode estar presente várias vezes em uma Grid. Cada nó cuida de gerenciar os slots para os navegadores disponíveis da máquina onde está sendo executado.\nO Nó se registra no Distribuidor através do Event Bus, e sua configuração é enviada como parte da mensagem de registro.\nPor padrão, o Nó registra automaticamente todos os drivers de navegador disponíveis no PATH da máquina onde ele roda. Ele também cria um slot por CPU disponível para navegadores baseados em Chromium e Firefox. Para Safari e Internet Explorer, apenas um slot é criado. Por meio de uma configuração específica, ele pode executar sessões em contêineres Docker. Você pode ver mais detalhes de configuração na próxima seção.\nUm Nó apenas executa os comandos recebidos, não avalia, não faz julgamentos, ou controlar qualquer coisa. As máquinas onde o Nó está rodando não precisam ter o mesmo sistema operacional que os outros componentes. Por exemplo, um nó do Windows pode ter a capacidade de oferecer o Internet Explorer como uma opção de navegador, considerando que isso não seria possível no Linux ou Mac.\nMapa de Sessão O Mapa da Sessão é um armazenamento de dados que mantém as informações do ID da sessão e do Nó onde a sessão está sendo executada. Serve como suporte para o Roteador no processo de encaminhamento de uma solicitação para o Nó. O Roteador irá pedir o mapa da sessão para o nó associado a um ID de sessão. Ao iniciar a Grid em seu modo totalmente distribuído, o Mapa da Sessão é o primeiro componente que deve ser iniciado.\nEnfileirador de Sessão, Fila de Sessão O Enfileirador de Sessão é o único componente que pode se comunicar com a nova fila de sessão. Ele lida com todas as operações de fila (como add) para manipular a fila. Possui parâmetros configuráveis ​​para definir o tempo limite da solicitação e o intervalo de repetição da solicitação.\nA Fila de Sessão recebe a nova solicitação de sessão do Roteador e a adiciona à fila. O enfileirador espera até receber a resposta para a solicitação. Se a solicitação expirar, ela será rejeitada imediatamente e não adicionada à fila.\nAo adicionar com sucesso a solicitação à fila, o Event Bus aciona um evento. O Distribuidor seleciona este evento e pesquisa a fila. Agora ele tenta criar uma sessão.\nSe os recursos solicitados não existirem em nenhum dos nós registrados, a solicitação será rejeitada imediatamente e o cliente recebe uma resposta.\nSe os recursos solicitados corresponderem aos recursos de qualquer um dos slots de Nó, o Distribuidor tenta obter o slot disponível. Se todos os slots estiverem ocupados, o Distribuidor pedirá ao enfileirador para adicionar o pedido para o início da fila. O Distribuidor recebe a solicitação novamente após o intervalo de repetição da solicitação. Ele tentará novas tentativas até que a solicitação seja bem-sucedida ou tenha expirado. Se a solicitação atingir o tempo limite ao tentar novamente ou adicionar à frente da fila, ela será rejeitada.\nDepois de obter um slot disponível e a criação de sessão, o Distribuidor passa a nova resposta de sessão para a nova fila de espera de sessão por meio do Event Bus. Enfileirador de Sessão responderá ao cliente quando ele recebe o evento.\nEvent Bus O Event Bus serve como um caminho de comunicação entre os nós, o distribuidor, o enfileirador de sessão e o mapa da sessão. A Grid faz a maior parte de sua comunicação interna por meio de mensagens, evitando chamadas HTTP caras.\nFunções na Grid Na Grade 3, os componentes eram Hub e Nó, e era possível executá-los juntos iniciando a Grid em modo autônomo. O mesmo conceito está disponível na Grid 4, é possível executar um hub agrupando alguns dos componentes descritos acima, e também é possível executar todos os componentes juntos em um modo autônomo.\nHub Hub é a união dos seguintes componentes:\n Roteador Distribuidor Mapa da Sessão Enfileirador de Sessão Event Bus  Habilita a configuração clássica de hub e nó(s).\nStandalone Como mencionado antes, Standalone é a união de todos os componentes e, aos olhos do usuário, eles são executado como um. Isso inclui todos os componentes que fazem parte do hub, mais um nó. Totalmente Uma Grid totalmente funcional está disponível após iniciá-la no modo Standalone.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/front_matter/copyright_and_attributions/","title":"Direitos autorais e atribuições","tags":[],"description":"","content":"A Documentação do Selenium Copyright \u0026copy; 2013-2021 , Software Freedom Conservancy.\nTodo esforço foi feito para tornar esta documentação a mais completa e precisa possível, mas nenhuma garantia ou adequação está implícita. As informações fornecidas são \u0026ldquo;no estado em que se encontram\u0026rdquo;. Os autores e a editora não terão qualquer responsabilidade para com qualquer pessoa ou entidade com relação a quaisquer perdas ou danos decorrentes das informações contidas neste livro. Nenhuma responsabilidade de patente é assumida com relação ao uso das informações aqui contidas.\nAtribuições Agradecimentos: Selenium Main Repository Selenium IDE Docker Selenium Selenium Website e Docs Website Selenium Anterior Projeto de Re-escrita da Documentação Anterior Projetos de terceiros usados pela documentação do Selenium:    Software Versão Licença     Hugo v0.66.0 Apache 2.0   Hugo Learn Theme v2.5.0 MIT   Code Tabs Style \u0026mdash; MIT    Licença Todo o código e documentação proveniente do projeto Selenium está licenciado sob a licença Apache 2.0, com a Software Freedom Conservancy como detentor dos direitos autorais.\nA licença está incluída aqui por conveniência, mas você também pode encontrá-la no Site da Apache Foundation:\nApache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \u0026#34;License\u0026#34; shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \u0026#34;Licensor\u0026#34; shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \u0026#34;Legal Entity\u0026#34; shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u0026#34;control\u0026#34; means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \u0026#34;You\u0026#34; (or \u0026#34;Your\u0026#34;) shall mean an individual or Legal Entity exercising permissions granted by this License. \u0026#34;Source\u0026#34; form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \u0026#34;Object\u0026#34; form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \u0026#34;Work\u0026#34; shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \u0026#34;Derivative Works\u0026#34; shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \u0026#34;Contribution\u0026#34; shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u0026#34;submitted\u0026#34; means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u0026#34;Not a Contribution.\u0026#34; \u0026#34;Contributor\u0026#34; shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \u0026#34;NOTICE\u0026#34; text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \u0026#34;[]\u0026#34; replaced with your own identifying information. (Don\u0026#39;t include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \u0026#34;printed page\u0026#34; as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. "},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/understanding_the_components/","title":"Entendendo os componentes","tags":[],"description":"","content":" Page being translated from English to Brazilian Portuguese. Do you speak Brazilian Portuguese? Help us to translate it by sending us pull requests!\n Building a test suite using WebDriver will require you to understand and effectively use a number of different components. As with everything in software, different people use different terms for the same idea. Below is a breakdown of how terms are used in this description.\nTerminology  API: Application Programming Interface. This is the set of \u0026ldquo;commands\u0026rdquo; you use to manipulate WebDriver. Library: A code module which contains the APIs and the code necessary to implement them. Libraries are specific to each language binding, eg .jar files for Java, .dll files for .NET, etc. Driver: Responsible for controlling the actual browser. Most drivers are created by the browser vendors themselves. Drivers are generally executable modules that run on the system with the browser itself, not on the system executing the test suite. (Although those may be the same system.) NOTE: Some people refer to the drivers as proxies. Framework: An additional library used as a support for WebDriver suites. These frameworks may be test frameworks such as JUnit or NUnit. They may also be frameworks supporting natural language features such as Cucumber or Robotium. Frameworks may also be written and used for things such as manipulating or configuring the system under test, data creation, test oracles, etc.  The Parts and Pieces At its minimum, WebDriver talks to a browser through a driver. Communication is two way: WebDriver passes commands to the browser through the driver, and receives information back via the same route.\nThe driver is specific to the browser, such as ChromeDriver for Google\u0026rsquo;s Chrome/Chromium, GeckoDriver for Mozilla\u0026rsquo;s Firefox, etc. The driver runs on the same system as the browser. This may, or may not be, the same system where the tests themselves are executing.\nThis simple example above is direct communication. Communication to the browser may also be remote communication through Selenium Server or RemoteWebDriver. RemoteWebDriver runs on the same system as the driver and the browser.\nRemote communication can also take place using Selenium Server or Selenium Grid, both of which in turn talk to the driver on the host system\nWhere Frameworks fit in WebDriver has one job and one job only: communicate with the browser via any of the methods above. WebDriver does not know a thing about testing: it does not know how to compare things, assert pass or fail, and it certainly does not know a thing about reporting or Given/When/Then grammar.\nThis is where various frameworks come in to play. At a minimum you will need a test framework that matches the language bindings, e.g. NUnit for .NET, JUnit for Java, RSpec for Ruby, etc.\nThe test framework is responsible for running and executing your WebDriver and related steps in your tests. As such, you can think of it looking akin to the following image.\nNatural language frameworks/tools such as Cucumber may exist as part of that Test Framework box in the figure above, or they may wrap the Test Framework entirely in their own implementation.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/selenium_installation/installing_selenium_libraries/","title":"Instalando bibliotecas do Selenium","tags":[],"description":"","content":"Primeiro você precisa instalar as ligações Selenium para seu projeto de automação. O processo de instalação de bibliotecas depende da linguagem que você escolher usar.\nJava A instalação de bibliotecas Selenium para Java pode ser feita usando Maven. Adicione a dependência selenium-java em seu pom.xml:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; A dependência selenium-java suporta a execução de sua automação com todos os navegadores com suporte Selenium. Se você quiser fazer testes apenas em um navegador específico, você pode adicionar a dependência para esse navegador em seu arquivo pom.xml. Por exemplo, você deve adicionar a seguinte dependência em seu pom.xml arquivo para executar seus testes apenas no Firefox:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-firefox-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; De maneira semelhante, se você deseja executar testes apenas no Chrome, você deve adicionar a seguinte dependência:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-chrome-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Python A instalação de bibliotecas Selenium para Python pode ser feita usando pip:\npip install selenium Como alternativa, você pode baixar o arquivo de origem do PyPI (selenium-x.x.x.tar.gz) e instale-o usando setup.py:\npython setup.py install C# A instalação de bibliotecas Selenium para C# pode ser feita usando NuGet:\n# Using package manager Install-Package Selenium.WebDriver # or using .Net CLI dotnet add package Selenium.WebDriver Ruby A instalação de bibliotecas Selenium para Ruby pode ser feita usando gem:\ngem install selenium-webdriver JavaScript A instalação de bibliotecas Selenium para JavaScript pode ser feita usando npm:\nnpm install selenium-webdriver Kotlin Devido à ausência de vínculos de linguagem nativo para Kotlin, você deve usar vínculos Java, por exemplo, com Maven Java\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/page_object_models/","title":"Modelos de objetos de página","tags":[],"description":"","content":"Objeto de página é um padrão de design que se tornou popular na automação de teste para melhorar a manutenção de teste e reduzir a duplicação de código. Um objeto de página é uma classe orientada a objetos que serve como uma interface para uma página de seu AUT. Os testes então usam os métodos desta classe de objeto de página sempre que precisam interagir com a interface do usuário dessa página. O benefício é que, se a IU mudar para a página, os próprios testes não precisam ser alterados, apenas o código dentro do o objeto da página precisa ser alterado. Posteriormente, todas as alterações para oferecer suporte a essa nova IU estão localizados em um só lugar.\nO padrão de design do objeto de página oferece as seguintes vantagens:\n Há uma separação clara entre o código de teste e o código específico da página, como localizadores (ou seu uso se você estiver usando um mapa de interface do usuário) e layout. Existe um único repositório para os serviços ou operações oferecidos pela página em vez de ter esses serviços espalhados pelos testes.  Em ambos os casos, isso permite qualquer modificação necessária devido a mudanças na IU ser feito em um só lugar. Informações úteis sobre esta técnica podem ser encontradas em vários blogs, já que esse ‘padrão de design de teste’ está se tornando amplamente usado. Nós incentivamos o leitor que deseja saber mais a pesquisar blogs na internet nesse assunto. Muitos escreveram sobre este padrão de design e podem fornecer dicas úteis que vão além do escopo deste guia do usuário. Para começar, no entanto, vamos ilustrar objetos de página com um exemplo simples.\nPrimeiro, considere um exemplo, típico de automação de teste, que não usa um objeto de página:\n/*** * Tests login feature */ public class Login { public void testLogin() { // preenche dados de login na página de entrada  driver.findElement(By.name(\u0026#34;user_name\u0026#34;)).sendKeys(\u0026#34;testUser\u0026#34;); driver.findElement(By.name(\u0026#34;password\u0026#34;)).sendKeys(\u0026#34;my supersecret password\u0026#34;); driver.findElement(By.name(\u0026#34;sign-in\u0026#34;)).click(); // verifica que a tag h1 é \u0026#34;Hello userName\u0026#34; após o login  driver.findElement(By.tagName(\u0026#34;h1\u0026#34;)).isDisplayed(); assertThat(driver.findElement(By.tagName(\u0026#34;h1\u0026#34;)).getText(), is(\u0026#34;Hello userName\u0026#34;)); } } Há dois problemas com esta abordagem.\n Não há separação entre o método de teste e os localizadores AUT (IDs neste exemplo); ambos estão interligados em um único método. Se a IU da aplicação muda seus identificadores, layout ou como um login é inserido e processado, o próprio teste deve mudar. Os localizadores do ID estariam espalhados em vários testes, em todos os testes que precisassem usar esta página de login.  Aplicando as técnicas de objeto de página, este exemplo poderia ser reescrito assim no exemplo a seguir de um objeto de página para uma página de Sign-in.\nimport org.openqa.selenium.By; import org.openqa.selenium.WebDriver; /** * Page Object encapsula a página de login. */ public class SignInPage { protected WebDriver driver; // \u0026lt;input name=\u0026#34;user_name\u0026#34; type=\u0026#34;text\u0026#34; value=\u0026#34;\u0026#34;\u0026gt;  private By usernameBy = By.name(\u0026#34;user_name\u0026#34;); // \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; value=\u0026#34;\u0026#34;\u0026gt;  private By passwordBy = By.name(\u0026#34;password\u0026#34;); // \u0026lt;input name=\u0026#34;sign_in\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;SignIn\u0026#34;\u0026gt;  private By signinBy = By.name(\u0026#34;sign_in\u0026#34;); public SignInPage(WebDriver driver){ this.driver = driver; } /** * Login como um usuário válido * * @param userName * @param password * @return HomePage object */ public HomePage loginValidUser(String userName, String password) { driver.findElement(usernameBy).sendKeys(userName); driver.findElement(passwordBy).sendKeys(password); driver.findElement(signinBy).click(); return new HomePage(driver); } } e o objeto de página de uma página inicial pode ter a seguinte aparência.\nimport org.openqa.selenium.By; import org.openqa.selenium.WebDriver; /** * Page Object encapsula a Home Page */ public class HomePage { protected WebDriver driver; // \u0026lt;h1\u0026gt;Hello userName\u0026lt;/h1\u0026gt;  private By messageBy = By.tagName(\u0026#34;h1\u0026#34;); public HomePage(WebDriver driver){ this.driver = driver; if (!driver.getTitle().equals(\u0026#34;Home Page of logged in user\u0026#34;)) { throw new IllegalStateException(\u0026#34;This is not Home Page of logged in user,\u0026#34; + \u0026#34; current page is: \u0026#34; + driver.getCurrentUrl()); } } /** * Get message (h1 tag) * * @return String message text */ public String getMessageText() { return driver.findElement(messageBy).getText(); } public HomePage manageProfile() { // Encapsulamento da página para gerenciar a funcionalidade do perfil  return new HomePage(driver); } /* Mais métodos fornecendo o serviços representados pela Home Page do usuário logado. Esses métodos por sua vez podem retornar mais Page Objects por exemplo clicar no botão Compor Email poderia retornar um objeto ComposeMail */ } Portanto, agora, o teste de login usaria esses dois objetos de página da seguinte maneira.\n/*** * Tests login feature */ public class TestLogin { @Test public void testLogin() { SignInPage signInPage = new SignInPage(driver); HomePage homePage = signInPage.loginValidUser(\u0026#34;userName\u0026#34;, \u0026#34;password\u0026#34;); assertThat(homePage.getMessageText(), is(\u0026#34;Hello userName\u0026#34;)); } } Há muita flexibilidade em como os objetos de página podem ser projetados, mas existem algumas regras básicas para obter a manutenção desejada de seu código de teste.\nOs próprios objetos de página nunca devem fazer verificações ou afirmações. Isto é parte do seu teste e deve estar sempre dentro do código do teste, nunca em um objeto de página. O objeto da página conterá a representação da página, e o serviços que a página fornece por meio de métodos, mas nenhum código relacionado ao que está sendo testado deve estar dentro do objeto de página.\nHá uma única verificação que pode e deve estar dentro do objeto de página e que é para verificar se a página e, possivelmente, elementos críticos em a página, foram carregados corretamente. Esta verificação deve ser feita enquanto instanciar o objeto de página. Nos exemplos acima, ambos SignInPage e os construtores da HomePage verificam se a página esperada está disponível e pronta para solicitações do teste.\nUm objeto de página não precisa necessariamente representar todas as partes da página em si. Os mesmos princípios usados para objetos de página podem ser usados para criar \u0026ldquo;Objetos de Componente de Página\u0026rdquo; que representam pedaços discretos da página e podem ser incluídos em objetos de página. Esses objetos de componentes podem fornecer referências aos elementos dentro desses blocos discretos, e métodos para utilizar a funcionalidade fornecida por eles. Você também pode aninhar objetos de componentes dentro de outros objetos de componentes para páginas mais complexas. Se uma página na aplicação tem vários componentes, ou componentes usados em todo o site (por exemplo, uma barra de navegação), então pode melhorar a manutenção e reduzir a duplicação de código.\nExistem outros padrões de design que também podem ser usados em testes. Alguns usam um Page Factory para instanciar seus objetos de página. Discutir tudo isso é além do escopo deste guia do usuário. Aqui, queremos apenas apresentar o conceitos para tornar o leitor ciente de algumas coisas que podem ser feitas. Como foi mencionado anteriormente, muitos escreveram sobre este tópico e nós encorajamos o leitor para pesquisar blogs sobre esses tópicos.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/getting_started_with_webdriver/browsers/","title":"Navegadores","tags":[],"description":"","content":"Navegadores comerciais O framework Selenium oferece suporte oficial aos seguintes navegadores:\n   Navegador Mantenedor Versões Suportadas     Chrome Chromium Todas as versões   Firefox Mozilla 54 ou mais nova   Edge Microsoft 84 ou mais nova   Internet Explorer Selenium 6 ou mais nova   Opera Opera Chromium / Presto 10.5 ou mais nova   Safari Apple 10 ou mais nova    Navegadores especializados Também existe um conjunto de navegadores especializados por aí normalmente usados em ambientes de desenvolvimento. Podemos usar alguns desses navegadores para fins de automação também, e o Selenium suporta os seguintes drivers especializados:\n   Nome do driver Objetivo Mantenedor     HtmlUnitDriver Emulador de navegador sem cabeçalho apoiado pelo Rhino Projeto Selenium    "},{"uri":"https://www.selenium.dev/documentation/pt-br/introduction/the_selenium_project_and_tools/","title":"O projeto Selenium e ferramentas","tags":[],"description":"","content":"Selenium controla navegadores Selenium é muitas coisas mas, em sua essência, é um conjunto de ferramentas para automação de navegador da web que usa as melhores técnicas disponíveis para controlar remotamente as instâncias do navegador e emular a interação do usuário com o navegador.\nEle permite que os usuários simulem atividades comuns realizadas por usuários finais; inserir texto em campos, selecionando valores suspensos e caixas de seleção, e clicar em links em documentos. Ele também fornece muitos outros controles, como o movimento do mouse, execução arbitrária de JavaScript e muito mais.\nEmbora seja usado principalmente para testes de front-end de sites, Selenium é basicamente uma biblioteca de agente de usuário de navegador. As interfaces são onipresentes em seus aplicativos, o que incentiva a composição com outras bibliotecas para atender a sua finalidade.\nUma interface para tudo Um dos princípios norteadores do projeto é oferecer suporte a uma interface comum para todas as tecnologias de navegador (principais). Os navegadores da web são aplicativos incrivelmente complexos e altamente projetados, realizando suas operações de maneiras completamente diferentes mas que frequentemente têm a mesma aparência ao fazê-lo. Mesmo que o texto seja renderizado com as mesmas fontes, as imagens sejam exibidas no mesmo lugar e os links levem você ao mesmo destino. O que está acontecendo por baixo é tão diferente quanto noite e dia. Selenium \u0026ldquo;abstrai\u0026rdquo; essas diferenças, esconde seus detalhes e complexidades da pessoa que está escrevendo o código. Isso permite que você escreva várias linhas de código para realizar um fluxo de trabalho complicado, mas essas mesmas linhas serão executadas no Firefox, Internet Explorer, Chrome e todos os outros navegadores compatíveis.\nFerramentas e suporte A abordagem de design minimalista do Selenium lhe dá a versatilidade para ser incluído como um componente em aplicações maiores. A infraestrutura circundante fornecida sob o Selenium dá a você as ferramentas para montar sua Grid de navegadores para que os testes possam ser executados em diferentes navegadores e sistemas operacionais em uma variedade de máquinas.\nImagine um banco de computadores em sua sala de servidores ou data center todos abrindo navegadores ao mesmo tempo acessando links, formulários, e tabelas — testando seu aplicativo 24 horas por dia. Por meio da interface de programação simples fornecido para os idiomas mais comuns, esses testes serão executados incansavelmente em paralelo, reportando de volta para você quando ocorrerem erros.\nÉ o objetivo de ajudar a tornar isso uma realidade para você, fornecendo aos usuários ferramentas e documentação não apenas para controlar os navegadores mas para tornar mais fácil dimensionar e implantar essas grades.\nQuem usa Selenium Muitas das empresas mais importantes do mundo adotaram o Selenium para seus testes baseados em navegador, frequentemente substituindo esforços de anos envolvendo outras ferramentas proprietárias. À medida que sua popularidade cresceu, seus requisitos e desafios se multiplicaram.\nConforme a web se torna mais complicada e novas tecnologias são adicionadas aos sites, é a missão deste projeto acompanhá-los sempre que possível. Sendo um projeto de código aberto, este apoio é fornecido por meio da generosa doação de tempo de muitos voluntários, cada um deles tem um “trabalho diurno”.\nOutra missão do projeto é incentivar mais voluntários para participar deste esforço, e construir uma comunidade forte para que o projeto possa continuar a acompanhar as tecnologias emergentes e permanecer uma plataforma dominante para automação de teste funcional.\nHistória Quando Selenium 1 foi lançado em 2004, foi devido à necessidade de reduzir o tempo gasto verificando manualmente o comportamento consistente no front-end de um aplicativo da web. Ele fez uso de quais ferramentas estavam disponíveis na época e dependia muito da injeção de JavaScript na página da web em teste para emular a interação de um usuário.\nEmbora o JavaScript seja uma boa ferramenta para permitir que você faça uma introspecção nas propriedades do DOM e fazer certas observações do lado do cliente que, de outra forma, você não seria capaz de fazer, fica aquém da capacidade de replicar naturalmente as interações de um usuário como se o mouse e o teclado estivessem sendo usados.\nDesde então, Selenium cresceu e amadureceu muito, em uma ferramenta amplamente usada por muitos — se não pela maioria — das maiores organizações em todo o mundo. Selenium deixou de ser um kit de ferramentas de automação de teste caseiro desenvolvido na Thoughtworks para um público de nicho e um caso de uso específico, à biblioteca de automação de navegador de facto do mundo.\nAssim como o Selenium RC fazia uso das ferramentas do comércio disponíveis na época, Selenium WebDriver impulsiona essa tradição ao seguir a parte de interação do navegador com a área residencial do fornecedor do navegador e pedindo a eles que assumam a responsabilidade pelas implementações de back-end voltadas para o navegador. Recentemente, este trabalho evoluiu para um processo de padronização W3C onde o objetivo é transformar o componente WebDriver no Selenium na biblioteca de controle remoto du jour para agentes do usuário.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/purposes_and_main_functionalities/","title":"Objetivos e funcionalidades principais","tags":[],"description":"","content":" Ponto de entrada central para todos os testes Gerenciamento e controle dos nós / ambiente onde os navegadores rodam Escalonamento Executar testes em paralelo Teste de plataforma cruzada Balanceamento de carga  "},{"uri":"https://www.selenium.dev/documentation/pt-br/driver_idiosyncrasies/shared_capabilities/","title":"Recursos compartilhados","tags":[],"description":"","content":"Para criar uma nova sessão por Selenium WebDriver, a extremidade local deve fornecer os recursos básicos para a extremidade remota. A extremidade remota usa o mesmo conjunto de recursos para cria uma sessão e descreve os recursos da sessão atual.\nWebDriver fornece recursos que cada controle extremidade remota irá/deverá apoiar a implementação. A seguir estão os recursos que o WebDriver suporta:\nbrowserName: Este recurso é usado para definir o browserName para uma determinada sessão. Se o navegador especificado não estiver instalado na extremidade remota, a criação da sessão irá falhar\nbrowserVersion: Este recurso é opcional, usado para definir a versão do navegador disponível na extremidade remota. Por exemplo, se pedir o Chrome versão 75 em um sistema que tem apenas a versão 80 instalada, a criação da sessão irá falhar\npageLoadStrategy: Ao navegar para uma nova página via URL, por padrão o Selenium irá esperar até que a página esteja totalmente carregada antes de responder. Isso funciona bem para iniciantes, mas pode causar longos tempos de espera em páginas que carregam um grande número de recursos de terceiros. Usar uma estratégia não padrão pode tornar a execução de testes mais rápida em casos como este, mas também pode apresentar instabilidade onde os elementos na página mudam de posição conforme os elementos são carregados e mudam de tamanho.\nA estratégia de carregamento da página consulta o document.readyState conforme descrito na tabela abaixo:\n   Estrtégia Ready State Notas     normal complete Usado por padrão, aguarda o download de todos os recursos   eager interactive O acesso ao DOM está pronto, mas outros recursos, como imagens, ainda podem estar carregando   none Any Não bloqueia o WebDriver de nenhuma forma    platformName Isso identifica o sistema operacional na extremidade remota e buscar o platformName retorna o nome do sistema operacional.\nEm provedores baseados em nuvem, definir platformName define o sistema operacional na extremidade remota.\nacceptInsecureCerts Este recurso verifica se um Certificado TLS expirado (ou) inválido é usado durante a navegação durante uma sessão.\nSe o recurso for definido como false, um erro de certificado inseguro será retornado quando a navegação encontrar qualquer problema de certificado de domínio. Se definido como verdadeiro, o certificado inválido será confiável para o navegador.\nTodos os certificados autoassinados serão considerados confiáveis por esse recurso por padrão. Uma vez definido, o recurso acceptInsecureCerts terá um efeito para toda a sessão.\nTimeout de Sessão Uma session do WebDriver é imposta com um certo intervalo session timeout durante o qual o usuário pode controlar o comportamento de executar scripts ou recuperar informações do navegador.\nCada tempo limite de sessão é configurado com combinação de diferentes timeouts, conforme descrito abaixo:\nTimeout de Script: Especifica quando interromper um script em execução em um contexto de navegação atual. O tempo limite padrão 30.000 é imposto quando uma nova sessão é criada pelo WebDriver.\nTimeout de Carregamento de Página: Especifica o intervalo de tempo em que a página da web precisa ser carregado em um contexto de navegação atual. O tempo limite padrão 300.000 é imposto quando uma nova sessão é criada pelo WebDriver. Se os carregamento da página delimitar um determinado período de tempo, o script será interrompido por TimeoutException.\nTimeout de Espera Implícita: Isso especifica o tempo de espera pela estratégia de implicit element location quando localizando de elementos. O tempo limite padrão 0 é imposto quando uma nova sessão é criada pelo WebDriver.\nunhandledPromptBehavior Especifica o estado do user prompt handler da sessão atual. O padrão é dismiss and notify state (dispensar e notificar estado, em português)\nUser Prompt Handler Isso define qual ação deve ser tomada quando um o prompt do usuário se encontra na extremidade remota. Isso é definido pelo recurso unhandledPromptBehavior e tem os seguintes estados:\n dismiss accept dismiss and notify accept and notify ignore  setWindowRect Este comando altera o tamanho e a posição da atual janela de contexto de navegação. Este comando atua como setter para o comando getWindowRect que aceita largura, altura, x, y como argumentos opcionais.\nDurante a automação, o contexto de navegação atual será associado com estados de janela, que descrevem a visibilidade da janela do navegador. Os estados da janela são\n maximized minimized normal fullscreen  Definir Width ou Height não garante que o resultado o tamanho da janela corresponderá exatamente ao que foi inserido. Isto é porque alguns drivers podem não ser redimensionados em incrementos de pixel único. Devido a isso, buscar o estado / detalhes da janela por getWindowRect pode não corresponder igualmente aos valores definidos para o navegador.\nstrictFileInteractability O novo recurso indica se as verificações estritas de interatividade devem ser aplicadas aos elementos input type = file. Como as verificações de interatividade estrita estão desativadas por padrão, há uma mudança no comportamento ao usar Element Send Keys com controles de upload de arquivos ocultos.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/legacy_docs/selenium_rc/","title":"Selenium 1 (Selenium RC)","tags":[],"description":"","content":" Page being translated from English to Brazilian Portuguese. Do you speak Brazilian Portuguese? Help us to translate it by sending us pull requests!\n Introduction Selenium RC was the main Selenium project for a long time, before the WebDriver/Selenium merge brought up Selenium 2, a more powerful tool. It is worth to highlight that Selenium 1 is not supported anymore.\nHow Selenium RC Works First, we will describe how the components of Selenium RC operate and the role each plays in running your test scripts.\nRC Components Selenium RC components are:\n The Selenium Server which launches and kills browsers, interprets and runs the Selenese commands passed from the test program, and acts as an HTTP proxy, intercepting and verifying HTTP messages passed between the browser and the AUT. Client libraries which provide the interface between each programming language and the Selenium RC Server.  Here is a simplified architecture diagram:\nThe diagram shows the client libraries communicate with the Server passing each Selenium command for execution. Then the server passes the Selenium command to the browser using Selenium-Core JavaScript commands. The browser, using its JavaScript interpreter, executes the Selenium command. This runs the Selenese action or verification you specified in your test script.\nSelenium Server Selenium Server receives Selenium commands from your test program, interprets them, and reports back to your program the results of running those tests.\nThe RC server bundles Selenium Core and automatically injects it into the browser. This occurs when your test program opens the browser (using a client library API function). Selenium-Core is a JavaScript program, actually a set of JavaScript functions which interprets and executes Selenese commands using the browser\u0026rsquo;s built-in JavaScript interpreter.\nThe Server receives the Selenese commands from your test program using simple HTTP GET/POST requests. This means you can use any programming language that can send HTTP requests to automate Selenium tests on the browser.\nClient Libraries The client libraries provide the programming support that allows you to run Selenium commands from a program of your own design. There is a different client library for each supported language. A Selenium client library provides a programming interface (API), i.e., a set of functions, which run Selenium commands from your own program. Within each interface, there is a programming function that supports each Selenese command.\nThe client library takes a Selenese command and passes it to the Selenium Server for processing a specific action or test against the application under test (AUT). The client library also receives the result of that command and passes it back to your program. Your program can receive the result and store it into a program variable and report it as a success or failure, or possibly take corrective action if it was an unexpected error.\nSo to create a test program, you simply write a program that runs a set of Selenium commands using a client library API. And, optionally, if you already have a Selenese test script created in the Selenium-IDE, you can generate the Selenium RC code. The Selenium-IDE can translate (using its Export menu item) its Selenium commands into a client-driver\u0026rsquo;s API function calls. See the Selenium-IDE chapter for specifics on exporting RC code from Selenium-IDE.\nInstallation Installation is rather a misnomer for Selenium. Selenium has a set of libraries available in the programming language of your choice. You could download them from the downloads page.\nOnce you\u0026rsquo;ve chosen a language to work with, you simply need to:\n Install the Selenium RC Server. Set up a programming project using a language specific client driver.  Installing Selenium Server The Selenium RC server is simply a Java jar file (selenium-server-standalone-.jar), which doesn\u0026rsquo;t require any special installation. Just downloading the zip file and extracting the server in the desired directory is sufficient.\nRunning Selenium Server Before starting any tests you must start the server. Go to the directory where Selenium RC\u0026rsquo;s server is located and run the following from a command-line console.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar This can be simplified by creating a batch or shell executable file (.bat on Windows and .sh on Linux) containing the command above. Then make a shortcut to that executable on your desktop and simply double-click the icon to start the server.\nFor the server to run you\u0026rsquo;ll need Java installed and the PATH environment variable correctly configured to run it from the console. You can check that you have Java correctly installed by running the following on a console.\njava -version If you get a version number (which needs to be 1.5 or later), you\u0026rsquo;re ready to start using Selenium RC.\nUsing the Java Client Driver  Download Selenium java client driver zip from the SeleniumHQ downloads page. Extract selenium-java-.jar file Open your desired Java IDE (Eclipse, NetBeans, IntelliJ, Netweaver, etc.) Create a java project. Add the selenium-java-.jar files to your project as references. Add to your project classpath the file selenium-java-.jar. From Selenium-IDE, export a script to a Java file and include it in your Java project, or write your Selenium test in Java using the selenium-java-client API. The API is presented later in this chapter. You can either use JUnit, or TestNg to run your test, or you can write your own simple main() program. These concepts are explained later in this section. Run Selenium server from the console. Execute your test from the Java IDE or from the command-line.  For details on Java test project configuration, see the Appendix sections Configuring Selenium RC With Eclipse and Configuring Selenium RC With Intellij.\nUsing the Python Client Driver  Install Selenium via PIP, instructions linked at SeleniumHQ downloads page Either write your Selenium test in Python or export a script from Selenium-IDE to a python file. Run Selenium server from the console Execute your test from a console or your Python IDE  For details on Python client driver configuration, see the appendix Python Client Driver Configuration.\nUsing the .NET Client Driver  Download Selenium RC from the SeleniumHQ downloads page Extract the folder Download and install NUnit ( Note: You can use NUnit as your test engine. If you\u0026rsquo;re not familiar yet with NUnit, you can also write a simple main() function to run your tests; however NUnit is very useful as a test engine.) Open your desired .Net IDE (Visual Studio, SharpDevelop, MonoDevelop) Create a class library (.dll) Add references to the following DLLs: nmock.dll, nunit.core.dll, nunit. framework.dll, ThoughtWorks.Selenium.Core.dll, ThoughtWorks.Selenium.IntegrationTests.dll and ThoughtWorks.Selenium.UnitTests.dll Write your Selenium test in a .Net language (C#, VB.Net), or export a script from Selenium-IDE to a C# file and copy this code into the class file you just created. Write your own simple main() program or you can include NUnit in your project for running your test. These concepts are explained later in this chapter. Run Selenium server from console Run your test either from the IDE, from the NUnit GUI or from the command line  For specific details on .NET client driver configuration with Visual Studio, see the appendix .NET client driver configuration.\nUsing the Ruby Client Driver  If you do not already have RubyGems, install it from RubyForge. Run gem install selenium-client At the top of your test script, add require \u0026quot;selenium/client\u0026quot; Write your test script using any Ruby test harness (eg Test::Unit, Mini::Test or RSpec). Run Selenium RC server from the console. Execute your test in the same way you would run any other Ruby script.  For details on Ruby client driver configuration, see the Selenium-Client documentation_\nFrom Selenese to a Program The primary task for using Selenium RC is to convert your Selenese into a programming language. In this section, we provide several different language-specific examples.\nSample Test Script Let\u0026rsquo;s start with an example Selenese test script. Imagine recording the following test with Selenium-IDE.\n          open /    type q selenium rc   clickAndWait btnG    assertTextPresent Results * for selenium rc     Note: This example would work with the Google search page http://www.google.com\nSelenese as Programming Code Here is the test script exported (via Selenium-IDE) to each of the supported programming languages. If you have at least basic knowledge of an object- oriented programming language, you will understand how Selenium runs Selenese commands by reading one of these examples. To see an example in a specific language, select one of these buttons.\nCSharp using System; using System.Text; using System.Text.RegularExpressions; using System.Threading; using NUnit.Framework; using Selenium; namespace SeleniumTests { [TestFixture] public class NewTest { private ISelenium selenium; private StringBuilder verificationErrors; [SetUp] public void SetupTest() { selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); verificationErrors = new StringBuilder(); } [TearDown] public void TeardownTest() { try { selenium.Stop(); } catch (Exception) { // Ignore errors if unable to close the browser  } Assert.AreEqual(\u0026#34;\u0026#34;, verificationErrors.ToString()); } [Test] public void TheNewTest() { selenium.Open(\u0026#34;/\u0026#34;); selenium.Type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.Click(\u0026#34;btnG\u0026#34;); selenium.WaitForPageToLoad(\u0026#34;30000\u0026#34;); Assert.AreEqual(\u0026#34;selenium rc - Google Search\u0026#34;, selenium.GetTitle()); } } } Java /** Add JUnit framework to your classpath if not already there * for this example to work */ package com.example.tests; import com.thoughtworks.selenium.*; import java.util.regex.Pattern; public class NewTest extends SeleneseTestCase { public void setUp() throws Exception { setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); } public void testNew() throws Exception { selenium.open(\u0026#34;/\u0026#34;); selenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.click(\u0026#34;btnG\u0026#34;); selenium.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(selenium.isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); } } Php \u0026lt;?php require_once \u0026#39;PHPUnit/Extensions/SeleniumTestCase.php\u0026#39;; class Example extends PHPUnit_Extensions_SeleniumTestCase { function setUp() { $this-\u0026gt;setBrowser(\u0026#34;*firefox\u0026#34;); $this-\u0026gt;setBrowserUrl(\u0026#34;http://www.google.com/\u0026#34;); } function testMyTestCase() { $this-\u0026gt;open(\u0026#34;/\u0026#34;); $this-\u0026gt;type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); $this-\u0026gt;click(\u0026#34;btnG\u0026#34;); $this-\u0026gt;waitForPageToLoad(\u0026#34;30000\u0026#34;); $this-\u0026gt;assertTrue($this-\u0026gt;isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); } } ?\u0026gt; Python from selenium import selenium import unittest, time, re class NewTest(unittest.TestCase): def setUp(self): self.verificationErrors = [] self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() def test_new(self): sel = self.selenium sel.open(\u0026#34;/\u0026#34;) sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;) sel.click(\u0026#34;btnG\u0026#34;) sel.wait_for_page_to_load(\u0026#34;30000\u0026#34;) self.failUnless(sel.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;)) def tearDown(self): self.selenium.stop() self.assertEqual([], self.verificationErrors) Ruby require \u0026#34;selenium/client\u0026#34; require \u0026#34;test/unit\u0026#34; class NewTest \u0026lt; Test::Unit::TestCase def setup @verification_errors = [] if $selenium @selenium = $selenium else @selenium = Selenium::Client::Driver.new(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;, 60); @selenium.start end @selenium.set_context(\u0026#34;test_new\u0026#34;) end def teardown @selenium.stop unless $selenium assert_equal [], @verification_errors end def test_new @selenium.open \u0026#34;/\u0026#34; @selenium.type \u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34; @selenium.click \u0026#34;btnG\u0026#34; @selenium.wait_for_page_to_load \u0026#34;30000\u0026#34; assert @selenium.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;) end end In the next section we\u0026rsquo;ll explain how to build a test program using the generated code.\nProgramming Your Test Now we\u0026rsquo;ll illustrate how to program your own tests using examples in each of the supported programming languages. There are essentially two tasks:\n Generate your script into a programming language from Selenium-IDE, optionally modifying the result. Write a very simple main program that executes the generated code.  Optionally, you can adopt a test engine platform like JUnit or TestNG for Java, or NUnit for .NET if you are using one of those languages.\nHere, we show language-specific examples. The language-specific APIs tend to differ from one to another, so you\u0026rsquo;ll find a separate explanation for each.\n Java C# Python Ruby Perl, PHP  Java For Java, people use either JUnit or TestNG as the test engine.\nSome development environments like Eclipse have direct support for these via plug-ins. This makes it even easier. Teaching JUnit or TestNG is beyond the scope of this document however materials may be found online and there are publications available. If you are already a \u0026ldquo;java-shop\u0026rdquo; chances are your developers will already have some experience with one of these test frameworks.\nYou will probably want to rename the test class from \u0026ldquo;NewTest\u0026rdquo; to something of your own choosing. Also, you will need to change the browser-open parameters in the statement:\nselenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); The Selenium-IDE generated code will look like this. This example has comments added manually for additional clarity.\npackage com.example.tests; // We specify the package of our tests  import com.thoughtworks.selenium.*; // This is the driver\u0026#39;s import. You\u0026#39;ll use this for instantiating a  // browser and making it do what you need.  import java.util.regex.Pattern; // Selenium-IDE add the Pattern module because it\u0026#39;s sometimes used for  // regex validations. You can remove the module if it\u0026#39;s not used in your  // script.  public class NewTest extends SeleneseTestCase { // We create our Selenium test case  public void setUp() throws Exception { setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); // We instantiate and start the browser  } public void testNew() throws Exception { selenium.open(\u0026#34;/\u0026#34;); selenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.click(\u0026#34;btnG\u0026#34;); selenium.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(selenium.isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); // These are the real test steps  } } C# The .NET Client Driver works with Microsoft.NET. It can be used with any .NET testing framework like NUnit or the Visual Studio 2005 Team System.\nSelenium-IDE assumes you will use NUnit as your testing framework. You can see this in the generated code below. It includes the using statement for NUnit along with corresponding NUnit attributes identifying the role for each member function of the test class.\nYou will probably have to rename the test class from \u0026ldquo;NewTest\u0026rdquo; to something of your own choosing. Also, you will need to change the browser-open parameters in the statement:\nselenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); The generated code will look similar to this.\nusing System; using System.Text; using System.Text.RegularExpressions; using System.Threading; using NUnit.Framework; using Selenium; namespace SeleniumTests { [TestFixture] public class NewTest { private ISelenium selenium; private StringBuilder verificationErrors; [SetUp] public void SetupTest() { selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); verificationErrors = new StringBuilder(); } [TearDown] public void TeardownTest() { try { selenium.Stop(); } catch (Exception) { // Ignore errors if unable to close the browser  } Assert.AreEqual(\u0026#34;\u0026#34;, verificationErrors.ToString()); } [Test] public void TheNewTest() { // Open Google search engine.  selenium.Open(\u0026#34;http://www.google.com/\u0026#34;); // Assert Title of page.  Assert.AreEqual(\u0026#34;Google\u0026#34;, selenium.GetTitle()); // Provide search term as \u0026#34;Selenium OpenQA\u0026#34;  selenium.Type(\u0026#34;q\u0026#34;, \u0026#34;Selenium OpenQA\u0026#34;); // Read the keyed search term and assert it.  Assert.AreEqual(\u0026#34;Selenium OpenQA\u0026#34;, selenium.GetValue(\u0026#34;q\u0026#34;)); // Click on Search button.  selenium.Click(\u0026#34;btnG\u0026#34;); // Wait for page to load.  selenium.WaitForPageToLoad(\u0026#34;5000\u0026#34;); // Assert that \u0026#34;www.openqa.org\u0026#34; is available in search results.  Assert.IsTrue(selenium.IsTextPresent(\u0026#34;www.openqa.org\u0026#34;)); // Assert that page title is - \u0026#34;Selenium OpenQA - Google Search\u0026#34;  Assert.AreEqual(\u0026#34;Selenium OpenQA - Google Search\u0026#34;, selenium.GetTitle()); } } } You can allow NUnit to manage the execution of your tests. Or alternatively, you can write a simple main() program that instantiates the test object and runs each of the three methods, SetupTest(), TheNewTest(), and TeardownTest() in turn.\nPython Pyunit is the test framework to use for Python.\nThe basic test structure is:\nfrom selenium import selenium # This is the driver\u0026#39;s import. You\u0026#39;ll use this class for instantiating a # browser and making it do what you need. import unittest, time, re # This are the basic imports added by Selenium-IDE by default. # You can remove the modules if they are not used in your script. class NewTest(unittest.TestCase): # We create our unittest test case def setUp(self): self.verificationErrors = [] # This is an empty array where we will store any verification errors # we find in our tests self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() # We instantiate and start the browser def test_new(self): # This is the test code. Here you should put the actions you need # the browser to do during your test. sel = self.selenium # We assign the browser to the variable \u0026#34;sel\u0026#34; (just to save us from  # typing \u0026#34;self.selenium\u0026#34; each time we want to call the browser). sel.open(\u0026#34;/\u0026#34;) sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;) sel.click(\u0026#34;btnG\u0026#34;) sel.wait_for_page_to_load(\u0026#34;30000\u0026#34;) self.failUnless(sel.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;)) # These are the real test steps def tearDown(self): self.selenium.stop() # we close the browser (I\u0026#39;d recommend you to comment this line while # you are creating and debugging your tests) self.assertEqual([], self.verificationErrors) # And make the test fail if we found that any verification errors # were found Ruby Old (pre 2.0) versions of Selenium-IDE generate Ruby code that requires the old Selenium gem. Therefore, it is advisable to update any Ruby scripts generated by the IDE as follows:\n  On line 1, change require \u0026quot;selenium\u0026quot; to require \u0026quot;selenium/client\u0026quot;\n  On line 11, change Selenium::SeleniumDriver.new to Selenium::Client::Driver.new\n  You probably also want to change the class name to something more informative than \u0026ldquo;Untitled,\u0026rdquo; and change the test method\u0026rsquo;s name to something other than \u0026ldquo;test_untitled.\u0026rdquo;\nHere is a simple example created by modifying the Ruby code generated by Selenium IDE, as described above.\n# load the Selenium-Client gem require \u0026#34;selenium/client\u0026#34; # Load Test::Unit, Ruby\u0026#39;s default test framework. # If you prefer RSpec, see the examples in the Selenium-Client # documentation. require \u0026#34;test/unit\u0026#34; class Untitled \u0026lt; Test::Unit::TestCase # The setup method is called before each test. def setup # This array is used to capture errors and display them at the # end of the test run. @verification_errors = [] # Create a new instance of the Selenium-Client driver. @selenium = Selenium::Client::Driver.new \\ :host =\u0026gt; \u0026#34;localhost\u0026#34;, :port =\u0026gt; 4444, :browser =\u0026gt; \u0026#34;*chrome\u0026#34;, :url =\u0026gt; \u0026#34;http://www.google.com/\u0026#34;, :timeout_in_second =\u0026gt; 60 # Start the browser session @selenium.start # Print a message in the browser-side log and status bar # (optional). @selenium.set_context(\u0026#34;test_untitled\u0026#34;) end # The teardown method is called after each test. def teardown # Stop the browser session. @selenium.stop # Print the array of error messages, if any. assert_equal [], @verification_errors end # This is the main body of your test. def test_untitled # Open the root of the site we specified when we created the # new driver instance, above. @selenium.open \u0026#34;/\u0026#34; # Type \u0026#39;selenium rc\u0026#39; into the field named \u0026#39;q\u0026#39; @selenium.type \u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34; # Click the button named \u0026#34;btnG\u0026#34; @selenium.click \u0026#34;btnG\u0026#34; # Wait for the search results page to load. # Note that we don\u0026#39;t need to set a timeout here, because that # was specified when we created the new driver instance, above. @selenium.wait_for_page_to_load begin # Test whether the search results contain the expected text. # Notice that the star (*) is a wildcard that matches any # number of characters. assert @selenium.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;) rescue Test::Unit::AssertionFailedError # If the assertion fails, push it onto the array of errors. @verification_errors \u0026lt;\u0026lt; $! end end end Perl, PHP The members of the documentation team have not used Selenium RC with Perl or PHP. If you are using Selenium RC with either of these two languages please contact the Documentation Team (see the chapter on contributing). We would love to include some examples from you and your experiences, to support Perl and PHP users.\nLearning the API The Selenium RC API uses naming conventions that, assuming you understand Selenese, much of the interface\nwill be self-explanatory. Here, however, we explain the most critical and possibly less obvious aspects.\nStarting the Browser CSharp selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); Java setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); Perl my $sel = Test::WWW::Selenium-\u0026gt;new( host =\u0026gt; \u0026#34;localhost\u0026#34;, port =\u0026gt; 4444, browser =\u0026gt; \u0026#34;*firefox\u0026#34;, browser_url =\u0026gt; \u0026#34;http://www.google.com/\u0026#34; ); Php $this-\u0026gt;setBrowser(\u0026#34;*firefox\u0026#34;); $this-\u0026gt;setBrowserUrl(\u0026#34;http://www.google.com/\u0026#34;); Python self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() Ruby @selenium = Selenium::ClientDriver.new(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;, 10000); @selenium.start Each of these examples opens the browser and represents that browser by assigning a \u0026ldquo;browser instance\u0026rdquo; to a program variable. This program variable is then used to call methods from the browser. These methods execute the Selenium commands, i.e. like open or type or the verify commands.\nThe parameters required when creating the browser instance are:\n  host Specifies the IP address of the computer where the server is located. Usually, this is the same machine as where the client is running, so in this case localhost is passed. In some clients this is an optional parameter.\n  port Specifies the TCP/IP socket where the server is listening waiting for the client to establish a connection. This also is optional in some client drivers.\n  browser The browser in which you want to run the tests. This is a required parameter.\n  url The base url of the application under test. This is required by all the client libs and is integral information for starting up the browser-proxy-AUT communication.\n  Note that some of the client libraries require the browser to be started explicitly by calling its start() method.\nRunning Commands Once you have the browser initialized and assigned to a variable (generally named \u0026ldquo;selenium\u0026rdquo;) you can make it run Selenese commands by calling the respective methods from the browser variable. For example, to call the type method of the selenium object:\nselenium.type(\u0026#34;field-id\u0026#34;,\u0026#34;string to type\u0026#34;) In the background the browser will actually perform a type operation, essentially identical to a user typing input into the browser, by\nusing the locator and the string you specified during the method call.\nReporting Results Selenium RC does not have its own mechanism for reporting results. Rather, it allows you to build your reporting customized to your needs using features of your chosen programming language. That\u0026rsquo;s great, but what if you simply want something quick that\u0026rsquo;s already done for you? Often an existing library or test framework can meet your needs faster than developing your own test reporting code.\nTest Framework Reporting Tools Test frameworks are available for many programming languages. These, along with their primary function of providing a flexible test engine for executing your tests, include library code for reporting results. For example, Java has two commonly used test frameworks, JUnit and TestNG. .NET also has its own, NUnit.\nWe won\u0026rsquo;t teach the frameworks themselves here; that\u0026rsquo;s beyond the scope of this user guide. We will simply introduce the framework features that relate to Selenium along with some techniques you can apply. There are good books available on these test frameworks however along with information on the internet.\nTest Report Libraries Also available are third-party libraries specifically created for reporting test results in your chosen programming language. These often support a variety of formats such as HTML or PDF.\nWhat\u0026rsquo;s The Best Approach? Most people new to the testing frameworks will begin with the framework\u0026rsquo;s built-in reporting features. From there most will examine any available libraries as that\u0026rsquo;s less time consuming than developing your own. As you begin to use Selenium no doubt you will start putting in your own \u0026ldquo;print statements\u0026rdquo; for reporting progress. That may gradually lead to you developing your own reporting, possibly in parallel to using a library or test framework. Regardless, after the initial, but short, learning curve you will naturally develop what works best for your own situation.\nTest Reporting Examples To illustrate, we\u0026rsquo;ll direct you to some specific tools in some of the other languages supported by Selenium. The ones listed here are commonly used and have been used extensively (and therefore recommended) by the authors of this guide.\nTest Reports in Java   If Selenium Test cases are developed using JUnit then JUnit Report can be used to generate test reports.\n  If Selenium Test cases are developed using TestNG then no external task is required to generate test reports. The TestNG framework generates an HTML report which list details of tests.\n  ReportNG is a HTML reporting plug-in for the TestNG framework. It is intended as a replacement for the default TestNG HTML report. ReportNG provides a simple, colour-coded view of the test results.\n  Logging the Selenese Commands  Logging Selenium can be used to generate a report of all the Selenese commands in your test along with the success or failure of each. Logging Selenium extends the Java client driver to add this Selenese logging ability.  Test Reports for Python  When using Python Client Driver then HTMLTestRunner can be used to generate a Test Report.  Test Reports for Ruby  If RSpec framework is used for writing Selenium Test Cases in Ruby then its HTML report can be used to generate a test report.  Adding Some Spice to Your Tests Now we\u0026rsquo;ll get to the whole reason for using Selenium RC, adding programming logic to your tests. It\u0026rsquo;s the same as for any program. Program flow is controlled using condition statements and iteration. In addition you can report progress information using I/O. In this section we\u0026rsquo;ll show some examples of how programming language constructs can be combined with Selenium to solve common testing problems.\nYou will find as you transition from the simple tests of the existence of page elements to tests of dynamic functionality involving multiple web-pages and varying data that you will require programming logic for verifying expected results. Basically, the Selenium-IDE does not support iteration and standard condition statements. You can do some conditions by embedding JavaScript in Selenese parameters, however iteration is impossible, and most conditions will be much easier in a\nprogramming language. In addition, you may need exception handling for error recovery. For these reasons and others, we have written this section to illustrate the use of common programming techniques to give you greater \u0026lsquo;verification power\u0026rsquo; in your automated testing.\nThe examples in this section are written in C# and Java, although the code is simple and can be easily adapted to the other supported languages. If you have some basic knowledge of an object-oriented programming language you shouldn\u0026rsquo;t have difficulty understanding this section.\nIteration Iteration is one of the most common things people need to do in their tests. For example, you may want to to execute a search multiple times. Or, perhaps for verifying your test results you need to process a \u0026ldquo;result set\u0026rdquo; returned from a database.\nUsing the same Google search example we used earlier, let\u0026rsquo;s check the Selenium search results. This test could use the Selenese:\n          open /    type q selenium rc   clickAndWait btnG    assertTextPresent Results * for selenium rc    type q selenium ide   clickAndWait btnG    assertTextPresent Results * for selenium ide    type q selenium grid   clickAndWait btnG    assertTextPresent Results * for selenium grid     The code has been repeated to run the same steps 3 times. But multiple copies of the same code is not good program practice because it\u0026rsquo;s more work to maintain. By using a programming language, we can iterate over the search results for a more flexible and maintainable solution.\nIn C# // Collection of String values.  String[] arr = {\u0026#34;ide\u0026#34;, \u0026#34;rc\u0026#34;, \u0026#34;grid\u0026#34;}; // Execute loop for each String in array \u0026#39;arr\u0026#39;.  foreach (String s in arr) { sel.open(\u0026#34;/\u0026#34;); sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium \u0026#34; +s); sel.click(\u0026#34;btnG\u0026#34;); sel.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(\u0026#34;Expected text: \u0026#34; +s+ \u0026#34; is missing on page.\u0026#34; , sel.isTextPresent(\u0026#34;Results * for selenium \u0026#34; + s)); } Condition Statements To illustrate using conditions in tests we\u0026rsquo;ll start with an example. A common problem encountered while running Selenium tests occurs when an expected element is not available on page. For example, when running the following line:\nselenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium \u0026#34; +s); If element \u0026lsquo;q\u0026rsquo; is not on the page then an exception is thrown:\ncom.thoughtworks.selenium.SeleniumException: ERROR: Element q not found This can cause your test to abort. For some tests that\u0026rsquo;s what you want. But often that is not desirable as your test script has many other subsequent tests to perform.\nA better approach is to first validate whether the element is really present and then take alternatives when it it is not. Let\u0026rsquo;s look at this using Java.\n// If element is available on page then perform type operation.  if(selenium.isElementPresent(\u0026#34;q\u0026#34;)) { selenium.type(\u0026#34;q\u0026#34;, \u0026#34;Selenium rc\u0026#34;); } else { System.out.printf(\u0026#34;Element: \u0026#34; +q+ \u0026#34; is not available on page.\u0026#34;) } The advantage of this approach is to continue with test execution even if some UI elements are not available on page.\nExecuting JavaScript from Your Test JavaScript comes very handy in exercising an application which is not directly supported by Selenium. The getEval method of Selenium API can be used to execute JavaScript from Selenium RC.\nConsider an application having check boxes with no static identifiers. In this case one could evaluate JavaScript from Selenium RC to get ids of all check boxes and then exercise them.\npublic static String[] getAllCheckboxIds () { String script = \u0026#34;var inputId = new Array();\u0026#34;;// Create array in java script. \tscript += \u0026#34;var cnt = 0;\u0026#34;; // Counter for check box ids. \tscript += \u0026#34;var inputFields = new Array();\u0026#34;; // Create array in java script. \tscript += \u0026#34;inputFields = window.document.getElementsByTagName(\u0026#39;input\u0026#39;);\u0026#34;; // Collect input elements. \tscript += \u0026#34;for(var i=0; i\u0026lt;inputFields.length; i++) {\u0026#34;; // Loop through the collected elements. \tscript += \u0026#34;if(inputFields[i].id !=null \u0026#34; + \u0026#34;\u0026amp;\u0026amp; inputFields[i].id !=\u0026#39;undefined\u0026#39; \u0026#34; + \u0026#34;\u0026amp;\u0026amp; inputFields[i].getAttribute(\u0026#39;type\u0026#39;) == \u0026#39;checkbox\u0026#39;) {\u0026#34;; // If input field is of type check box and input id is not null. \tscript += \u0026#34;inputId[cnt]=inputFields[i].id ;\u0026#34; + // Save check box id to inputId array. \t\u0026#34;cnt++;\u0026#34; + // increment the counter. \t\u0026#34;}\u0026#34; + // end of if. \t\u0026#34;}\u0026#34;; // end of for. \tscript += \u0026#34;inputId.toString();\u0026#34; ;// Convert array in to string.\t\tString[] checkboxIds = selenium.getEval(script).split(\u0026#34;,\u0026#34;); // Split the string. \treturn checkboxIds; } To count number of images on a page:\nselenium.getEval(\u0026#34;window.document.images.length;\u0026#34;); Remember to use window object in case of DOM expressions as by default selenium window is referred to, not the test window.\nServer Options When the server is launched, command line options can be used to change the default server behaviour.\nRecall, the server is started by running the following.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar To see the list of options, run the server with the -h option.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -h You\u0026rsquo;ll see a list of all the options you can use with the server and a brief description of each. The provided descriptions will not always be enough, so we\u0026rsquo;ve provided explanations for some of the more important options.\nProxy Configuration If your AUT is behind an HTTP proxy which requires authentication then you should configure http.proxyHost, http.proxyPort, http.proxyUser and http.proxyPassword using the following command.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -Dhttp.proxyHost=proxy.com -Dhttp.proxyPort=8080 -Dhttp.proxyUser=username -Dhttp.proxyPassword=password Multi-Window Mode If you are using Selenium 1.0 you can probably skip this section, since multiwindow mode is the default behavior. However, prior to version 1.0, Selenium by default ran the application under test in a sub frame as shown here.\nSome applications didn\u0026rsquo;t run correctly in a sub frame, and needed to be loaded into the top frame of the window. The multi-window mode option allowed the AUT to run in a separate window rather than in the default frame where it could then have the top frame it required.\nFor older versions of Selenium you must specify multiwindow mode explicitly with the following option:\n-multiwindow As of Selenium RC 1.0, if you want to run your test within a single frame (i.e. using the standard for earlier Selenium versions) you can state this to the Selenium Server using the option\n-singlewindow Specifying the Firefox Profile Firefox will not run two instances simultaneously unless you specify a separate profile for each instance. Selenium RC 1.0 and later runs in a separate profile automatically, so if you are using Selenium 1.0, you can probably skip this section. However, if you\u0026rsquo;re using an older version of Selenium or if you need to use a specific profile for your tests (such as adding an https certificate or having some addons installed), you will need to explicitly specify the profile.\nFirst, to create a separate Firefox profile, follow this procedure. Open the Windows Start menu, select \u0026ldquo;Run\u0026rdquo;, then type and enter one of the following:\nfirefox.exe -profilemanager firefox.exe -P Create the new profile using the dialog. Then when you run Selenium Server, tell it to use this new Firefox profile with the server command-line option -firefoxProfileTemplate and specify the path to the profile using its filename and directory path.\n-firefoxProfileTemplate \u0026#34;path to the profile\u0026#34; Warning: Be sure to put your profile in a new folder separate from the default!!! The Firefox profile manager tool will delete all files in a folder if you delete a profile, regardless of whether they are profile files or not.\nMore information about Firefox profiles can be found in Mozilla\u0026rsquo;s Knowledge Base\nRun Selenese Directly Within the Server Using -htmlSuite You can run Selenese html files directly within the Selenium Server by passing the html file to the server\u0026rsquo;s command line. For instance:\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -htmlSuite \u0026#34;*firefox\u0026#34; \u0026#34;http://www.google.com\u0026#34; \u0026#34;c:\\absolute\\path\\to\\my\\HTMLSuite.html\u0026#34; \u0026#34;c:\\absolute\\path\\to\\my\\results.html\u0026#34; This will automatically launch your HTML suite, run all the tests and save a nice HTML report with the results.\nNote: When using this option, the server will start the tests and wait for a specified number of seconds for the test to complete; if the test doesn\u0026rsquo;t complete within that amount of time, the command will exit with a non-zero exit code and no results file will be generated.\nThis command line is very long so be careful when you type it. Note this requires you to pass in an HTML Selenese suite, not a single test. Also be aware the -htmlSuite option is incompatible with -interactive You cannot run both at the same time.\nSelenium Server Logging Server-Side Logs When launching Selenium server the -log option can be used to record valuable debugging information reported by the Selenium Server to a text file.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -log selenium.log This log file is more verbose than the standard console logs (it includes DEBUG level logging messages). The log file also includes the logger name, and the ID number of the thread that logged the message. For example:\n20:44:25 DEBUG [12] org.openqa.selenium.server.SeleniumDriverResourceHandler - Browser 465828/:top frame1 posted START NEW The message format is\nTIMESTAMP(HH:mm:ss) LEVEL [THREAD] LOGGER - MESSAGE This message may be multiline.\nBrowser-Side Logs JavaScript on the browser side (Selenium Core) also logs important messages; in many cases, these can be more useful to the end-user than the regular Selenium Server logs. To access browser-side logs, pass the -browserSideLog argument to the Selenium Server.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -browserSideLog -browserSideLog must be combined with the -log argument, to log browserSideLogs (as well as all other DEBUG level logging messages) to a file.\nSpecifying the Path to a Specific Browser You can specify to Selenium RC a path to a specific browser. This is useful if you have different versions of the same browser and you wish to use a specific one. Also, this is used to allow your tests to run against a browser not directly supported by Selenium RC. When specifying the run mode, use the *custom specifier followed by the full path to the browser\u0026rsquo;s executable:\n*custom \u0026lt;path to browser\u0026gt; Selenium RC Architecture Note: This topic tries to explain the technical implementation behind Selenium RC. It\u0026rsquo;s not fundamental for a Selenium user to know this, but could be useful for understanding some of the problems you might find in the future.\nTo understand in detail how Selenium RC Server works and why it uses proxy injection and heightened privilege modes you must first understand the same origin policy_.\nThe Same Origin Policy The main restriction that Selenium faces is the Same Origin Policy. This security restriction is applied by every browser in the market and its objective is to ensure that a site\u0026rsquo;s content will never be accessible by a script from another site. The Same Origin Policy dictates that any code loaded within the browser can only operate within that website\u0026rsquo;s domain. It cannot perform functions on another website. So for example, if the browser loads JavaScript code when it loads www.mysite.com, it cannot run that loaded code against www.mysite2.com\u0026ndash;even if that\u0026rsquo;s another of your sites. If this were possible, a script placed on any website you open would be able to read information on your bank account if you had the account page opened on other tab. This is called XSS (Cross-site Scripting).\nTo work within this policy, Selenium-Core (and its JavaScript commands that make all the magic happen) must be placed in the same origin as the Application Under Test (same URL).\nHistorically, Selenium-Core was limited by this problem since it was implemented in JavaScript. Selenium RC is not, however, restricted by the Same Origin Policy. Its use of the Selenium Server as a proxy avoids this problem. It, essentially, tells the browser that the browser is working on a single \u0026ldquo;spoofed\u0026rdquo; website that the Server provides.\nNote: You can find additional information about this topic on Wikipedia pages about Same Origin Policy and XSS.\nProxy Injection The first method Selenium used to avoid the The Same Origin Policy was Proxy Injection. In Proxy Injection Mode, the Selenium Server acts as a client-configured HTTP proxy1, that sits between the browser and the Application Under Test2. It then masks the AUT under a fictional URL (embedding Selenium-Core and the set of tests and delivering them as if they were coming from the same origin).\nHere is an architectural diagram.\nAs a test suite starts in your favorite language, the following happens:\n The client/driver establishes a connection with the selenium-RC server. Selenium RC server launches a browser (or reuses an old one) with a URL that injects Selenium-Core\u0026rsquo;s JavaScript into the browser-loaded web page. The client-driver passes a Selenese command to the server. The Server interprets the command and then triggers the corresponding JavaScript execution to execute that command within the browser. Selenium-Core instructs the browser to act on that first instruction, typically opening a page of the AUT. The browser receives the open request and asks for the website\u0026rsquo;s content from the Selenium RC server (set as the HTTP proxy for the browser to use). Selenium RC server communicates with the Web server asking for the page and once it receives it, it sends the page to the browser masking the origin to look like the page comes from the same server as Selenium-Core (this allows Selenium-Core to comply with the Same Origin Policy). The browser receives the web page and renders it in the frame/window reserved for it.  Heightened Privileges Browsers This workflow in this method is very similar to Proxy Injection but the main difference is that the browsers are launched in a special mode called Heightened Privileges, which allows websites to do things that are not commonly permitted (as doing XSS_, or filling file upload inputs and pretty useful stuff for Selenium). By using these browser modes, Selenium Core is able to directly open the AUT and read/interact with its content without having to pass the whole AUT through the Selenium RC server.\nHere is the architectural diagram.\nAs a test suite starts in your favorite language, the following happens:\n The client/driver establishes a connection with the selenium-RC server. Selenium RC server launches a browser (or reuses an old one) with a URL that will load Selenium-Core in the web page. Selenium-Core gets the first instruction from the client/driver (via another HTTP request made to the Selenium RC Server). Selenium-Core acts on that first instruction, typically opening a page of the AUT. The browser receives the open request and asks the Web Server for the page. Once the browser receives the web page, renders it in the frame/window reserved for it.  Handling HTTPS and Security Popups Many applications switch from using HTTP to HTTPS when they need to send encrypted information such as passwords or credit card information. This is common with many of today\u0026rsquo;s web applications. Selenium RC supports this.\nTo ensure the HTTPS site is genuine, the browser will need a security certificate. Otherwise, when the browser accesses the AUT using HTTPS, it will assume that application is not \u0026lsquo;trusted\u0026rsquo;. When this occurs the browser displays security popups, and these popups cannot be closed using Selenium RC.\nWhen dealing with HTTPS in a Selenium RC test, you must use a run mode that supports this and handles the security certificate for you. You specify the run mode when your test program initializes Selenium.\nIn Selenium RC 1.0 beta 2 and later use *firefox or *iexplore for the run mode. In earlier versions, including Selenium RC 1.0 beta 1, use *chrome or *iehta, for the run mode. Using these run modes, you will not need to install any special security certificates; Selenium RC will handle it for you.\nIn version 1.0 the run modes *firefox or *iexplore are recommended. However, there are additional run modes of *iexploreproxy and *firefoxproxy. These are provided for backwards compatibility only, and should not be used unless required by legacy test programs. Their use will present limitations with security certificate handling and with the running of multiple windows if your application opens additional browser windows.\nIn earlier versions of Selenium RC, *chrome or *iehta were the run modes that supported HTTPS and the handling of security popups. These were considered ‘experimental modes although they became quite stable and many people used them. If you are using Selenium 1.0 you do not need, and should not use, these older run modes.\nSecurity Certificates Explained Normally, your browser will trust the application you are testing by installing a security certificate which you already own. You can check this in your browser\u0026rsquo;s options or Internet properties (if you don\u0026rsquo;t know your AUT\u0026rsquo;s security certificate ask your system administrator). When Selenium loads your browser it injects code to intercept messages between the browser and the server. The browser now thinks untrusted software is trying to look like your application. It responds by alerting you with popup messages.\nTo get around this, Selenium RC, (again when using a run mode that support this) will install its own security certificate, temporarily, to your client machine in a place where the browser can access it. This tricks the browser into thinking it\u0026rsquo;s accessing a site different from your AUT and effectively suppresses the popups.\nAnother method used with earlier versions of Selenium was to install the Cybervillians security certificate provided with your Selenium installation. Most users should no longer need to do this however; if you are running Selenium RC in proxy injection mode, you may need to explicitly install this security certificate.\nSupporting Additional Browsers and Browser Configurations The Selenium API supports running against multiple browsers in addition to Internet Explorer and Mozilla Firefox. See the https://selenium.dev website for supported browsers. In addition, when a browser is not directly supported, you may still run your Selenium tests against a browser of your choosing by using the \u0026ldquo;*custom\u0026rdquo; run-mode (i.e. in place of *firefox or *iexplore) when your test application starts the browser. With this, you pass in the path to the browsers executable within the API call. This can also be done from the Server in interactive mode.\ncmd=getNewBrowserSession\u0026amp;1=*custom c:\\Program Files\\Mozilla Firefox\\MyBrowser.exe\u0026amp;2=http://www.google.com Running Tests with Different Browser Configurations Normally Selenium RC automatically configures the browser, but if you launch the browser using the \u0026ldquo;*custom\u0026rdquo; run mode, you can force Selenium RC to launch the browser as-is, without using an automatic configuration.\nFor example, you can launch Firefox with a custom configuration like this:\ncmd=getNewBrowserSession\u0026amp;1=*custom c:\\Program Files\\Mozilla Firefox\\firefox.exe\u0026amp;2=http://www.google.com Note that when launching the browser this way, you must manually configure the browser to use the Selenium Server as a proxy. Normally this just means opening your browser preferences and specifying \u0026ldquo;localhost:4444\u0026rdquo; as an HTTP proxy, but instructions for this can differ radically from browser to browser. Consult your browser\u0026rsquo;s documentation for details.\nBe aware that Mozilla browsers can vary in how they start and stop. One may need to set the MOZ_NO_REMOTE environment variable to make Mozilla browsers behave a little more predictably. Unix users should avoid launching the browser using a shell script; it\u0026rsquo;s generally better to use the binary executable (e.g. firefox-bin) directly.\nTroubleshooting Common Problems When getting started with Selenium RC there\u0026rsquo;s a few potential problems that are commonly encountered. We present them along with their solutions here.\nUnable to Connect to Server When your test program cannot connect to the Selenium Server, Selenium throws an exception in your test program. It should display this message or a similar one:\n\u0026#34;Unable to connect to remote server (Inner Exception Message: No connection could be made because the target machine actively refused it )\u0026#34; (using .NET and XP Service Pack 2) If you see a message like this, be sure you started the Selenium Server. If so, then there is a problem with the connectivity between the Selenium Client Library and the Selenium Server.\nWhen starting with Selenium RC, most people begin by running their test program (with a Selenium Client Library) and the Selenium Server on the same machine. To do this use \u0026ldquo;localhost\u0026rdquo; as your connection parameter. We recommend beginning this way since it reduces the influence of potential networking problems which you\u0026rsquo;re getting started. Assuming your operating system has typical networking and TCP/IP settings you should have little difficulty. In truth, many people choose to run the tests this way.\nIf, however, you do want to run Selenium Server on a remote machine, the connectivity should be fine assuming you have valid TCP/IP connectivity between the two machines.\nIf you have difficulty connecting, you can use common networking tools like ping, telnet, ifconfig(Unix)/ipconfig (Windows), etc to ensure you have a valid network connection. If unfamilar with these, your system administrator can assist you.\nUnable to Load the Browser Ok, not a friendly error message, sorry, but if the Selenium Server cannot load the browser you will likely see this error.\n(500) Internal Server Error This could be caused by\n Firefox (prior to Selenium 1.0) cannot start because the browser is already open and you did not specify a separate profile. See the section on Firefox profiles under Server Options. The run mode you\u0026rsquo;re using doesn\u0026rsquo;t match any browser on your machine. Check the parameters you passed to Selenium when you program opens the browser. You specified the path to the browser explicitly (using \u0026ldquo;*custom\u0026rdquo;\u0026ndash;see above) but the path is incorrect. Check to be sure the path is correct. Also check the user group to be sure there are no known issues with your browser and the \u0026ldquo;*custom\u0026rdquo; parameters.  Selenium Cannot Find the AUT If your test program starts the browser successfully, but the browser doesn\u0026rsquo;t display the website you\u0026rsquo;re testing, the most likely cause is your test program is not using the correct URL.\nThis can easily happen. When you use Selenium-IDE to export your script, it inserts a dummy URL. You must manually change the URL to the correct one for your application to be tested.\nFirefox Refused Shutdown While Preparing a Profile This most often occurs when you run your Selenium RC test program against Firefox, but you already have a Firefox browser session running and, you didn\u0026rsquo;t specify a separate profile when you started the Selenium Server. The error from the test program looks like this:\nError: java.lang.RuntimeException: Firefox refused shutdown while preparing a profile Here\u0026rsquo;s the complete error message from the server:\n16:20:03.919 INFO - Preparing Firefox profile... 16:20:27.822 WARN - GET /selenium-server/driver/?cmd=getNewBrowserSession\u0026amp;1=*fir efox\u0026amp;2=http%3a%2f%2fsage-webapp1.qa.idc.com HTTP/1.1 java.lang.RuntimeException: Firefox refused shutdown while preparing a profile at org.openqa.selenium.server.browserlaunchers.FirefoxCustomProfileLaunc her.waitForFullProfileToBeCreated(FirefoxCustomProfileLauncher.java:277) ... Caused by: org.openqa.selenium.server.browserlaunchers.FirefoxCustomProfileLaunc her$FileLockRemainedException: Lock file still present! C:\\DOCUME~1\\jsvec\\LOCALS ~1\\Temp\\customProfileDir203138\\parent.lock To resolve this, see the section on Specifying a Separate Firefox Profile\nVersioning Problems Make sure your version of Selenium supports the version of your browser. For example, Selenium RC 0.92 does not support Firefox 3. At times you may be lucky (I was). But don\u0026rsquo;t forget to check which browser versions are supported by the version of Selenium you are using. When in doubt, use the latest release version of Selenium with the most widely used version of your browser.\nError message: \u0026ldquo;(Unsupported major.minor version 49.0)\u0026rdquo; while starting server This error says you\u0026rsquo;re not using a correct version of Java. The Selenium Server requires Java 1.5 or higher.\nTo check double-check your java version, run this from the command line.\njava -version You should see a message showing the Java version.\njava version \u0026#34;1.5.0_07\u0026#34; Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_07-b03) Java HotSpot(TM) Client VM (build 1.5.0_07-b03, mixed mode) If you see a lower version number, you may need to update the JRE, or you may simply need to add it to your PATH environment variable.\n404 error when running the getNewBrowserSession command If you\u0026rsquo;re getting a 404 error while attempting to open a page on \u0026ldquo;http://www.google.com/selenium-server/\u0026quot;, then it must be because the Selenium Server was not correctly configured as a proxy. The \u0026ldquo;selenium-server\u0026rdquo; directory doesn\u0026rsquo;t exist on google.com; it only appears to exist when the proxy is properly configured. Proxy Configuration highly depends on how the browser is launched with firefox, iexplore, opera, or custom.\n  iexplore: If the browser is launched using *iexplore, you could be having a problem with Internet Explorer\u0026rsquo;s proxy settings. Selenium Server attempts To configure the global proxy settings in the Internet Options Control Panel. You must make sure that those are correctly configured when Selenium Server launches the browser. Try looking at your Internet Options control panel. Click on the \u0026ldquo;Connections\u0026rdquo; tab and click on \u0026ldquo;LAN Settings\u0026rdquo;.\n If you need to use a proxy to access the application you want to test, you\u0026rsquo;ll need to start Selenium Server with \u0026ldquo;-Dhttp.proxyHost\u0026rdquo;; see the Proxy Configuration_ for more details. You may also try configuring your proxy manually and then launching the browser with *custom, or with *iehta browser launcher.    custom: When using *custom you must configure the proxy correctly(manually), otherwise you\u0026rsquo;ll get a 404 error. Double-check that you\u0026rsquo;ve configured your proxy settings correctly. To check whether you\u0026rsquo;ve configured the proxy correctly is to attempt to intentionally configure the browser incorrectly. Try configuring the browser to use the wrong proxy server hostname, or the wrong port. If you had successfully configured the browser\u0026rsquo;s proxy settings incorrectly, then the browser will be unable to connect to the Internet, which is one way to make sure that one is adjusting the relevant settings.\n  For other browsers (*firefox, *opera) we automatically hard-code the proxy for you, and so there are no known issues with this functionality. If you\u0026rsquo;re encountering 404 errors and have followed this user guide carefully post your results to user group for some help from the user community.\n  Permission Denied Error The most common reason for this error is that your session is attempting to violate the same-origin policy by crossing domain boundaries (e.g., accesses a page from http://domain1 and then accesses a page from http://domain2) or switching protocols (moving from http://domainX to https://domainX).\nThis error can also occur when JavaScript attempts to find UI objects which are not yet available (before the page has completely loaded), or are no longer available (after the page has started to be unloaded). This is most typically encountered with AJAX pages which are working with sections of a page or subframes that load and/or reload independently of the larger page.\nThis error can be intermittent. Often it is impossible to reproduce the problem with a debugger because the trouble stems from race conditions which are not reproducible when the debugger\u0026rsquo;s overhead is added to the system. Permission issues are covered in some detail in the tutorial. Read the section about the The Same Origin Policy_, Proxy Injection_ carefully.\nHandling Browser Popup Windows There are several kinds of \u0026ldquo;Popups\u0026rdquo; that you can get during a Selenium test. You may not be able to close these popups by running Selenium commands if they are initiated by the browser and not your AUT. You may need to know how to manage these. Each type of popup needs to be addressed differently.\n  HTTP basic authentication dialogs: These dialogs prompt for a username/password to login to the site. To login to a site that requires HTTP basic authentication, use a username and password in the URL, as described in RFC 1738_, like this: open(\u0026ldquo;http://myusername:myuserpassword@myexample.com/blah/blah/blah\u0026quot;).\n  SSL certificate warnings: Selenium RC automatically attempts to spoof SSL certificates when it is enabled as a proxy; see more on this in the section on HTTPS. If your browser is configured correctly, you should never see SSL certificate warnings, but you may need to configure your browser to trust our dangerous \u0026ldquo;CyberVillains\u0026rdquo; SSL certificate authority. Again, refer to the HTTPS section for how to do this.\n  modal JavaScript alert/confirmation/prompt dialogs: Selenium tries to conceal those dialogs from you (by replacing window.alert, window.confirm and window.prompt) so they won\u0026rsquo;t stop the execution of your page. If you\u0026rsquo;re seeing an alert pop-up, it\u0026rsquo;s probably because it fired during the page load process, which is usually too early for us to protect the page. Selenese contains commands for asserting or verifying alert and confirmation popups. See the sections on these topics in Chapter 4.\n  On Linux, why isn\u0026rsquo;t my Firefox browser session closing? On Unix/Linux you must invoke \u0026ldquo;firefox-bin\u0026rdquo; directly, so make sure that executable is on the path. If executing Firefox through a shell script, when it comes time to kill the browser Selenium RC will kill the shell script, leaving the browser running. You can specify the path to firefox-bin directly, like this.\ncmd=getNewBrowserSession\u0026amp;1=*firefox /usr/local/firefox/firefox-bin\u0026amp;2=http://www.google.com Firefox *chrome doesn\u0026rsquo;t work with custom profile Check Firefox profile folder -\u0026gt; prefs.js -\u0026gt; user_pref(\u0026ldquo;browser.startup.page\u0026rdquo;, 0); Comment this line like this: \u0026ldquo;//user_pref(\u0026ldquo;browser.startup.page\u0026rdquo;, 0);\u0026rdquo; and try again.\nIs it ok to load a custom pop-up as the parent page is loading (i.e., before the parent page\u0026rsquo;s javascript window.onload() function runs)? No. Selenium relies on interceptors to determine window names as they are being loaded. These interceptors work best in catching new windows if the windows are loaded AFTER the onload() function. Selenium may not recognize windows loaded before the onload function.\nFirefox on Linux On Unix/Linux, versions of Selenium before 1.0 needed to invoke \u0026ldquo;firefox-bin\u0026rdquo; directly, so if you are using a previous version, make sure that the real executable is on the path.\nOn most Linux distributions, the real firefox-bin is located on:\n/usr/lib/firefox-x.x.x/ Where the x.x.x is the version number you currently have. So, to add that path to the user\u0026rsquo;s path. you will have to add the following to your .bashrc file:\nexport PATH=\u0026#34;$PATH:/usr/lib/firefox-x.x.x/\u0026#34; If necessary, you can specify the path to firefox-bin directly in your test, like this:\n\u0026#34;*firefox /usr/lib/firefox-x.x.x/firefox-bin\u0026#34; IE and Style Attributes If you are running your tests on Internet Explorer and you cannot locate elements using their style attribute. For example:\n//td[@style=\u0026#34;background-color:yellow\u0026#34;] This would work perfectly in Firefox, Opera or Safari but not with IE. IE interprets the keys in @style as uppercase. So, even if the source code is in lowercase, you should use:\n//td[@style=\u0026#34;BACKGROUND-COLOR:yellow\u0026#34;] This is a problem if your test is intended to work on multiple browsers, but you can easily code your test to detect the situation and try the alternative locator that only works in IE.\nError encountered - \u0026ldquo;Cannot convert object to primitive value\u0026rdquo; with shut down of *googlechrome browser To avoid this error you have to start browser with an option that disables same origin policy checks:\nselenium.start(\u0026#34;commandLineFlags=--disable-web-security\u0026#34;); Error encountered in IE - \u0026ldquo;Couldn\u0026rsquo;t open app window; is the pop-up blocker enabled?\u0026rdquo; To avoid this error you have to configure the browser: disable the popup blocker AND uncheck \u0026lsquo;Enable Protected Mode\u0026rsquo; option in Tools \u0026raquo; Options \u0026raquo; Security.\n  The proxy is a third person in the middle that passes the ball between the two parts. It acts as a \u0026ldquo;web server\u0026rdquo; that delivers the AUT to the browser. Being a proxy gives Selenium Server the capability of \u0026ldquo;lying\u0026rdquo; about the AUT\u0026rsquo;s real URL. \u0026#x21a9;\u0026#xfe0e;\n The browser is launched with a configuration profile that has set localhost:4444 as the HTTP proxy, this is why any HTTP request that the browser does will pass through Selenium server and the response will pass through it and not from the real server. \u0026#x21a9;\u0026#xfe0e;\n   "},{"uri":"https://www.selenium.dev/documentation/pt-br/remote_webdriver/remote_webdriver_server/","title":"Servidor do WebDriver remoto","tags":[],"description":"","content":"O servidor sempre será executado na máquina com o navegador que você deseja testar. O servidor pode ser usado a partir da linha de comando ou por meio de configuração de código.\nIniciando o servidor a partir da linha de comando Depois de fazer o download do selenium-server-standalone-{VERSION}.jar, coloque-o no computador com o navegador que deseja testar. Então, a partir do diretório com o jar, execute o seguinte:\njava -jar selenium-server-standalone-{VERSION}.jar Considerações para executar o servidor O chamador deve encerrar cada sessão adequadamente, chamando ou Selenium#stop() ou WebDriver#quit.\nO selenium-server mantém registros na memória para cada sessão em andamento, que são apagados quando Selenium#stop() ou WebDriver#quit é chamado. E se você se esquecer de encerrar essas sessões, seu servidor pode vazar memória. E se você mantém sessões de duração extremamente longa, você provavelmente precisará parar / sair de vez em quando (ou aumentar a memória com a opção -Xmx jvm).\nTimeouts (a partir da versão 2.21) O servidor tem dois timeouts diferentes, que podem ser definidos da seguinte forma:\njava -jar selenium-server-standalone-{VERSION}.jar -timeout=20 -browserTimeout=60  browserTimeout  Controla por quanto tempo o navegador pode travar (valor em segundos).   timeout  Controla por quanto tempo o cliente pode ficar fora antes que a sessão seja recuperada (valor em segundos).    A propriedade do sistema selenium.server.session.timeout não é mais compatível a partir da versão 2.21.\nObserve que o browserTimeout destina-se a ser um mecanismo de timeout de backup quando o mecanismo de timeout comum falha, e deve ser usado principalmente em ambientes de Grid / servidor para garantir que processos travados / perdidos não permaneçam por muito tempo poluindo o ambiente de execução.\nConfigurando o servidor programaticamente Em teoria, o processo é tão simples quanto mapear o DriverServlet para uma URL, mas também é possível hospedar a página em um formato leve de container, como Jetty, configurado inteiramente em código.\n Baixe o selenium-server.zip e descompacte. Coloque os JARs no CLASSPATH. Crie uma nova classe chamada AppServer. Aqui, estamos usando Jetty, então você precisará baixar isso também:  import org.mortbay.jetty.Connector; import org.mortbay.jetty.Server; import org.mortbay.jetty.nio.SelectChannelConnector; import org.mortbay.jetty.security.SslSocketConnector; import org.mortbay.jetty.webapp.WebAppContext; import javax.servlet.Servlet; import java.io.File; import org.openqa.selenium.remote.server.DriverServlet; public class AppServer { private Server server = new Server(); public AppServer() throws Exception { WebAppContext context = new WebAppContext(); context.setContextPath(\u0026#34;\u0026#34;); context.setWar(new File(\u0026#34;.\u0026#34;)); server.addHandler(context); context.addServlet(DriverServlet.class, \u0026#34;/wd/*\u0026#34;); SelectChannelConnector connector = new SelectChannelConnector(); connector.setPort(3001); server.addConnector(connector); server.start(); } } "},{"uri":"https://www.selenium.dev/documentation/pt-br/getting_started/quick/","title":"Tour rápido","tags":[],"description":"","content":"Selenium não é só uma ferramenta ou API, mas sim uma composição de várias ferramentas.\nWebDriver Se você está começando com automação de testes de um site de desktop ou site para celular, então vai usar as APIs WebDriver. O WebDriver usa APIs de automação de navegador disponibilizadas por fornecedores de navegador para o controlar e executar testes. É como se um usuário real o estivesse operando. Como o WebDriver não exige que sua API seja compilada com o código do aplicativo, não é intrusivo. Portanto, você está testando o mesmo aplicativo que você envia aos ambientes de produção.\nIDE IDE (Ambiente de Desenvolvimento Integrado, em português) é a ferramenta que você usa para desenvolver seus casos de teste Selenium. É uma extensão para Chrome e Firefox fácil de usar e geralmente é a maneira mais eficiente de desenvolver casos de teste. Ela registra as ações dos usuários no navegador para você, usando comandos Selenium existentes, com parâmetros definidos pelo contexto daquele elemento. Isso não é apenas uma economia de tempo, mas também uma maneira excelente de aprender a sintaxe de script do Selenium.\nGrid Selenium Grid permite que você execute casos de teste em diferentes máquinas em diferentes plataformas. O controle para acionar os casos de teste está na extremidade local, e quando os casos de teste são acionados, eles são automaticamente executados pela extremidade remota.\nApós o desenvolvimento dos testes WebDriver, você pode enfrentar a necessidade de executar seus testes em vários navegadores e combinações de sistemas operacionais. É aqui que o Grid entra em cena.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/remote_webdriver/remote_webdriver_client/","title":"Cliente do WebDriver remoto","tags":[],"description":"","content":"Para executar um cliente WebDriver remoto, primeiro precisamos nos conectar ao RemoteWebDriver. Fazemos isso apontando a URL para o endereço do servidor que está executando nossos testes. Para personalizar nossa configuração, definimos os recursos desejados. Abaixo está um exemplo de como instanciar um objeto WebDriver remoto apontando para nosso servidor remoto da web, www.example.com, executando nossos testes no Firefox.\nJava Python C# Ruby JavaScript Kotlin FirefoxOptions firefoxOptions = new FirefoxOptions(); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();   from selenium import webdriver firefox_options = webdriver.FirefoxOptions() driver = webdriver.Remote( command_executor=\u0026#39;http://www.example.com\u0026#39;, options=firefox_options ) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   FirefoxOptions firefoxOptions = new FirefoxOptions(); IWebDriver driver = new RemoteWebDriver(new Uri(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions); driver.Navigate().GoToUrl(\u0026#34;http://www.google.com\u0026#34;); driver.Quit();   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :remote, url: \u0026#34;http://www.example.com\u0026#34;, desired_capabilities: :firefox driver.get \u0026#34;http://www.google.com\u0026#34; driver.close   const { Builder, Capabilities } = require(\u0026#34;selenium-webdriver\u0026#34;); var capabilities = Capabilities.firefox(); (async function helloSelenium() { let driver = new Builder() .usingServer(\u0026#34;http://example.com\u0026#34;) .withCapabilities(capabilities) .build(); try { await driver.get(\u0026#39;http://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   firefoxOptions = FirefoxOptions() driver: WebDriver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()     Para personalizar ainda mais nossa configuração de teste, podemos adicionar outros recursos desejados.\nOpções do browser Por exemplo, suponha que você queira executar o Chrome no Windows XP, usando o Chrome versão 67:\nJava Python C# Ruby JavaScript Kotlin ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setCapability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); chromeOptions.setCapability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), chromeOptions); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();   from selenium import webdriver chrome_options = webdriver.ChromeOptions() chrome_options.set_capability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;) chrome_options.set_capability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;) driver = webdriver.Remote( command_executor=\u0026#39;http://www.example.com\u0026#39;, options=chrome_options ) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var chromeOptions = new ChromeOptions(); chromeOptions.BrowserVersion = \u0026#34;67\u0026#34;; chromeOptions.PlatformName = \u0026#34;Windows XP\u0026#34;; IWebDriver driver = new RemoteWebDriver(new Uri(\u0026#34;http://www.example.com\u0026#34;), chromeOptions); driver.Navigate().GoToUrl(\u0026#34;http://www.google.com\u0026#34;); driver.Quit();   caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.platform = Windows XP caps.version = 67 driver = Selenium::WebDriver.for :remote, :url =\u0026gt; \u0026#34;http://www.example.com\u0026#34;, :desired_capabilities =\u0026gt; caps   const { Builder } = require(\u0026#34;selenium-webdriver\u0026#34;); const chrome = require(\u0026#34;selenium-webdriver/chrome\u0026#34;); let opts = new chrome.Options(); opts.setAcceptInsecureCerts(true); opts.setBrowserVersion(\u0026#39;67\u0026#39;); opts.setPlatform(\u0026#39;Windows XP\u0026#39;); (async function helloSelenium() { let driver = new Builder() .usingServer(\u0026#34;http://example.com\u0026#34;) .forBrowser(\u0026#39;chrome\u0026#39;) .setChromeOptions(opts) .build(); try { await driver.get(\u0026#39;http://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   val chromeOptions = ChromeOptions() chromeOptions.setCapability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;) chromeOptions.setCapability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;) val driver: WebDriver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), chromeOptions) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()     Detector de arquivo local O Detector de Arquivo Local permite a transferência de arquivos da máquina do cliente para o servidor remoto. Por exemplo, se um teste precisa carregar um arquivo para um aplicativo da web, um WebDriver remoto pode transferir automaticamente o arquivo da máquina local para o servidor web remoto durante o tempo de execução. Isso permite que o arquivo seja carregado da máquina remota executando o teste. Não é habilitado por padrão e pode ser habilitado em da seguinte forma:\nJava Python C# Ruby JavaScript Kotlin driver.setFileDetector(new LocalFileDetector());   from selenium.webdriver.remote.file_detector import LocalFileDetector driver.file_detector = LocalFileDetector()   var allowsDetection = this.driver as IAllowsFileDetection; if (allowsDetection != null) { allowsDetection.FileDetector = new LocalFileDetector(); }   @driver.file_detector = lambda do |args| # args =\u0026gt; [\u0026#34;/path/to/file\u0026#34;] str = args.first.to_s str if File.exist?(str) end   var remote = require(\u0026#39;selenium-webdriver/remote\u0026#39;); driver.setFileDetector(new remote.FileDetector);   driver.fileDetector = LocalFileDetector()     Assim que o código acima for definido, você pode fazer upload de um arquivo em seu teste da seguinte maneira:\nJava Python C# Ruby JavaScript Kotlin driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); WebElement upload = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)); upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;) driver.find_element(By.ID, \u0026#34;myfile\u0026#34;).send_keys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;)   driver.Navigate().GoToUrl(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); IWebElement upload = driver.FindElement(By.Id(\u0026#34;myfile\u0026#34;)); upload.SendKeys(@\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   @driver.navigate.to \u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34; element = @driver.find_element(:id, \u0026#39;myfile\u0026#39;) element.send_keys \u0026#34;/Users/sso/SauceLabs/sauce/hostess/maitred/maitred/public/images/darkbulb.jpg\u0026#34;   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); var upload = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)); upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;) val upload: WebElement = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)) upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;)     "},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/grid_3/setting_up_your_own_grid/","title":"Configurando a sua","tags":[],"description":"","content":"Para usar Selenium Grid, você precisa manter sua própria infraestrutura para os nós. Como isso pode ser um esforço pesado e intenso, muitas organizações usam provedores IaaS como Amazon EC2 e Google Compute para fornecer essa infraestrutura.\nOutras opções incluem o uso de provedores como Sauce Labs ou Testing Bot que fornecem uma Selenium Grid como um serviço na nuvem. Certamente também é possível executar nós em seu próprio hardware. Este capítulo entrará em detalhes sobre a opção de executar sua própria Grid, completo com sua própria infraestrutura de nós.\nInício Este exemplo mostrará como iniciar o Selenium 2 Grid Hub, e registrar um nó WebDriver e um nó legado Selenium 1 RC. Também mostraremos como chamar a Grid a partir do Java. O hub e os nós são mostrados aqui em execução na mesma máquina, mas é claro que você pode copiar o selenium-server-standalone para várias máquinas.\nO pacote selenium-server-standalone inclui o hub, WebDriver e RC legado necessários para executar o Grid, ant não é mais necessário. Você pode baixar o selenium-server-standalone.jar de https://selenium.dev/downloads/.\nPasso 1: Inicialize o Hub O Hub é o ponto central que receberá solicitações de teste e os distribuirá para os nós certos. A distribuição é feita com base em recursos, significando que um teste que requer um conjunto de recursos só será distribuído para nós que oferecem esse conjunto ou subconjunto de recursos.\nPorque os recursos desejados de um teste são apenas o que o nome indica, desired, o hub não pode garantir que localizará um nó corresponder totalmente ao conjunto de recursos desejados solicitados.\nAbra um prompt de comando e navegue até o diretório onde você copiou o arquivo selenium-server-standalone.jar. Você inicia o hub passando a sinalização -role hub para o servidor autônomo:\njava -jar selenium-server-standalone.jar -role hub The Hub will listen to port 4444 by default. You can view the status of the hub by opening a browser window and navigating to http://localhost:4444/grid/console.\nPara alterar a porta padrão, você pode adicionar a flag opcional -port com um número inteiro representando a porta a ser ouvida quando você executa o comando. Além disso, todas as outras opções que você vê no arquivo de configuração JSON (veja abaixo) são possíveis flags de linha de comando.\nVocê certamente pode sobreviver apenas com o comando simples mostrado acima, mas se você precisar de uma configuração mais avançada, você também pode especificar um arquivo de configuração de formato JSON, por conveniência, para configurar o hub ao iniciá-lo. Você pode fazer assim:\njava -jar selenium-server-standalone.jar -role hub -hubConfig hubConfig.json -debug Abaixo você verá um exemplo de um arquivo hubConfig.json. Entraremos em mais detalhes sobre como fornecer arquivos de configuração de nó no Passo 2.\n{ \u0026#34;_comment\u0026#34; : \u0026#34;Configuration for Hub - hubConfig.json\u0026#34;, \u0026#34;host\u0026#34;: ip, \u0026#34;maxSession\u0026#34;: 5, \u0026#34;port\u0026#34;: 4444, \u0026#34;cleanupCycle\u0026#34;: 5000, \u0026#34;timeout\u0026#34;: 300000, \u0026#34;newSessionWaitTimeout\u0026#34;: -1, \u0026#34;servlets\u0026#34;: [], \u0026#34;prioritizer\u0026#34;: null, \u0026#34;capabilityMatcher\u0026#34;: \u0026#34;org.openqa.grid.internal.utils.DefaultCapabilityMatcher\u0026#34;, \u0026#34;throwOnCapabilityNotPresent\u0026#34;: true, \u0026#34;nodePolling\u0026#34;: 180000, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;} Pasos 2: Inicialize os Nós Independentemente de você querer executar uma Grid com a nova funcionalidade WebDriver, ou uma Grid com funcionalidade Selenium 1 RC, ou os dois ao mesmo tempo, você usa o mesmo arquivo selenium-server-standalone.jar para iniciar os nós:\njava -jar selenium-server-standalone.jar -role node -hub http://localhost:4444 Se uma porta não for especificada por meio do sinalizador -port, uma porta livre será escolhida. Você pode executar vários nós em uma máquina mas se você fizer isso, você precisa estar ciente dos recursos de memória de seus sistemas e problemas com capturas de tela se seus testes as fizerem.\nConfiguração de um nó com opções Como mencionado, para compatibilidade com versões anteriores as funções “wd” e “rc” ainda são um subconjunto válido da função “node”. Mas essas funções limitam os tipos de conexões remotas para sua API correspondente, enquanto “node” permite conexões remotas RC e WebDriver.\nAo passar propriedades JVM (usando o sinalizador -D antes do argumento -jar) na linha de comando também, estas serão coletadas e propagadas para os nós:\n-Dwebdriver.chrome.driver=chromedriver.exe\nConfiguração de um nó com JSON Você também pode iniciar nós da Grid que estão configurados com um arquivo de configuração JSON\njava -Dwebdriver.chrome.driver=chromedriver.exe -jar selenium-server-standalone.jar -role node -nodeConfig node1Config.json E aqui está um exemplo do arquivo nodeConfig.json:\n{ \u0026#34;capabilities\u0026#34;: [ { \u0026#34;browserName\u0026#34;: \u0026#34;firefox\u0026#34;, \u0026#34;acceptSslCerts\u0026#34;: true, \u0026#34;javascriptEnabled\u0026#34;: true, \u0026#34;takesScreenshot\u0026#34;: false, \u0026#34;firefox_profile\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;browser-version\u0026#34;: \u0026#34;27\u0026#34;, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;maxInstances\u0026#34;: 5, \u0026#34;firefox_binary\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;cleanSession\u0026#34;: true }, { \u0026#34;browserName\u0026#34;: \u0026#34;chrome\u0026#34;, \u0026#34;maxInstances\u0026#34;: 5, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;webdriver.chrome.driver\u0026#34;: \u0026#34;C:/Program Files (x86)/Google/Chrome/Application/chrome.exe\u0026#34; }, { \u0026#34;browserName\u0026#34;: \u0026#34;internet explorer\u0026#34;, \u0026#34;maxInstances\u0026#34;: 1, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;webdriver.ie.driver\u0026#34;: \u0026#34;C:/Program Files (x86)/Internet Explorer/iexplore.exe\u0026#34; } ], \u0026#34;configuration\u0026#34;: { \u0026#34;_comment\u0026#34; : \u0026#34;Configuration for Node\u0026#34;, \u0026#34;cleanUpCycle\u0026#34;: 2000, \u0026#34;timeout\u0026#34;: 30000, \u0026#34;proxy\u0026#34;: \u0026#34;org.openqa.grid.selenium.proxy.WebDriverRemoteProxy\u0026#34;, \u0026#34;port\u0026#34;: 5555, \u0026#34;host\u0026#34;: ip, \u0026#34;register\u0026#34;: true, \u0026#34;hubPort\u0026#34;: 4444, \u0026#34;maxSession\u0026#34;: 5 } } Uma observação sobre a flag -host\nPara hub e nó, se a flag -host não for especificada, 0.0.0.0 será usado por padrão. Isso se ligará a todos as interfaces IPv4 públicas (sem loopback) da máquina. Se você tem uma configuração especial de rede ou qualquer componente que crie interfaces de rede extras, é aconselhável definir a flag -host com um valor que permite o hub / nó acessível a partir de uma máquina diferente.\nEspecificando a porta A porta TCP / IP padrão usada pelo hub é 4444. Se você precisar alterar a porta use as configurações mencionadas acima.\nSolução de problemas Usando um arquivo de log Para solução de problemas avançada, você pode especificar um arquivo de log para registrar mensagens do sistema. Inicie o hub ou nó Selenium Grid com o argumento -log. Por favor, veja o exemplo abaixo:\njava -jar selenium-server-standalone.jar -role hub -log log.txt Use o seu editor de texto favorito para abrir o arquivo de log (log.txt no exemplo acima) para encontrar registros de \u0026ldquo;ERROR\u0026rdquo; se você tiver problemas.\nUsando o argumento -debug Você também pode usar o argumento -debug para imprimir logs de depuração no console. Inicie o Selenium Grid Hub ou Node com o argumento -debug. Por favor, veja o exemplo abaixo:\njava -jar selenium-server-standalone.jar -role hub -debug Aviso A Selenium Grid deve ser protegida do acesso externo usando permissões de firewall.\nA falha em proteger sua rede pode resultar em um ou mais dos seguintes eventos:\n Você fornece acesso aberto à sua infraestrutura de rede Você permite que terceiros acessem aplicativos e arquivos internos da web Você permite que terceiros executem binários personalizados  Veja esta postagem do blog em Detectify, que dá uma boa visão geral de como uma rede exposta publicamente pode ser mal utilizada: Não deixe sua grade totalmente aberta.\nDocker Selenium Docker fornece uma maneira conveniente de provisionar e escalar a infraestrutura da Selenium Grid em uma unidade conhecida como contêiner. Os contêineres são unidades padronizadas de software que contêm tudo o que é necessário para executar o aplicativo desejado, incluindo todas as dependências, de forma confiável e repetível em máquinas diferentes.\nO projeto Selenium mantém um conjunto de imagens Docker que você pode baixar e executar para colocar uma Grid em funcionamento rapidamente. Os nós estão disponíveis para Firefox e Chrome. Detalhes completos de como provisionar uma grade podem ser encontrados no repositório Docker Selenium.\nPré-requisitos O único requisito para executar um Grid é ter o Docker instalado e funcionando. [Instale o Docker] (// www.docker.com/products/docker-desktop).\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/grid_4/setting_up_your_own_grid/","title":"Configurando a sua","tags":[],"description":"","content":"Diferentes modos de configuração de Grid no Selenium 4:  Standalone Hub and Node Distributed Docker  Modo Standalone: O novo Selenium Server Jar contém tudo que você precisa para executar uma Grid. É também o modo mais fácil de ligar uma Selenium Grid. Por padrão, o servidor estará escutando em http://localhost:4444, e essa é a URL para a qual você deve apontar seus testes RemoteWebDriver. O servidor detectará os drivers disponíveis que podem ser usados no PATH do sistema\njava -jar selenium-server-4.0.0-alpha-6.jar standalone Modo Hub e Nó: Inicialize o Hub: java -jar selenium-server-4.0.0-alpha-6.jar hub Registre o Nó: java -jar selenium-server-4.0.0-alpha-6.jar node --detect-drivers Faça a busca na Selenium Grid: No Selenium 4, também adicionamos GraphQL, uma nova maneira de consultar os dados necessários facilmente e obter exatamente a mesma coisa.\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{ \u0026#34;query\u0026#34;: \u0026#34;{grid{uri}}\u0026#34; }\u0026#39; -s http://localhost:4444/graphql | jq . Modo Distribuído:   Passo 1: Em primeiro lugar, inicie o Event Bus, ele serve como um caminho de comunicação para outros componentes da rede nas etapas subsequentes.\njava -jar selenium-server-4.0.0-alpha-6.jar event-bus   Passo 2: Inicie o mapa da sessão, que é responsável por mapear os IDs da sessão para o nó em que a sessão está sendo executada:\njava -jar selenium-server-4.0.0-alpha-6.jar sessions   Passo 3: Inicie o novo enfileirador de sessão, ele adiciona a nova solicitação de sessão a uma fila local. O distribuidor atende o pedido da fila.\njava -jar selenium-server-4.0.0-alpha-6.jar sessionqueuer   Passo 4: Inicie o Distribuidor. Todos os Nós são anexados como parte do processo do Distribuidor. É responsável por atribuir um nó, quando um pedido de criação de sessão é invocado.\njava -jar selenium-server-4.0.0-alpha-6.jar distributor --sessions http://localhost:5556 --sessionqueuer http://localhost:5559 --bind-bus false   Passo 5: A próxima etapa é iniciar o Roteador, um endereço que você exporia à web\njava -jar selenium-server-4.0.0-alpha-6.jar router --sessions http://localhost:5556 --distributor http://localhost:5553 --sessionqueuer http://localhost:5559   Step 6: Finalmente, adicione um Nó\njava -jar selenium-server-4.0.0-alpha-6.jar node --detect-drivers   Inicie a Standalone Grid via imagens Docker Você pode simplesmente iniciar um Nó com o seguinte comando:\njava -jar selenium-server-4.0.0-alpha-1.jar node -D selenium/standalone-firefox:latest \u0026#39;{\u0026#34;browserName\u0026#34;: \u0026#34;firefox\u0026#34;}\u0026#39; Você pode iniciar o servidor Selenium e delegá-lo ao docker para a criação de novas instâncias:\njava -jar selenium-server-4.0.0-alpha-6.jar standalone -D selenium/standalone-firefox:latest \u0026#39;{\u0026#34;browserName\u0026#34;: \u0026#34;firefox\u0026#34;}\u0026#39; --detect-drivers false "},{"uri":"https://www.selenium.dev/documentation/pt-br/front_matter/typographical_conventions/","title":"Convenções tipográficas","tags":[],"description":"","content":"Capitalização de títulos Deve-se evitar a capitalização do título, como Um Título Muito Estiloso, e em vez disso, use Um título muito estiloso. Letras maiúsculas gratuitas, ou caixa do título, muitas vezes mostram um mal-entendido - ou um desprezo por - convenções ortográficas. Preferimos o que é conhecido como sentence case, com uma única inicial maiúscula para iniciar cabeçalhos.\nComprimento da linha Ao editar o código fonte da documentação, que é escrito em HTML puro, limite o comprimento das linhas a cerca de 72 caracteres.\nAlguns de nós dão um passo adiante e usam o que é chamado de linefeeds semânticos, que é uma técnica pela qual as linhas de origem HTML, que não são lidos pelo público, são divididas em \u0026ldquo;intervalos naturais\u0026rdquo; na prosa. Em outras palavras, as frases são divididas em quebras naturais entre as orações. Em vez de se preocupar com as linhas de cada parágrafo de modo que todos terminem perto da margem direita, os feeds de linha podem ser adicionados em qualquer lugar que existe uma ruptura entre as ideias.\nIsso pode tornar as diffs muito fáceis de ler ao colaborar por meio do git, mas não é algo que obrigamos os colaboradores a usar.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/worst_practices/file_downloads/","title":"Downloads de arquivo","tags":[],"description":"","content":"Embora seja possível iniciar um download clicando em um link com um navegador sob o controle do Selenium, a API não expõe o progresso do download, tornando-o menos do que ideal para testar arquivos baixados. Isso ocorre porque o download de arquivos não é considerado um aspecto importante de emular a interação do usuário com a plataforma da web. Em vez disso, encontre o link usando Selenium (e todos os cookies necessários) e passe este cookie para uma biblioteca de solicitação HTTP como libcurl.\nO driver HtmlUnit pode baixar anexos acessando-os como fluxos de entrada, implementando o AttachmentHandler. O AttachmentHandler pode ser adicionado ao WebClient HtmlUnit.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/getting_started_with_webdriver/third_party_drivers_and_plugins/","title":"Drivers e plugins de terceiros","tags":[],"description":"","content":"Selenium pode ser estendido com o uso de plug-ins. Aqui estão alguns plugins criados e mantidos por terceiros. Para obter mais informações sobre como para criar seu próprio plugin ou listá-lo, consulte a documentação.\nObserve que esses plug-ins não são suportados, mantidos, hospedados ou endossados pelo projeto Selenium. Além disso, esteja ciente de que os plug-ins listados abaixo não são necessariamente licenciados sob a Licença Apache v.2.0. Alguns dos plug-ins estão disponíveis em outro software de código aberto e gratuito licença; outros estão disponíveis apenas sob licença proprietária. Alguma pergunta sobre plug-ins e suas licenças de distribuição precisam ser levantadas com seus respectivo(s) desenvolvedor(es).\n   Nevgador Atual Changelog Issues     Mozilla GeckoDriver latest change log issue tracker   Google Chrome Driver latest change log issue tracker   Opera latest - issue tracker   Microsoft Edge Driver latest - issue tracker   SafariDriver Embutido - issue tracker    "},{"uri":"https://www.selenium.dev/documentation/pt-br/selenium_installation/installing_webdriver_binaries/","title":"Instalando binários do WebDriver","tags":[],"description":"","content":"Para executar seu projeto e controlar o navegador, você precisa ter binários WebDriver específicos do navegador instalados.\nBaixe o binário WebDriver suportado pelo seu navegador e coloque-o no System PATH.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/introduction/","title":"Introdução","tags":[],"description":"","content":"Introdução Selenium é um projeto abrangente para uma gama de ferramentas e bibliotecas que permitem e suportam a automação de navegadores da web.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/domain_specific_language/","title":"Linguagem específica de domínio (DSL)","tags":[],"description":"","content":"Uma linguagem específica de domínio (DSL) é um sistema que fornece ao usuário um meio expressivo de resolver um problema. Ele permite a um usuário interagir com o sistema em seus termos - não apenas na linguagem do programador.\nSeus usuários, em geral, não se importam com a aparência do seu site. Eles não preocupam-se com a decoração, animações ou gráficos. Eles deseja usar seu sistema para empurrar seus novos funcionários através do processo com dificuldade mínima; eles querem reservar uma viagem para o Alasca; eles querem configurar e comprar unicórnios com desconto. Seu trabalho como testador deve chegar o mais perto possível de “capturar” essa mentalidade. Com isso em mente, começamos a \u0026ldquo;modelar\u0026rdquo; o aplicativo que você está trabalhando, de modo que os scripts de teste (o único proxy de pré-lançamento do usuário) “fala a linguagem” e representa o usuário.\nCom Selenium, DSL é geralmente representado por métodos, escritos para fazer a API simples e legível - eles permitem um relatório entre o desenvolvedores e as partes interessadas (usuários, proprietários de produtos, negócios especialistas em inteligência, etc.).\nBenefícios  Legível: As partes interessadas da empresa podem entendê-lo. Gravável: Fácil de escrever, evita duplicações desnecessárias. Extensível: Funcionalidade pode (razoavelmente) ser adicionada sem quebrar contratos e funcionalidades existentes. Manutenção: Deixando os detalhes de implementação fora do teste casos, você está bem isolado contra alterações no AUT *.  Java Aqui está um exemplo de um método DSL razoável em Java. Por questão de brevidade, ele assume que o objeto driver é pré-definido e está disponível para o método.\n/** * Recebe um username e password, prrenche os campos, e clica em \u0026#34;login\u0026#34;. * @return Uma instância de AccountPage */ public AccountPage loginAsUser(String username, String password) { WebElement loginField = driver.findElement(By.id(\u0026#34;loginField\u0026#34;)); loginField.clear(); loginField.sendKeys(username); // Preenche o campo password. O localizador que estamos usando é \u0026#34;By.id\u0026#34;, e devemos  // definí-lo em algum outro lugar dentro da Classe.  WebElement passwordField = driver.findElement(By.id(\u0026#34;password\u0026#34;)); passwordField.clear(); passwordField.sendKeys(password); // Clica o botão de login, que possui o id \u0026#34;submit\u0026#34;.  driver.findElement(By.id(\u0026#34;submit\u0026#34;)).click(); // Cria e retorna uma nova instância de AccountPage (via o Selenium  // PageFactory embutido).  return PageFactory.newInstance(AccountPage.class); } Este método abstrai completamente os conceitos de campos de entrada, botões, cliques e até páginas do seu código de teste. Usando este abordagem, tudo o que o testador precisa fazer é chamar esse método. Isto dá uma vantagem de manutenção: se os campos de login mudaram, você teria apenas que alterar esse método - não seus testes.\npublic void loginTest() { loginAsUser(\u0026#34;cbrown\u0026#34;, \u0026#34;cl0wn3\u0026#34;); // Agora que estamos logados, fazemos alguma outra coisa--como usamos uma DSL para suportar  // nossos testadores, é apenas escolher um dos métodos disponíveis.  do.something(); do.somethingElse(); Assert.assertTrue(\u0026#34;Algo deveria ter sido feito!\u0026#34;, something.wasDone()); // Note que ainda não nos referimos a nenhum botão ou web control nesse  // script... } Vale a pena repetir: um de seus principais objetivos deve ser escrever um API que permite que seus testes resolvam o problema em questão, e NÃO o problema da IU. A IU é uma preocupação secundária para o seu usuários - eles não se importam com a interface do usuário, eles apenas querem fazer seu trabalho feito. Seus scripts de teste devem ser lidos como uma lista de itens sujos que o usuário deseja FAZER e as coisas que deseja SABER. Os testes não devem se preocupar com COMO a interface do usuário exige que você vá sobre isso.\n*AUT: Application under test\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/legacy_docs/migrating_from_rc_to_webdriver/","title":"Migrando do RC para WebDriver","tags":[],"description":"","content":"Como migrar para o Selenium WebDriver Uma pergunta comum ao adotar o Selenium 2 é qual é a coisa certa a fazer ao adicionar novos testes a um conjunto existente de testes? Usuários que são novos no framework podem começar usando as novas APIs WebDriver para escrever seus testes. Mas e os usuários que já possuem suítes de testes existentes? Este guia é projetado para demonstrar como migrar seus testes existentes para as novas APIs, permitindo que todos os novos testes sejam escritos usando os novos recursos oferecidos pelo WebDriver.\nO método apresentado aqui descreve uma migração gradativa para as APIs WebDriver sem precisar refazer tudo em um push massivo. Isso significa que você pode permitir mais tempo para migrar seus testes existentes, que pode tornar mais fácil para você decidir onde investir seu esforço.\nEste guia foi escrito em Java, porque tem o melhor suporte para fazer a migração. À medida que fornecemos ferramentas melhores para outras linguagens, este guia deve ser expandido para incluir essas linguagens.\nPorque migrar para o WebDriver Mover um conjunto de testes de uma API para outra requer uma enorme quantidade de esforço. Por que você e sua equipe considerariam fazer essa mudança? Aqui estão alguns motivos pelos quais você deve considerar a migração de seus testes Selenium para usar o WebDriver.\n API menor e compacta. A API do WebDriver é mais orientada a objetos do que o Selenium RC API original. Isso pode facilitar o trabalho. Melhor emulação das interações do usuário. Sempre que possível, o WebDriver faz uso de eventos nativos para interagir com uma página da web. Imita melhor a maneira como seus usuários trabalham com seu site e aplicativos. Além do que, o WebDriver oferece APIs de interações de usuário avançadas que permitem que você modele interações complexas com seu site. Suporte de fornecedores de navegadores. Opera, Mozilla e Google são todos participantes ativos do desenvolvimento do WebDriver, e cada um tem engenheiros trabalhando para melhorar a estrutura. Frequentemente, isso significa que o suporte para WebDriver está embutido no próprio navegador: seus testes são executados tão rápidos e estáveis quanto possível.  Antes de começar A fim de tornar o processo de migração o mais indolor possível, certifique-se de que todos os seus testes sejam executados corretamente com a versão mais recente do Selenium. Isso pode parecer óbvio, mas é melhor que seja dito!\nComeçando A primeira etapa ao iniciar a migração é mudar a forma como você obtém sua instância Selenium. Ao usar Selenium RC, isso é feito assim:\nSelenium selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.yoursite.com\u0026#34;); selenium.start(); Isso deve ser substituído assim:\nWebDriver driver = new FirefoxDriver(); Selenium selenium = new WebDriverBackedSelenium(driver, \u0026#34;http://www.yoursite.com\u0026#34;); Próximos passos Depois que seus testes forem executados sem erros, a próxima etapa é migrar o código de teste real para usar as APIs WebDriver. Dependendo de quão bem você abstrair o seu código, pode ser um processo curto ou longo. Em ambos os casos, a abordagem é a mesma e pode ser resumida simplesmente: modifique o código para usar a nova API quando for editá-lo.\nSe você precisar extrair a implementação WebDriver subjacente da instância Selenium, você pode simplesmente fazer um cast para WrapsDriver:\nWebDriver driver = ((WrapsDriver) selenium).getWrappedDriver(); Isso permite que você continue passando a instância Selenium como normal, mas desembrulhar a instância do WebDriver conforme necessário.\nEm algum ponto, sua base de código usará principalmente as APIs mais recentes. Neste ponto, você pode inverter o relacionamento, usando WebDriver em tudo e instanciar uma instância do Selenium sob demanda:\nSelenium selenium = new WebDriverBackedSelenium(driver, baseUrl); Problemas comuns Felizmente, você não é a primeira pessoa a passar por essa migração, então, aqui estão alguns problemas comuns que outras pessoas viram e como resolvê-los.\nClicar e digitar são mais completos Um padrão comum em um teste de Selenium RC é ver algo como:\nselenium.type(\u0026#34;name\u0026#34;, \u0026#34;exciting tex\u0026#34;); selenium.keyDown(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); selenium.keyPress(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); selenium.keyUp(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); Isso se baseia no fato de que o \u0026ldquo;tipo\u0026rdquo; simplesmente substitui o conteúdo do elemento identificado sem também disparar todos os eventos que normalmente seriam disparados se um usuário interagir com a página. As invocações diretas finais de \u0026ldquo;key*\u0026rdquo; faz com que os manipuladores JS sejam acionados conforme o esperado.\nAo usar o WebDriverBackedSelenium, o resultado do preenchimento do campo do formulário seria \u0026ldquo;exciting texttt\u0026rdquo;: não o que você esperaria! O motivo disso é que o WebDriver emula com mais precisão o comportamento do usuário, e assim terá disparado eventos o tempo todo.\nEsse mesmo fato às vezes pode fazer com que o carregamento da página seja disparado antes do que aconteceria em um teste de Selenium 1. Você pode dizer que isso aconteceu se uma \u0026ldquo;StaleElementException\u0026rdquo; é lançada pelo WebDriver.\nWaitForPageToLoad retorna muito cedo Descobrir quando o carregamento de uma página está completo é uma tarefa complicada. Queremos dizer \u0026ldquo;quando o evento de carregamento dispara\u0026rdquo;, \u0026ldquo;quando todas as solicitações AJAX são concluídas\u0026rdquo;, \u0026ldquo;quando não há tráfego de rede \u0026ldquo;,\u0026rdquo; quando document.readyState mudou\u0026rdquo; ou outra coisa completamente diferente?\nWebDriver tenta simular o comportamento original do Selenium, mas isso não sempre funciona perfeitamente por vários motivos. O motivo mais comum é que é difícil dizer a diferença entre um carregamento de página que ainda não começou e um carregamento da página concluído entre as chamadas de método. Isso às vezes significa que o controle é devolvido ao seu teste antes que a página termine (ou mesmo comece!) o carregamento.\nA solução para isso é esperar por algo específico. Normalmente, isso pode ser o elemento com o qual deseja interagir a seguir, ou para alguma variável Javascript a ser definida com um valor específico. Um exemplo seria:\nWait\u0026lt;WebDriver\u0026gt; wait = new WebDriverWait(driver, Duration.ofSeconds(30)); WebElement element= wait.until(visibilityOfElementLocated(By.id(\u0026#34;some_id\u0026#34;))); Onde \u0026ldquo;visibilityOfElementLocated\u0026rdquo; é implementado como:\npublic ExpectedCondition\u0026lt;WebElement\u0026gt; visibilityOfElementLocated(final By locator) { return new ExpectedCondition\u0026lt;WebElement\u0026gt;() { public WebElement apply(WebDriver driver) { WebElement toReturn = driver.findElement(locator); if (toReturn.isDisplayed()) { return toReturn; } return null; } }; } Isso pode parecer complexo, mas é quase todo um código padrão. O único interessante é que a \u0026ldquo;condição esperada\u0026rdquo; será avaliada repetidamente até que o método \u0026ldquo;apply\u0026rdquo; retorne algo que não seja \u0026ldquo;null\u0026rdquo; nem Boolean.FALSE.\nClaro, adicionar todas essas chamadas de \u0026ldquo;wait\u0026rdquo; pode confundir seu código. E se esse é o caso, e suas necessidades são simples, considere usar as esperas implícitas:\ndriver.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS); Ao fazer isso, toda vez que um elemento é localizado, se o elemento não estiver presente, o local é tentado novamente até que esteja presente ou até 30 segundos passados.\nEncontrar por seletores XPath ou CSS nem sempre funciona, mas funciona no Selenium 1 No Selenium 1, era comum para o xpath usar uma biblioteca agrupada em vez de os recursos do próprio navegador. WebDriver sempre usará os métodos nativos do navegador, a menos que não haja alternativa. Isso significa que expressões xpath complexas podem falhar em alguns navegadores.\nOs seletores CSS no Selenium 1 foram implementados usando a biblioteca Sizzle. Esta biblioteca implementa um superconjunto da CSS Selector Spec, e nem sempre é claro onde você cruzou a linha. Se você estiver usando o WebDriverBackedSelenium e usar um Localizador Sizzle em vez de um Seletor CSS para encontrar elementos, um aviso ser registrado no console. Vale a pena procurar por eles, particularmente se os testes estão falhando por não ser capaz de encontrar os elementos.\nNão há nenhum Browserbot O Selenium RC era baseado no Selenium Core e, portanto, quando você executava Javascript, você podia acessar bits do Selenium Core para tornar as coisas mais fáceis. Como o WebDriver não é baseado no Selenium Core, isso não é mais possível. Como você pode saber se está usando Selenium Core? Simples! Basta olhar para ver se o seu \u0026ldquo;getEval\u0026rdquo; ou chamadas semelhantes usam \u0026ldquo;selenium\u0026rdquo; ou \u0026ldquo;browserbot\u0026rdquo; no Javascript avaliado.\nVocê pode estar usando o browserbot para obter um identificador para a janela atual ou documento do teste. Felizmente, o WebDriver sempre avalia JS no contexto da janela atual, então você pode usar \u0026ldquo;window\u0026rdquo; ou \u0026ldquo;document\u0026rdquo; diretamente.\nComo alternativa, você pode usar o browserbot para localizar elementos. No WebDriver, o idioma para fazer isso é primeiro localizar o elemento, e então passe isso como um argumento para o Javascript. Portanto:\nString name = selenium.getEval( \u0026#34;selenium.browserbot.findElement(\u0026#39;id=foo\u0026#39;, browserbot.getCurrentWindow()).tagName\u0026#34;); se torna:\nWebElement element = driver.findElement(By.id(\u0026#34;foo\u0026#34;)); String name = (String) ((JavascriptExecutor) driver).executeScript( \u0026#34;return arguments[0].tagName\u0026#34;, element); Observe como a variável \u0026ldquo;element\u0026rdquo; passada aparece como o primeiro item na array de \u0026ldquo;arguments\u0026rdquo; padrão do JS.\nA execução de Javascript não retorna nada O JavascriptExecutor do WebDriver envolverá todo o JS e o avaliará como uma expressão anônima. Isso significa que você precisa usar a palavra-chave \u0026ldquo;return\u0026rdquo;:\nString title = selenium.getEval(\u0026#34;browserbot.getCurrentWindow().document.title\u0026#34;); se torna:\n((JavascriptExecutor) driver).executeScript(\u0026#34;return document.title;\u0026#34;); "},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/when_to_use_grid/","title":"Quando usar a Grid","tags":[],"description":"","content":"De modo geral, há dois motivos pelos quais você pode querer usar a Grid.\n Para executar seus testes em vários navegadores, várias versões de navegador, e navegadores executados em diferentes sistemas operacionais. Para reduzir o tempo que leva para o conjunto de testes concluir uma aprovação no teste.  A Grid é usada para acelerar a execução dos testes usando várias máquinas para executar testes em paralelo. Por exemplo, se você tiver um conjunto de 100 testes, mas você configurou o Grid para suportar 4 máquinas diferentes (VMs ou máquinas físicas separadas) para executar esses testes, seu conjunto de testes será concluído em (aproximadamente) um quarto do tempo, do que se você executasse seus testes sequencialmente em uma única máquina. Para grandes conjuntos de testes e conjuntos de testes de longa duração, como aqueles que realizam grandes quantidades de validação de dados, isso pode ser um economizador de tempo significativo. Alguns conjuntos de testes podem levar horas para serem executados. Outro motivo para impulsionar o tempo gasto na execução do pacote é para encurtar o tempo de resposta para os resultados do teste após o código de check-in dos desenvolvedores para o AUT. Cada vez mais equipes de software praticando o desenvolvimento de software Agile desejam testar o feedback tão imediatamente quanto possível, em oposição a esperar durante a noite para uma aprovação no teste durante a noite.\nA Grid também é usada para suportar testes em execução em vários ambientes de runtime, especificamente, em diferentes navegadores ao mesmo tempo. Por exemplo, uma ‘Grid’ de máquinas virtuais pode ser configurada com cada uma suportando um navegador diferente que o aplicativo a ser testado deve suportar. Então, máquina 1 tem Internet Explorer 8, máquina 2, Internet Explorer 9, máquina 3, o mais recente Chrome e máquina 4 com o Firefox mais recente. Quando o conjunto de testes é executado, o Selenium Grid recebe cada combinação de navegador de teste e atribui cada teste a um navegador necessário.\nAlém disso, pode-se ter uma Grid do mesmo navegador, tipo e versão. Por exemplo, pode-se ter uma Grid de 4 máquinas, cada uma executando 3 instâncias de Firefox 70, permitindo um ‘server-farm’ (em certo sentido) de Firefox. Quando o pacote é executado, cada teste é passado para o Grid que atribui o teste à próxima instância disponível do Firefox. Desta maneira um obtém aprovação em que, concebivelmente, 12 testes estão sendo executados ao mesmo tempo em paralelo, reduzindo significativamente o tempo necessário para concluir os testes.\nA Grid é muito flexível. Esses dois exemplos podem ser combinados para permitir várias instâncias de cada tipo e versão de navegador. Uma configuração como essa forneceria execução paralela para conclusão rápida de testes e suporte para vários tipos e versões de navegador simultaneamente.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/driver_idiosyncrasies/driver_specific_capabilities/","title":"Recursos específicos do Driver","tags":[],"description":"","content":"Firefox Definindo recursos usando FirefoxOptions FirefoxOptions é a nova forma de definir recursos para o Navegador Firefox e geralmente deve ser usado em detrimento de DesiredCapabilities.\nJava Python C# Ruby JavaScript Kotlin FirefoxOptions options = new FirefoxOptions(); options.addPreference(\u0026#34;network.proxy.type\u0026#34;, 0); driver = new RemoteWebDriver(options);   from selenium.webdriver.firefox.options import Options options = Options() options.headless = True driver = webdriver.Firefox(options=options)   var options = new FirefoxOptions(); options.Proxy.Kind = ProxyKind.Direct; var driver = new FirefoxDriver(options);   require \u0026#39;selenium-webdriver\u0026#39; opts = Selenium::WebDriver::Firefox::Options.new(args: [\u0026#39;-headless\u0026#39;]) driver = Selenium::WebDriver.for(:firefox, options: opts)   const { Builder } = require(\u0026#34;selenium-webdriver\u0026#34;); const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); options.headless(); const driver = new Builder() .forBrowser(\u0026#39;firefox\u0026#39;) .setFirefoxOptions(options) .build();   val options = new FirefoxOptions() options.addPreference(\u0026#34;network.proxy.type\u0026#34;, 0) driver = RemoteWebDriver(options)     Definindo um perfil personalizado É possível criar um perfil personalizado para o Firefox, conforme demonstrado abaixo.\nJava Python C# Ruby JavaScript Kotlin FirefoxProfile profile = new FirefoxProfile(); FirefoxOptions options = new FirefoxOptions(); options.setProfile(profile); driver = new RemoteWebDriver(options);   from selenium.webdriver.firefox.options import Options from selenium.webdriver.firefox.firefox_profile import FirefoxProfile options=Options() firefox_profile = FirefoxProfile() firefox_profile.set_preference(\u0026#34;javascript.enabled\u0026#34;, False) options.profile = firefox_profile   var options = new FirefoxOptions(); var profile = new FirefoxProfile(); options.Profile = profile; var driver = new RemoteWebDriver(options);   profile = Selenium::WebDriver::Firefox::Profile.new profile[\u0026#39;browser.download.dir\u0026#39;] = \u0026#34;/tmp/webdriver-downloads\u0026#34; options = Selenium::WebDriver::Firefox::Options.new(profile: profile) driver = Selenium::WebDriver.for :firefox, options: options   const { Builder } = require(\u0026#34;selenium-webdriver\u0026#34;); const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); let profile = \u0026#39;/path to custom profile\u0026#39;; options.setProfile(profile); const driver = new Builder() .forBrowser(\u0026#39;firefox\u0026#39;) .setFirefoxOptions(options) .build();   val options = FirefoxOptions() options.profile = FirefoxProfile() driver = RemoteWebDriver(options)     Internet Explorer fileUploadDialogTimeout Em alguns ambientes, o Internet Explorer pode expirar ao abrir a Caixa de Diálogo de upload de arquivo. O IEDriver tem um tempo limite padrão de 1000 ms, mas você pode aumentar o tempo limite usando o recurso fileUploadDialogTimeout.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.waitForUploadDialogUpTo(Duration.ofSeconds(2)); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.file_upload_dialog_timeout = 2000 driver = webdriver.Ie(options=options) # Navegar para Url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.FileUploadDialogTimeout = TimeSpan.FromMilliseconds(2000); var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.file_upload_dialog_timeout = 2000 driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().fileUploadDialogTimeout(2000); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.waitForUploadDialogUpTo(Duration.ofSeconds(2)) val driver = RemoteWebDriver(options)     ensureCleanSession Quando definido como true, este recurso limpa o Cache, Histórico do navegador e cookies para todas as instâncias em execução do InternetExplorer, incluindo aquelas iniciadas manualmente ou pelo driver. Por padrão, é definido como false.\nUsar este recurso causará queda de desempenho quando iniciar o navegador, pois o driver irá esperar até que o cache seja limpo antes de iniciar o navegador IE.\nEsse recurso aceita um valor booleano como parâmetro.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.destructivelyEnsureCleanSession(); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.ensure_clean_session = True driver = webdriver.Ie(options=options) # Navegar para Url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.EnsureCleanSession = true; var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.ensure_clean_session = true driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().ensureCleanSession(true); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.destructivelyEnsureCleanSession() val driver = RemoteWebDriver(options)     ignoreZoomSetting O driver do InternetExplorer espera que o nível de zoom do navegador seja de 100%, caso contrário, o driver lançará uma exceção. Este comportamento padrão pode ser desativado definindo ignoreZoomSetting como true.\nEsse recurso aceita um valor booleano como parâmetro.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.ignoreZoomSettings(); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.ignore_zoom_level = True driver = webdriver.Ie(options=options) # Navegar para Url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.IgnoreZoomLevel = true; var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.ignore_zoom_level = true driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().ignoreZoomSetting(true); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.ignoreZoomSettings() val driver = RemoteWebDriver(options)     ignoreProtectedModeSettings Se deve ignorar a verificação do Modo protegido durante o lançamento uma nova sessão do IE.\nSe não for definido e as configurações do Modo protegido não forem iguais para todas as zonas, uma exceção será lançada pelo driver.\nSe a capacidade for definida como true, os testes podem tornar-se instáveis, não responderem ou os navegadores podem travar. No entanto, esta ainda é de longe a segunda melhor escolha, e a primeira escolha sempre deve ser definir as configurações do Modo protegido de cada zona manualmente. Se um usuário estiver usando esta propriedade, apenas um \u0026ldquo;melhor esforço\u0026rdquo; no suporte será dado.\nEsse recurso aceita um valor booleano como parâmetro.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.introduceFlakinessByIgnoringSecurityDomains(); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.ignore_protected_mode_settings = True driver = webdriver.Ie(options=options) # Navegar para Url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.IntroduceInstabilityByIgnoringProtectedModeSettings = true; var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.ignore_protected_mode_settings = true driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().introduceFlakinessByIgnoringProtectedModeSettings(true); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.introduceFlakinessByIgnoringSecurityDomains() val driver = RemoteWebDriver(options)     silent Quando definido como true, esse recurso suprime a saída de diagnóstico do IEDriverServer.\nEsse recurso aceita um valor booleano como parâmetro.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.setCapability(\u0026#34;silent\u0026#34;, true); WebDriver driver = new InternetExplorerDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.set_capability(\u0026#34;silent\u0026#34;, True) driver = webdriver.Ie(options=options) # Navegar para Url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   InternetExplorerOptions options = new InternetExplorerOptions(); options.AddAdditionalInternetExplorerOption(\u0026#34;silent\u0026#34;, true); IWebDriver driver = new InternetExplorerDriver(options);   # Por favor inclua um PR para adicionar uma amostra de código   const {Builder,By, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); let caps = Capabilities.ie(); caps.set(\u0026#39;silent\u0026#39;, true); (async function example() { let driver = await new Builder() .forBrowser(\u0026#39;internet explorer\u0026#39;) .withCapabilities(caps) .build(); try { await driver.get(\u0026#39;http://www.google.com/ncr\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.Capabilities import org.openqa.selenium.ie.InternetExplorerDriver import org.openqa.selenium.ie.InternetExplorerOptions fun main() { val options = InternetExplorerOptions() options.setCapability(\u0026#34;silent\u0026#34;, true) val driver = InternetExplorerDriver(options) try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;) val caps = driver.getCapabilities() println(caps) } finally { driver.quit() } }     Opções de linha de comando do IE O Internet Explorer inclui várias opções de linha de comando que permitem solucionar problemas e configurar o navegador.\nOs seguintes pontos descrevem algumas opções de linha de comando com suporte\n  -private: Usado para iniciar o IE no modo de navegação privada. Isso funciona para o IE 8 e versões posteriores.\n  -k: Inicia o Internet Explorer no modo quiosque. O navegador é aberto em uma janela maximizada que não exibe a barra de endereço, os botões de navegação ou a barra de status.\n  -extoff: Inicia o IE no modo sem add-on. Esta opção é usada especificamente para solucionar problemas com complementos do navegador. Funciona no IE 7 e versões posteriores.\n  Nota: forceCreateProcessApi deve ser habilitado para que os argumentos da linha de comando funcionem.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; public class ieTest { public static void main(String[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); options.addCommandSwitches(\u0026#34;-k\u0026#34;); InternetExplorerDriver driver = new InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); Capabilities caps = driver.getCapabilities(); System.out.println(caps); } finally { driver.quit(); } } }   from selenium import webdriver options = webdriver.IeOptions() options.add_argument(\u0026#39;-private\u0026#39;) options.force_create_process_api = True driver = webdriver.Ie(options=options) # Navegar para Url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using System; using OpenQA.Selenium; using OpenQA.Selenium.IE; namespace ieTest { class Program { static void Main(string[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.ForceCreateProcessApi = true; options.BrowserCommandLineArguments = \u0026#34;-k\u0026#34;; IWebDriver driver = new InternetExplorerDriver(options); driver.Url = \u0026#34;https://google.com/ncr\u0026#34;; } } }   require \u0026#39;selenium-webdriver\u0026#39; options = Selenium::WebDriver::IE::Options.new options.force_create_process_api = true options.add_argument(\u0026#39;-k\u0026#39;) driver = Selenium::WebDriver.for(:ie, options: options) begin # Navegar para URL driver.get \u0026#39;https://google.com\u0026#39; puts(driver.capabilities.to_json) ensure driver.quit end   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options(); options.addBrowserCommandSwitches(\u0026#39;-k\u0026#39;); options.addBrowserCommandSwitches(\u0026#39;-private\u0026#39;); options.forceCreateProcessApi(true); driver = await env.builder() .setIeOptions(options) .build();   import org.openqa.selenium.Capabilities import org.openqa.selenium.ie.InternetExplorerDriver import org.openqa.selenium.ie.InternetExplorerOptions fun main() { val options = InternetExplorerOptions() options.useCreateProcessApiToLaunchIe() options.addCommandSwitches(\u0026#34;-k\u0026#34;) val driver = InternetExplorerDriver(options) try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;) val caps = driver.getCapabilities() println(caps) } finally { driver.quit() } }     forceCreateProcessApi Força a inicialização do Internet Explorer usando a API CreateProcess. O valor padrão é falso.\nPara IE 8 e superior, esta opção requer que o valor de registro \u0026ldquo;TabProcGrowth\u0026rdquo; seja definido como 0.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; public class ieTest { public static void main(String[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); InternetExplorerDriver driver = new InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); Capabilities caps = driver.getCapabilities(); System.out.println(caps); } finally { driver.quit(); } } }   from selenium import webdriver options = webdriver.IeOptions() options.force_create_process_api = True driver = webdriver.Ie(options=options) # Navegar para Url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using System; using OpenQA.Selenium; using OpenQA.Selenium.IE; namespace ieTest { class Program { static void Main(string[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.ForceCreateProcessApi = true; IWebDriver driver = new InternetExplorerDriver(options); driver.Url = \u0026#34;https://google.com/ncr\u0026#34;; } } }   require \u0026#39;selenium-webdriver\u0026#39; options = Selenium::WebDriver::IE::Options.new options.force_create_process_api = true driver = Selenium::WebDriver.for(:ie, options: options) begin # Navegar para Url driver.get \u0026#39;https://google.com\u0026#39; puts(driver.capabilities.to_json) ensure driver.quit end   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options(); options.forceCreateProcessApi(true); driver = await env.builder() .setIeOptions(options) .build();   import org.openqa.selenium.Capabilities import org.openqa.selenium.ie.InternetExplorerDriver import org.openqa.selenium.ie.InternetExplorerOptions fun main() { val options = InternetExplorerOptions() options.useCreateProcessApiToLaunchIe() val driver = InternetExplorerDriver(options) try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;) val caps = driver.getCapabilities() println(caps) } finally { driver.quit() } }     "},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/driver_requirements/","title":"Requerimentos do driver","tags":[],"description":"","content":" Page being translated from English to Brazilian Portuguese. Do you speak Brazilian Portuguese? Help us to translate it by sending us pull requests!\n Through WebDriver, Selenium supports all major browsers on the market such as Chrom(ium), Firefox, Internet Explorer, Opera, and Safari. Where possible, WebDriver drives the browser using the browser\u0026rsquo;s built-in support for automation, although not all browsers have official support for remote control.\nWebDriver\u0026rsquo;s aim is to emulate a real user\u0026rsquo;s interaction with the browser as closely as possible. This is possible at varying levels in different browsers. For more details on the different driver idiosyncracies, please see Driver Idiosyncracies.\nEven though all the drivers share a single user-facing interface for controlling the browser, they have slightly different ways of setting up browser sessions. Since many of the driver implementations are provided by third parties, they are not included in the standard Selenium distribution.\nDriver instantiation, profile management, and various browser specific settings are examples of parameters that have different requirements depending on the browser. This section explains the basic requirements for getting you started with the different browsers.\nAdding Executables to your PATH Most drivers require an extra executable for Selenium to communicate with the browser. You can manually specify where the executable lives before starting WebDriver, but this can make your tests less portable as the executables will need to be in the same place on every machine, or include the executable within your test code repository.\nBy adding a folder containing WebDriver\u0026rsquo;s binaries to your system\u0026rsquo;s path, Selenium will be able to locate the additional binaries without requiring your test code to locate the exact location of the driver.\n Create a directory to place the executables in, like C:\\WebDriver\\bin or /opt/WebDriver/bin Add the directory to your PATH:  On Windows - Open a command prompt as administrator and run the following command to permanently add the directory to your path for all users on your machine:    setx /m path \u0026#34;%path%;C:\\WebDriver\\bin\\\u0026#34;  Bash users on macOS and Linux - In a terminal:  export PATH=$PATH:/opt/WebDriver/bin \u0026gt;\u0026gt; ~/.profile   You are now ready to test your changes. Close all open command prompts and open a new one. Type out the name of one of the binaries in the folder you created in the previous step, e.g.:\nchromedriver   If your PATH is configured correctly, you will see some output relating to the startup of the driver:\n  Starting ChromeDriver 2.25.426935 (820a95b0b81d33e42712f9198c215f703412e1a1) on port 9515 Only local connections are allowed. You can regain control of your command prompt by pressing Ctrl+CQuick reference    Browser Supported OS Maintained by Download Issue Tracker     Chromium/Chrome Windows/macOS/Linux Google Downloads Issues   Firefox Windows/macOS/Linux Mozilla Downloads Issues   Edge Windows 10 Microsoft Downloads Issues   Internet Explorer Windows Selenium Project Downloads Issues   Safari macOS El Capitan and newer Apple Built in Issues   Opera Windows/macOS/Linux Opera Downloads Issues    Chromium/Chrome To drive Chrome or Chromium, you have to download chromedriver and put it in a folder that is on your system\u0026rsquo;s path.\nOn Linux or macOS, this means modifying the PATH environmental variable. You can see what directories, separated by a colon, make up your system\u0026rsquo;s path by executing the following command:\n$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin To include chromedriver on the path, if it is not already, make sure you include the chromedriver binary\u0026rsquo;s parent directory. The following line will set the PATH environmental variable its current content, plus an additional path added after the colon:\n$ export PATH=\u0026#34;$PATH:/path/to/chromedriver\u0026#34; When chromedriver is available on your path, you should be able to execute the chromedriver executable from any directory.\nTo instantiate a Chrome/Chromium session, you can do the following:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeDriver; WebDriver driver = new ChromeDriver();   #Simple assignment from selenium.webdriver import Chrome driver = Chrome() #Or use the context manager from selenium.webdriver import Chrome with Chrome() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; IWebDriver driver = new ChromeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :chrome   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.chrome.ChromeDriver val driver: WebDriver = ChromeDriver()     Remember that you have to set the path to the chromedriver executable. This is possible using the following line:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;/path/to/chromedriver\u0026#34;);   Chrome(executable_path=\u0026#39;/path/to/chromedriver\u0026#39;)   new ChromeDriver(\u0026#34;/path/to/chromedriver\u0026#34;);   Selenium::WebDriver::Chrome.driver_path = \u0026#34;/path/to/chromedriver\u0026#34;   chrome.setDefaultService(new chrome.ServiceBuilder(\u0026#39;path/to/chromedriver\u0026#39;).build());   System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;/path/to/chromedriver\u0026#34;)     The chromedriver is implemented as a WebDriver remote server that instructs the browser what to do by exposing Chrome\u0026rsquo;s internal automation proxy interface.\nFirefox Starting with Selenium 3, Mozilla has taken over implementation of Firefox Driver, with geckodriver. The new driver for Firefox is called geckodriver and works with Firefox 48 and newer. Since the Firefox WebDriver is under development, the newer the Firefox version the better the support.\nAs geckodriver is the new default way of launching Firefox, you can instantiate Firefox in the same way as Selenium 2:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.firefox.FirefoxDriver; WebDriver driver = new FirefoxDriver();   #Simple assignment from selenium.webdriver import Firefox driver = Firefox() #Or use the context manager from selenium.webdriver import Firefox with Firefox() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Firefox; IWebDriver driver = new FirefoxDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :firefox   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.Firefox.FirefoxDriver val driver: WebDriver = FirefoxDriver()     If you prefer not to set geckodriver\u0026rsquo;s location using PATH, set the geckodriver binary location programmatically:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.gecko.driver\u0026#34;, \u0026#34;/path/to/geckodriver\u0026#34;);   Firefox(executable_path=\u0026#39;/path/to/geckodriver\u0026#39;)   new FirefoxDriver(\u0026#34;/path/to/geckodriver\u0026#34;);   Selenium::WebDriver::Firefox.driver_path = \u0026#34;/path/to/geckodriver\u0026#34;   const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); options.setBinary(\u0026#34;/path/to/geckodriver\u0026#34;);   System.setProperty(\u0026#34;webdriver.gecko.driver\u0026#34;, \u0026#34;/path/to/geckodriver\u0026#34;)     It is also possible to set the property at run time:\nmvn test -Dwebdriver.gecko.driver=/path/to/geckodriver It is currently possible to revert to the older, more feature complete Firefox driver, by installing Firefox 47.0.1 or 45 ESR and specifying a desired capability of marionette as false. Later releases of Firefox are no longer compatible.\nEdge Edge is Microsoft\u0026rsquo;s newest browser, included with Windows 10 and Server 2016. Updates to Edge are bundled with major Windows updates, so you will need to download a binary which matches the build number of your currently installed build of Windows. The Edge Developer site contains links to all the available binaries. Bugs against the EdgeDriver implementation can be raised with Microsoft. If you would like to run tests against Edge, but are not running Windows 10, Microsoft offer free VMs for testers on the Edge Developer site.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.edge.EdgeDriver; WebDriver driver = new EdgeDriver();   #Simple assignment from selenium.webdriver import Edge driver = Edge() #Or use the context manager from selenium.webdriver import Edge with Edge() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Edge; IWebDriver driver = new EdgeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :edge   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;MicrosoftEdge\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.edge.EdgeDriver val driver: WebDriver = EdgeDriver()     If Edge driver is not present in your path, you can set the path using the following line:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.edge.driver\u0026#34;, \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;);   Edge(executable_path=\u0026#39;/path/to/MicrosoftWebDriver.exe\u0026#39;)   new EdgeDriver(\u0026#34;/path/to/MicrosoftWebDriver.exe\u0026#34;);   Selenium::WebDriver::Edge.driver_path = \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const edge = require(\u0026#39;selenium-webdriver/edge\u0026#39;); let service = new edge.ServiceBuilder(\u0026#34;/path/to/msedgedriver.exe\u0026#34;); (async function test() { let driver = await new Builder() .setEdgeService(service) .forBrowser(\u0026#39;MicrosoftEdge\u0026#39;) .build(); })();   System.setProperty(\u0026#34;webdriver.edge.driver\u0026#34;, \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;)     Internet Explorer Internet Explorer was Microsoft\u0026rsquo;s default browser until Windows 10, although it is still included in Windows 10. Internet Explorer Driver is the only driver The Selenium project aims to support the same releases Microsoft considers current. Older releases may work, but will be unsupported.\nWhile the Selenium project provides binaries for both the 32-bit and 64-bit versions of Internet Explorer, there are some limitations with Internet Explorer 10 \u0026amp; 11 with the 64-bit driver, but using the 32-bit driver continues to work well. It should be noted that as Internet Explorer preferences are saved against the logged in user\u0026rsquo;s account, some additional setup is required.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.ie.InternetExplorerDriver; WebDriver driver = new InternetExplorerDriver();   #Simple assignment from selenium.webdriver import Ie driver = Ie() #Or use the context manager from selenium.webdriver import Ie with Ie() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.IE; IWebDriver driver = new InternetExplorerDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;internet explorer\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.ie.InternetExplorerDriver val driver: WebDriver = InternetExplorerDriver()     If Internet Explorer driver is not present in your path, you can set the path using the following line:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.ie.driver\u0026#34;, \u0026#34;C:/path/to/IEDriver.exe\u0026#34;);   Ie(executable_path=\u0026#39;/path/to/IEDriverServer.exe\u0026#39;)   new InternetExplorerDriver(\u0026#34;C:/path/to/IEDriver.exe\u0026#34;);   Selenium::WebDriver::IE.driver_path = \u0026#34;C:/path/to/IEDriver.exe\u0026#34;   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let service = new ie.ServiceBuilder(\u0026#34;/path/to/IEDriverServer.exe\u0026#34;); (async function test() { let driver = await new Builder() .setIeService(service) .forBrowser(\u0026#39;internet explorer\u0026#39;) .build(); })();   System.setProperty(\u0026#34;webdriver.ie.driver\u0026#34;, \u0026#34;C:/path/to/IEDriver.exe\u0026#34;)     Microsoft also offer a WebDriver binary for Internet Explorer 11 on Windows 7 \u0026amp; 8.1. It has not been updated since 2014 and is based on a draft version of the W3 specification. Jim Evans has an excellent writeup on Microsoft\u0026rsquo;s implementation.\nOpera Current releases of Opera are built on top of the Chromium engine, and WebDriver is now supported via the closed-source Opera Chromium Driver, which can be added to your PATH or as a system property.\nInstantiating a driver session is similar to Firefox and Chromium:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.opera.OperaDriver; WebDriver driver = new OperaDriver();   #Simple assignment from selenium.webdriver import Opera driver = Opera() #Or use the context manager from selenium.webdriver import Opera with Opera() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Opera; IWebDriver driver = new OperaDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :opera   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const opera = require(\u0026#39;selenium-webdriver/opera\u0026#39;); (async function test() { let driver = await new Builder() .forBrowser(\u0026#39;opera\u0026#39;) .build(); })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.opera.OperaDriver val driver: WebDriver = OperaDriver()     Safari High Sierra and later:\n Run the following command from the terminal for the first time and type your password at the prompt to authorise WebDriver  safaridriver --enable El Capitan and Sierra:\n Enable the Developer menu from Safari preferences Check the Allow Remote Automation option from with the Develop menu Run the following command from the terminal for the first time and type your password at the prompt to authorise WebDriver  /usr/bin/safaridriver -p 1337\u0026lt;/ You can then start a driver session using:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.safari.SafariDriver; WebDriver driver = new SafariDriver();   #Simple assignment from selenium.webdriver import Safari driver = Safari() #Or use the context manager from selenium.webdriver import Safari with Safari() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Safari; IWebDriver driver = new SafariDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :safari   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;safari\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.safari.SafariDriver val driver: WebDriver = SafariDriver()     Those looking to automate Safari on iOS should look to the Appium project. Whilst Safari was previously available for Windows, Apple has long since dropped support, making it a poor choice of test platform.\nMock browsers HtmlUnit HtmlUnit is a \u0026ldquo;GUI-Less browser for Java programs\u0026rdquo;. It models HTML documents and provides an API that allows you to invoke pages, fill out forms, click links, etc. It has JavaScript support and is able to work with AJAX libraries, simulating Chrome, Firefox or Internet Explorer depending on the configuration used. It has been moved to a new location. The source is maintained on svn.\nPhantomJS PhantomJS is a headless browser based on Webkit, albeit a version much older than that used by Google Chrome or Safari. Whilst historically a popular choice, it would now be wise to avoid PhantomJS. The project has been unmaintained since the 5th of August 2017, so whilst the web will continue to change, PhantomJS will not be updated. This was after Google announced the ability to run Chrome headlessly, something also now offered by Mozilla\u0026rsquo;s Firefox.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/introduction/on_test_automation/","title":"Sobre automação de testes","tags":[],"description":"","content":"Primeiro, comece perguntando a si mesmo se você realmente precisa ou não de um navegador. As probabilidades são de que, em algum ponto, se você estiver trabalhando em um aplicativo da web complexo, você precisará abrir um navegador e realmente testá-lo.\nNo entanto, os testes funcionais do usuário final, como os testes Selenium, são caros para executar. Além disso, eles normalmente exigem infraestrutura substancial para ser executado de forma eficaz. É uma boa regra sempre se perguntar se o que você deseja testar pode ser feito usando abordagens de teste mais leves, como testes de unidade ou com uma abordagem de nível inferior.\nDepois de determinar que está no negócio de teste de navegador da web, e você tem seu ambiente Selenium pronto para começar a escrever testes, você geralmente executará alguma combinação de três etapas:\n Configurar os dados Executar um conjunto discreto de ações Avaliar os resultados  Você deve manter essas etapas o mais curtas possível; uma ou duas operações devem ser suficientes na maioria das vezes. A automação do navegador tem a reputação de ser \u0026ldquo;instável\u0026rdquo;, mas, na realidade, é porque os usuários freqüentemente exigem muito dele. Em capítulos posteriores, retornaremos às técnicas que você pode usar para mitigar problemas aparentemente intermitentes nos testes, em particular sobre como superar as condições de corrida entre o navegador e o WebDriver.\nMantendo seus testes curtos e usando o navegador da web apenas quando você não tiver absolutamente nenhuma alternativa, você pode ter muitos testes com instabilidade mínima.\nUma vantagem distinta dos testes do Selenium é sua capacidade inerente de testar todos os componentes do aplicativo, de back-end para front-end, da perspectiva do usuário. Em outras palavras, embora os testes funcionais possam ser caros para executar, eles também abrangem grandes partes críticas para os negócios de uma só vez.\nRequerimentos de teste Como mencionado antes, os testes do Selenium podem ser caros para serem executados. Até que ponto depende do navegador em que você está executando os testes, mas historicamente o comportamento dos navegadores tem variado tanto que muitas vezes foi uma meta declarada testar cruzado contra vários navegadores.\nSelenium permite que você execute as mesmas instruções em vários navegadores em vários sistemas operacionais, mas a enumeração de todos os navegadores possíveis, suas diferentes versões e os muitos sistemas operacionais em que são executados rapidamente se tornará uma tarefa não trivial.\nVamos começar com um exemplo Larry escreveu um site que permite aos usuários solicitarem seus unicórnios personalizados.\nO fluxo de trabalho geral (o que chamaremos de \u0026ldquo;caminho feliz\u0026rdquo;) é algo como isso:\n Criar uma conta Configurar o unicórnio Adicionar ao carrinho de compras Verificar e pagar Dar feedback sobre o unicórnio  Seria tentador escrever um grande roteiro do Selenium para realizar todas essas operações - muitos tentarão. Resista à tentação! Isso resultará em um teste que a) leva muito tempo, b) estará sujeito a alguns problemas comuns em torno de problemas de tempo de renderização de página, e c) se falhar, não lhe dará um método conciso e “superficial” para diagnosticar o que deu errado.\nA estratégia preferida para testar este cenário seria dividi-lo em uma série de testes independentes e rápidos, cada um dos quais tem uma “razão” de existir.\nVamos fingir que você deseja testar a segunda etapa: Configure o unicórnio. Ele executará as seguintes ações:\n Criar uma conta Configurar o unicórnio  Observe que estamos pulando o restante dessas etapas, vamos testar o resto do fluxo de trabalho em outros casos de teste pequenos e discretos depois de terminarmos com este.\nPara começar, você precisa criar uma conta. Aqui você tem algumas escolhas a fazer:\n Deseja usar uma conta existente? Você deseja criar uma nova conta? Existem propriedades especiais de tal usuário que precisam ser levadas em consideração antes do início da configuração?  Independentemente de como você responde a esta pergunta, a solução é torná-la parte da etapa de \u0026ldquo;configurar os dados\u0026rdquo; do teste. Se Larry expôs uma API que permite a você (ou qualquer pessoa) criar e atualizar contas de usuário, certifique-se de usar isso para responder a esta pergunta. Se possível, você deseja iniciar o navegador somente depois de ter um usuário \u0026ldquo;em mãos\u0026rdquo;, cujas credenciais você pode usar para fazer login.\nSe cada teste para cada fluxo de trabalho começar com a criação de uma conta de usuário, muitos segundos serão adicionados à execução de cada teste. Chamar uma API e falar com um banco de dados são operações rápidas, \u0026ldquo;sem cabeçalho\u0026rdquo; que não requerem o processo caro de abrir um navegador, navegar para as páginas certas, clicando e aguardando o envio dos formulários, etc.\nIdealmente, você pode abordar esta fase de configuração em uma linha de código, que será executado antes que qualquer navegador seja iniciado:\nJava Python C# Ruby JavaScript Kotlin // Crie um usuário que tenha permissões somente leitura - eles podem configurar um unicórnio, // mas eles não têm informações de pagamento configuradas, nem têm // privilégios administrativos. No momento em que o usuário é criado, seu endereço // de e-mail e senha são gerados aleatoriamente - você nem precisa // conhecê-los. User user = UserFactory.createCommonUser(); //Este método está definido em algum outro lugar.  // Faça login como este usuário. // O login neste site leva você à sua página pessoal \u0026#34;Minha conta\u0026#34;, e então // o objeto AccountPage é retornado pelo método loginAs, permitindo que você // execute ações da AccountPage. AccountPage accountPage = loginAs(user.getEmail(), user.getPassword());   # Crie um usuário que tenha permissões somente leitura - eles podem configurar um unicórnio, # mas eles não têm informações de pagamento configuradas, nem têm # privilégios administrativos. No momento em que o usuário é criado, seu endereço # de e-mail e senha são gerados aleatoriamente - você nem precisa # conhecê-los. user = user_factory.create_common_user() #This method is defined elsewhere. # Faça login como este usuário. # O login neste site leva você à sua página pessoal \u0026#34;Minha conta\u0026#34;, e então # o objeto AccountPage é retornado pelo método loginAs, permitindo que você # execute ações da AccountPage. account_page = login_as(user.get_email(), user.get_password())   // Crie um usuário que tenha permissões somente leitura - eles podem configurar um unicórnio, // mas eles não têm informações de pagamento configuradas, nem têm // privilégios administrativos. No momento em que o usuário é criado, seu endereço // de e-mail e senha são gerados aleatoriamente - você nem precisa // conhecê-los. User user = UserFactory.CreateCommonUser(); //This method is defined elsewhere.  // Faça login como este usuário. // O login neste site leva você à sua página pessoal \u0026#34;Minha conta\u0026#34;, e então // o objeto AccountPage é retornado pelo método loginAs, permitindo que você // execute ações da AccountPage. AccountPage accountPage = LoginAs(user.Email, user.Password);   # Crie um usuário que tenha permissões somente leitura - eles podem configurar um unicórnio, # mas eles não têm informações de pagamento configuradas, nem têm # privilégios administrativos. No momento em que o usuário é criado, seu endereço # de e-mail e senha são gerados aleatoriamente - você nem precisa # conhecê-los. user = UserFactory.create_common_user #This method is defined elsewhere. # Faça login como este usuário. # O login neste site leva você à sua página pessoal \u0026#34;Minha conta\u0026#34;, e então # o objeto AccountPage é retornado pelo método loginAs, permitindo que você # execute ações da AccountPage. account_page = login_as(user.email, user.password)   // Crie um usuário que tenha permissões somente leitura - eles podem configurar um unicórnio, // mas eles não têm informações de pagamento configuradas, nem têm // privilégios administrativos. No momento em que o usuário é criado, seu endereço // de e-mail e senha são gerados aleatoriamente - você nem precisa // conhecê-los. var user = userFactory.createCommonUser(); //This method is defined elsewhere.  // Faça login como este usuário. // O login neste site leva você à sua página pessoal \u0026#34;Minha conta\u0026#34;, e então // o objeto AccountPage é retornado pelo método loginAs, permitindo que você // execute ações da AccountPage. var accountPage = loginAs(user.email, user.password);   // Crie um usuário que tenha permissões somente leitura - eles podem configurar um unicórnio, // mas eles não têm informações de pagamento configuradas, nem têm // privilégios administrativos. No momento em que o usuário é criado, seu endereço // de e-mail e senha são gerados aleatoriamente - você nem precisa // conhecê-los. val user = UserFactory.createCommonUser() //This method is defined elsewhere.  // Faça login como este usuário. // O login neste site leva você à sua página pessoal \u0026#34;Minha conta\u0026#34;, e então // o objeto AccountPage é retornado pelo método loginAs, permitindo que você // execute ações da AccountPage. val accountPage = loginAs(user.getEmail(), user.getPassword())     Como você pode imaginar, a UserFactory pode ser estendida para fornecer métodos como createAdminUser () e createUserWithPayment (). A questão é que essas duas linhas de código não o distraem do objetivo final deste teste: configurando um unicórnio.\nOs detalhes do modelo de objeto de página será discutido em capítulos posteriores, mas vamos apresentar o conceito aqui:\nSeus testes devem ser compostos de ações, realizadas do ponto de vista do usuário, dentro do contexto das páginas do site. Essas páginas são armazenadas como objetos, que conterão informações específicas sobre como a página da web é composta e como as ações são realizadas - muito pouco disso deve preocupar você como testador.\nQue tipo de unicórnio você quer? Você pode querer rosa, mas não necessariamente. Roxo tem sido bastante popular ultimamente. Ela precisa de óculos escuros? Tatuagens de estrelas? Essas escolhas, embora difíceis, são sua principal preocupação como testador - você precisa garantir que seu centro de atendimento de pedidos envia o unicórnio certo para a pessoa certa, e isso começa com essas escolhas.\nObserve que em nenhum lugar desse parágrafo falamos sobre botões, campos, menus suspensos, botões de opção ou formulários da web. Nem deveriam seus testes! Você deseja escrever seu código como o usuário tentando resolver seu problema. Aqui está uma maneira de fazer isso (continuando do exemplo anterior):\nJava Python C# Ruby JavaScript Kotlin // O Unicórnio é um objeto de nível superior - ele possui atributos, que são definidos aqui. // Isso armazena apenas os valores; não preenche formulários da web nem interage // com o navegador de qualquer forma. Unicorn sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS); // Uma vez que já estamos \u0026#34;na\u0026#34; página da conta, temos que usá-la para chegar ao // lugar real onde você configura os unicórnios. Chamar o método \u0026#34;Add Unicorn\u0026#34; // nos leva lá. AddUnicornPage addUnicornPage = accountPage.addUnicorn(); // Agora que estamos na AddUnicornPage, passaremos o objeto \u0026#34;sparkles\u0026#34; para // o método createUnicorn(). Este método pegará os atributos do Sparkles, // preencher o formulário e clicar em enviar. UnicornConfirmationPage unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles);   # O Unicórnio é um objeto de nível superior - ele possui atributos, que são definidos aqui. # Isso armazena apenas os valores; não preenche formulários da web nem interage # com o navegador de qualquer forma. sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) # Uma vez que já estamos \u0026#34;na\u0026#34; página da conta, temos que usá-la para chegar ao # lugar real onde você configura os unicórnios. Chamar o método \u0026#34;Add Unicorn\u0026#34; # nos leva lá. add_unicorn_page = account_page.add_unicorn() # Agora que estamos na AddUnicornPage, passaremos o objeto \u0026#34;sparkles\u0026#34; para # o método createUnicorn(). Este método pegará os atributos do Sparkles, # preencher o formulário e clicar em enviar. unicorn_confirmation_page = add_unicorn_page.create_unicorn(sparkles)   // O Unicórnio é um objeto de nível superior - ele possui atributos, que são definidos aqui. // Isso armazena apenas os valores; não preenche formulários da web nem interage // com o navegador de qualquer forma. Unicorn sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.Purple, UnicornAccessories.Sunglasses, UnicornAdornments.StarTattoos); // Uma vez que já estamos \u0026#34;na\u0026#34; página da conta, temos que usá-la para chegar ao // lugar real onde você configura os unicórnios. Chamar o método \u0026#34;Add Unicorn\u0026#34; // nos leva lá. AddUnicornPage addUnicornPage = accountPage.AddUnicorn(); // Agora que estamos na AddUnicornPage, passaremos o objeto \u0026#34;sparkles\u0026#34; para // o método createUnicorn(). Este método pegará os atributos do Sparkles, // preencher o formulário e clicar em enviar. UnicornConfirmationPage unicornConfirmationPage = addUnicornPage.CreateUnicorn(sparkles);   # O Unicórnio é um objeto de nível superior - ele possui atributos, que são definidos aqui. # Isso armazena apenas os valores; não preenche formulários da web nem interage # com o navegador de qualquer forma. sparkles = Unicorn.new(\u0026#39;Sparkles\u0026#39;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) # Uma vez que já estamos \u0026#34;na\u0026#34; página da conta, temos que usá-la para chegar ao # lugar real onde você configura os unicórnios. Chamar o método \u0026#34;Add Unicorn\u0026#34; # nos leva lá. add_unicorn_page = account_page.add_unicorn # Agora que estamos na AddUnicornPage, passaremos o objeto \u0026#34;sparkles\u0026#34; para # o método createUnicorn(). Este método pegará os atributos do Sparkles, # preencher o formulário e clicar em enviar. unicorn_confirmation_page = add_unicorn_page.create_unicorn(sparkles)   // O Unicórnio é um objeto de nível superior - ele possui atributos, que são definidos aqui. // Isso armazena apenas os valores; não preenche formulários da web nem interage // com o navegador de qualquer forma. var sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS); // Uma vez que já estamos \u0026#34;na\u0026#34; página da conta, temos que usá-la para chegar ao // lugar real onde você configura os unicórnios. Chamar o método \u0026#34;Add Unicorn\u0026#34; // nos leva lá. var addUnicornPage = accountPage.addUnicorn(); // Agora que estamos na AddUnicornPage, passaremos o objeto \u0026#34;sparkles\u0026#34; para // o método createUnicorn(). Este método pegará os atributos do Sparkles, // preencher o formulário e clicar em enviar. var unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles);   // O Unicórnio é um objeto de nível superior - ele possui atributos, que são definidos aqui. // Isso armazena apenas os valores; não preenche formulários da web nem interage // com o navegador de qualquer forma. val sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) // Uma vez que já estamos \u0026#34;na\u0026#34; página da conta, temos que usá-la para chegar ao // lugar real onde você configura os unicórnios. Chamar o método \u0026#34;Add Unicorn\u0026#34; // nos leva lá. val addUnicornPage = accountPage.addUnicorn() // Agora que estamos na AddUnicornPage, passaremos o objeto \u0026#34;sparkles\u0026#34; para // o método createUnicorn(). Este método pegará os atributos do Sparkles, // preencher o formulário e clicar em enviar. unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles)     Agora que você configurou seu unicórnio, você precisa passar para a etapa 3: certifique-se de que realmente funcionou.\nJava Python C# Ruby JavaScript Kotlin // O método exists() de UnicornConfirmationPage pegará o objeto // Sparkles - uma especificação dos atributos que você deseja ver e compará-los // com os campos na página Assert.assertTrue(\u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;, unicornConfirmationPage.exists(sparkles));   # O método exists() de UnicornConfirmationPage pegará o objeto # Sparkles - uma especificação dos atributos que você deseja ver e compará-los # com os campos na página assert unicorn_confirmation_page.exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;   // O método exists() de UnicornConfirmationPage pegará o objeto // Sparkles - uma especificação dos atributos que você deseja ver e compará-los // com os campos na página Assert.True(unicornConfirmationPage.Exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;);   # O método exists() de UnicornConfirmationPage pegará o objeto # Sparkles - uma especificação dos atributos que você deseja ver e compará-los # com os campos na página expect(unicorn_confirmation_page.exists?(sparkles)).to be, \u0026#39;Sparkles should have been created, with all attributes intact\u0026#39;   // O método exists() de UnicornConfirmationPage pegará o objeto // Sparkles - uma especificação dos atributos que você deseja ver e compará-los // com os campos na página assert(unicornConfirmationPage.exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;);   // O método exists() de UnicornConfirmationPage pegará o objeto // Sparkles - uma especificação dos atributos que você deseja ver e compará-los // com os campos na página assertTrue(\u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;, unicornConfirmationPage.exists(sparkles))     Observe que o testador ainda não fez nada além de falar sobre unicórnios neste código– sem botões, sem localizadores, sem controles do navegador. Este método de modelagem do aplicativo permite que você mantenha esses comandos de nível de teste no lugar e imutáveis, mesmo se Larry decidir na próxima semana que não gosta mais de Ruby-on-Rails e decidir reimplementar todo o site em Haskell com um front-end Fortran.\nSeus objetos de página exigirão alguma pequena manutenção para estar conformidade com o redesenho do site, mas esses testes permanecerão os mesmos. Pegando esse design básico, você desejará continuar seus fluxos de trabalho com o menor número possível de etapas voltadas para o navegador. Seu próximo fluxo de trabalho envolverá adicionar um unicórnio ao carrinho de compras. Provavelmente, você desejará muitas iterações deste teste para ter certeza de que o carrinho está mantendo o estado adequado: Existe mais de um unicórnio no carrinho antes de você começar? Quantos cabem no carrinho de compras? Se você criar mais de um com o mesmo nome e / ou recursos, ele falhará? Manterá apenas o existente ou acrescentará outro?\nCada vez que você passa pelo fluxo de trabalho, você deseja evitar ter que criar uma conta, fazer login como o usuário e configurar o unicórnio. Idealmente, você será capaz de criar uma conta e pré-configurar um unicórnio por meio da API ou banco de dados. Em seguida, tudo que você precisa fazer é fazer login como o usuário, localizar Sparkles, e adicioná-lo ao carrinho.\nAutomatizar ou não automatizar? A automação é sempre vantajosa? Quando se deve decidir automatizar os casos de teste?\nNem sempre é vantajoso automatizar casos de teste. Tem vezes que o teste manual pode ser mais apropriado. Por exemplo, se a interface do aplicativo mudará consideravelmente em um futuro próximo, então qualquer automação pode precisar ser reescrita de qualquer maneira. Além disso, às vezes simplesmente não há tempo suficiente para construir automação de testes. A curto prazo, o teste manual pode ser mais eficaz. Se um aplicativo tem um prazo muito curto, atualmente não há automação de teste disponível, e é imperativo que o teste seja feito dentro nesse período, o teste manual é a melhor solução.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/support_packages/working_with_colours/","title":"Trabalhando com cores","tags":[],"description":"","content":"Ocasionalmente, você desejará validar a cor de algo como parte de seus testes; o problema é que as definições de cores na web não são constantes. Não seria bom se houvesse uma maneira fácil de comparar uma representação HEX de uma cor com uma representação RGB de uma cor, ou uma representação RGBA de uma cor com uma representação HSLA de uma cor?\nNão se preocupe. Existe uma solução: a classe Color!\nEm primeiro lugar, você precisará importar a classe:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.support.Color;   from selenium.webdriver.support.color import Color   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    include Selenium::WebDriver::Support   // This feature is not implemented - Help us by sending a pr to implement this feature    import org.openqa.selenium.support.Color    Agora você pode começar a criar objetos coloridos. Cada objeto de cor precisará ser criado a partir de uma representação de string de sua cor. As representações de cores com suporte são:\nJava Python C# Ruby JavaScript Kotlin private final Color HEX_COLOUR = Color.fromString(\u0026#34;#2F7ED8\u0026#34;); private final Color RGB_COLOUR = Color.fromString(\u0026#34;rgb(255, 255, 255)\u0026#34;); private final Color RGB_COLOUR = Color.fromString(\u0026#34;rgb(40%, 20%, 40%)\u0026#34;); private final Color RGBA_COLOUR = Color.fromString(\u0026#34;rgba(255, 255, 255, 0.5)\u0026#34;); private final Color RGBA_COLOUR = Color.fromString(\u0026#34;rgba(40%, 20%, 40%, 0.5)\u0026#34;); private final Color HSL_COLOUR = Color.fromString(\u0026#34;hsl(100, 0%, 50%)\u0026#34;); private final Color HSLA_COLOUR = Color.fromString(\u0026#34;hsla(100, 0%, 50%, 0.5)\u0026#34;);   HEX_COLOUR = Color.from_string(\u0026#39;#2F7ED8\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(255, 255, 255)\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(40%, 20%, 40%)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(255, 255, 255, 0.5)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(40%, 20%, 40%, 0.5)\u0026#39;) HSL_COLOUR = Color.from_string(\u0026#39;hsl(100, 0%, 50%)\u0026#39;) HSLA_COLOUR = Color.from_string(\u0026#39;hsla(100, 0%, 50%, 0.5)\u0026#39;)   // Não temos ainda um exemplo de C# - Nos ajude envando um PR!    HEX_COLOUR = Color.from_string(\u0026#39;#2F7ED8\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(255, 255, 255)\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(40%, 20%, 40%)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(255, 255, 255, 0.5)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(40%, 20%, 40%, 0.5)\u0026#39;) HSL_COLOUR = Color.from_string(\u0026#39;hsl(100, 0%, 50%)\u0026#39;) HSLA_COLOUR = Color.from_string(\u0026#39;hsla(100, 0%, 50%, 0.5)\u0026#39;)   // Essa funcionalidade não está implementada - Nos ajude enviando um PR implementando essa funcionalidade    private val HEX_COLOUR = Color.fromString(\u0026#34;#2F7ED8\u0026#34;) private val RGB_COLOUR = Color.fromString(\u0026#34;rgb(255, 255, 255)\u0026#34;) private val RGB_COLOUR_PERCENT = Color.fromString(\u0026#34;rgb(40%, 20%, 40%)\u0026#34;) private val RGBA_COLOUR = Color.fromString(\u0026#34;rgba(255, 255, 255, 0.5)\u0026#34;) private val RGBA_COLOUR_PERCENT = Color.fromString(\u0026#34;rgba(40%, 20%, 40%, 0.5)\u0026#34;) private val HSL_COLOUR = Color.fromString(\u0026#34;hsl(100, 0%, 50%)\u0026#34;) private val HSLA_COLOUR = Color.fromString(\u0026#34;hsla(100, 0%, 50%, 0.5)\u0026#34;)     A classe Color também suporta todas as definições de cores básicas especificadas em http://www.w3.org/TR/css3-color/#html4.\nJava Python C# Ruby JavaScript Kotlin private final Color BLACK = Color.fromString(\u0026#34;black\u0026#34;); private final Color CHOCOLATE = Color.fromString(\u0026#34;chocolate\u0026#34;); private final Color HOTPINK = Color.fromString(\u0026#34;hotpink\u0026#34;);   BLACK = Color.from_string(\u0026#39;black\u0026#39;) CHOCOLATE = Color.from_string(\u0026#39;chocolate\u0026#39;) HOTPINK = Color.from_string(\u0026#39;hotpink\u0026#39;)   // Não temos ainda um exemplo de C# - Nos ajude envando um PR!    BLACK = Color.from_string(\u0026#39;black\u0026#39;) CHOCOLATE = Color.from_string(\u0026#39;chocolate\u0026#39;) HOTPINK = Color.from_string(\u0026#39;hotpink\u0026#39;)   // Essa funcionalidade não está implementada - Nos ajude enviando um PR implementando essa funcionalidade    private val BLACK = Color.fromString(\u0026#34;black\u0026#34;) private val CHOCOLATE = Color.fromString(\u0026#34;chocolate\u0026#34;) private val HOTPINK = Color.fromString(\u0026#34;hotpink\u0026#34;)     Às vezes, os navegadores retornam um valor de cor \u0026ldquo;transparent\u0026rdquo; se nenhuma cor foi definida em um elemento. A classe Color também oferece suporte para isso:\nJava Python C# Ruby JavaScript Kotlin private final Color TRANSPARENT = Color.fromString(\u0026#34;transparent\u0026#34;);   TRANSPARENT = Color.from_string(\u0026#39;transparent\u0026#39;)   // Não temos ainda um exemplo de C# - Nos ajude envando um PR!    TRANSPARENT = Color.from_string(\u0026#39;transparent\u0026#39;)   // Essa funcionalidade não está implementada - Nos ajude enviando um PR implementando essa funcionalidade    private val TRANSPARENT = Color.fromString(\u0026#34;transparent\u0026#34;)     Agora você pode consultar com segurança um elemento para obter sua cor / cor de fundo sabendo que qualquer resposta será analisada corretamente e convertido em um objeto Color válido:\nJava Python C# Ruby JavaScript Kotlin Color loginButtonColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;)); Color loginButtonBackgroundColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;background-color\u0026#34;));   login_button_colour = Color.from_string(driver.find_element(By.ID,\u0026#39;login\u0026#39;).value_of_css_property(\u0026#39;color\u0026#39;)) login_button_background_colour = Color.from_string(driver.find_element(By.ID,\u0026#39;login\u0026#39;).value_of_css_property(\u0026#39;background-color\u0026#39;))   // Não temos ainda um exemplo de C# - Nos ajude envando um PR!    login_button_colour = Color.from_string(driver.find_element(id: \u0026#39;login\u0026#39;).css_value(\u0026#39;color\u0026#39;)) login_button_background_colour = Color.from_string(driver.find_element(id: \u0026#39;login\u0026#39;).css_value(\u0026#39;background-color\u0026#39;))   // Essa funcionalidade não está implementada - Nos ajude enviando um PR implementando essa funcionalidade    val loginButtonColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;)) val loginButtonBackgroundColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;background-color\u0026#34;))     Você pode então comparar diretamente os objetos coloridos:\nJava Python C# Ruby JavaScript Kotlin assert loginButtonBackgroundColour.equals(HOTPINK);   assert login_button_background_colour == HOTPINK   // Não temos ainda um exemplo de C# - Nos ajude envando um PR!    assert(login_button_background_colour == HOTPINK)   // Essa funcionalidade não está implementada - Nos ajude enviando um PR implementando essa funcionalidade    assert(loginButtonBackgroundColour.equals(HOTPINK))     Ou você pode converter a cor em um dos seguintes formatos e realizar uma validação estática:\nJava Python C# Ruby JavaScript Kotlin assert loginButtonBackgroundColour.asHex().equals(\u0026#34;#ff69b4\u0026#34;); assert loginButtonBackgroundColour.asRgba().equals(\u0026#34;rgba(255, 105, 180, 1)\u0026#34;); assert loginButtonBackgroundColour.asRgb().equals(\u0026#34;rgb(255, 105, 180)\u0026#34;);   assert login_button_background_colour.hex == \u0026#39;#ff69b4\u0026#39; assert login_button_background_colour.rgba == \u0026#39;rgba(255, 105, 180, 1)\u0026#39; assert login_button_background_colour.rgb == \u0026#39;rgb(255, 105, 180)\u0026#39;   // Não temos ainda um exemplo de C# - Nos ajude envando um PR!    assert(login_button_background_colour.hex == \u0026#39;#ff69b4\u0026#39;) assert(login_button_background_colour.rgba == \u0026#39;rgba(255, 105, 180, 1)\u0026#39;) assert(login_button_background_colour.rgb == \u0026#39;rgb(255, 105, 180)\u0026#39;)   // Essa funcionalidade não está implementada - Nos ajude enviando um PR implementando essa funcionalidade    assert(loginButtonBackgroundColour.asHex().equals(\u0026#34;#ff69b4\u0026#34;)) assert(loginButtonBackgroundColour.asRgba().equals(\u0026#34;rgba(255, 105, 180, 1)\u0026#34;)) assert(loginButtonBackgroundColour.asRgb().equals(\u0026#34;rgb(255, 105, 180)\u0026#34;))     As cores não são mais um problema.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/worst_practices/http_response_codes/","title":"Códigos de respostas HTTP","tags":[],"description":"","content":"Para algumas configurações de navegador no Selenium RC, Selenium atuou como um proxy entre o navegador e o site sendo automatizado. Isso significa que todo o tráfego do navegador que passou pelo Selenium poderia ser capturado ou manipulado. O método captureNetworkTraffic() pretendia capturar todo o tráfego de rede entre o navegador e o site sendo automatizado, incluindo códigos de resposta HTTP.\nSelenium WebDriver é uma abordagem completamente diferente para a automação do navegador, preferindo agir mais como um usuário. Isso é representado na maneira como você escreve testes com o WebDriver. Em testes funcionais automatizados, verificar o código de status não é um detalhe particularmente importante da falha de um teste; as etapas que o precederam são mais importantes.\nO navegador sempre representará o código de status HTTP, imagine, por exemplo, uma página de erro 404 ou 500. Uma maneira simples de “falhar rapidamente” quando você encontrar uma dessas páginas de erro é verificar o título da página ou o conteúdo de um ponto confiável (por exemplo, a tag \u0026lt;h1\u0026gt;) após cada carregamento de página. Se você estiver usando o modelo de objeto de página, você pode incluir esta verificação em seu construtor de classe ou ponto semelhante onde o carregamento da página é esperado. Ocasionalmente, o código HTTP pode até ser representado na página de erro do navegador e você pode usar o WebDriver para ler isso e melhorar sua saída de depuração.\nVerificar se a própria página da web está alinhada com a prática ideal do WebDriver de representar a visão do usuário do site.\nSe você insiste, uma solução avançada para capturar códigos de status HTTP é replicar o comportamento do Selenium RC usando um proxy. A API WebDriver fornece a capacidade de definir um proxy para o navegador, e há uma série de proxies que irão permitir que você manipule de forma programática o conteúdo das solicitações enviadas e recebidas do servidor da web. Usar um proxy permite que você decida como deseja responder para códigos de resposta de redirecionamento. Além disso, nem todo navegador torna os códigos de resposta disponíveis para WebDriver, então optar por usar um proxy permite que você tenha uma solução que funciona para todos os navegadores.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/generating_application_state/","title":"Gerando estado da aplicação","tags":[],"description":"","content":"Selenium não deve ser usado para preparar um caso de teste. Tudo as ações repetitivas e preparações para um caso de teste devem ser feitas por meio de outros métodos. Por exemplo, a maioria das IUs da web tem autenticação (por exemplo, um formulário de login). Eliminar o login via navegador da web antes de cada teste irá melhorar a velocidade e estabilidade do teste. Um método deve ser criado para obter acesso à AUT* (por exemplo, usando uma API para fazer login e definir um cookie). Além disso, a criação de métodos para pré-carregar dados para o teste não deve ser feito usando Selenium. Como dito anteriormente, APIs existentes devem ser aproveitadas para criar dados para a AUT *.\n*AUT: Application under test\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/grid_3/","title":"Grid 3","tags":[],"description":"","content":"Grid 3 Selenium Grid é um servidor proxy inteligente que permite que os testes Selenium encaminhem comandos para instâncias remotas do navegador da web. Seu objetivo é fornecer uma maneira fácil de executar testes em paralelo em várias máquinas.\nCom Selenium Grid, um servidor atua como o hub que roteia comandos de teste formatados em JSON para um ou mais nós registrados. Os testes entram em contato com o hub para obter acesso a instâncias remotas do navegador. O hub tem uma lista de servidores registrados aos quais fornece acesso, e permite o controle dessas instâncias.\nSelenium Grid nos permite executar testes em paralelo em várias máquinas, e gerenciar diferentes versões e configurações do navegador centralmente (em vez de em cada teste individual).\nSelenium Grid não é uma bala de prata. Ele resolve um subconjunto de problemas comuns de delegação e distribuição, mas não irá, por exemplo, gerenciar sua infraestrutura, e pode não atender às suas necessidades específicas.\n** Observe que a Grid 3 não é mais compatível e o projeto Selenium recomenda usar [Grid 4] (/pt-br/grid/grid_4/)**\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/legacy_docs/html-runner/","title":"HTML runner","tags":[],"description":"","content":"Selenium HTML-runner permite que você execute suítes de teste da linha de comando. Suítes de teste são exportações de HTML do Selenium IDE ou ferramentas compatíveis.\nInformação comum  Combinação de lançamentos de geckodriver / firefox / selenium-html-runner são importantes. Pode haver um software matriz de compatibilidade em algum lugar. selenium-html-runner executa apenas suítes de teste (não casos de teste - por exemplo, uma exportação do Monitis Transaction Monitor). Certifique-se de cumprir isso. Para usuários Linux sem DISPLAY - você precisa iniciar o html-runner com display virtual (procure por xvfb)  Exemplo de ambiente Linux Instale / baixe os seguintes pacotes:\n[user@localhost ~]$ cat /etc/redhat-release CentOS Linux release 7.4.1708 (Core) [user@localhost ~]$ rpm -qa | egrep -i \u0026#34;xvfb|java-1.8|firefox\u0026#34; xorg-x11-server-Xvfb-1.19.3-11.el7.x86_64 firefox-52.4.0-1.el7.centos.x86_64 java-1.8.0-openjdk-1.8.0.151-1.b12.el7_4.x86_64 java-1.8.0-openjdk-headless-1.8.0.151-1.b12.el7_4.x86_64 Exemplo de suíte de testes:\n[user@localhost ~]$ cat testsuite.html \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD XHTML 1.0 Strict//EN\u0026#34; \u0026#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\u0026#34;\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34; xml:lang=\u0026#34;en\u0026#34; lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta content=\u0026#34;text/html; charset=UTF-8\u0026#34; http-equiv=\u0026#34;content-type\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Test Suite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table id=\u0026#34;suiteTable\u0026#34; cellpadding=\u0026#34;1\u0026#34; cellspacing=\u0026#34;1\u0026#34; border=\u0026#34;1\u0026#34; class=\u0026#34;selenium\u0026#34;\u0026gt;\u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;b\u0026gt;Test Suite\u0026lt;/b\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;YOUR-TEST-SCENARIO.html\u0026#34;\u0026gt;YOUR-TEST-SCENARIO\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Como rodar o selenium-html-runner headless Agora, a parte mais importante, um exemplo de como executar o selenium-html-runner! Sua experiência pode variar dependendo das combinações de software - versões geckodriver / FF / html-runner.\nxvfb-run java -Dwebdriver.gecko.driver=/home/mmasek/geckodriver.0.18.0 -jar selenium-html-runner-3.7.1.jar -htmlSuite \u0026#34;firefox\u0026#34; \u0026#34;https://YOUR-BASE-URL\u0026#34; \u0026#34;$(pwd)/testsuite.html\u0026#34; \u0026#34;results.html\u0026#34; ; grep result: -A1 results.html/firefox.results.html [user@localhost ~]$ xvfb-run java -Dwebdriver.gecko.driver=/home/mmasek/geckodriver.0.18.0 -jar selenium-html-runner-3.7.1.jar -htmlSuite \u0026#34;*firefox\u0026#34; \u0026#34;https://YOUR-BASE-URL\u0026#34; \u0026#34;$(pwd)/testsuite.html\u0026#34; \u0026#34;results.html\u0026#34; ; grep result: -A1 results.html/firefox.results.html Multi-window mode is longer used as an option and will be ignored. 1510061109691 geckodriver INFO geckodriver 0.18.0 1510061109708 geckodriver INFO Listening on 127.0.0.1:2885 1510061110162 geckodriver::marionette INFO Starting browser /usr/bin/firefox with args [\u0026#34;-marionette\u0026#34;] 1510061111084 Marionette INFO Listening on port 43229 1510061111187 Marionette WARN TLS certificate errors will be ignored for this session Nov 07, 2017 1:25:12 PM org.openqa.selenium.remote.ProtocolHandshake createSession INFO: Detected dialect: W3C 2017-11-07 13:25:12.714:INFO::main: Logging initialized @3915ms to org.seleniumhq.jetty9.util.log.StdErrLog 2017-11-07 13:25:12.804:INFO:osjs.Server:main: jetty-9.4.z-SNAPSHOT 2017-11-07 13:25:12.822:INFO:osjsh.ContextHandler:main: Started o.s.j.s.h.ContextHandler@87a85e1{/tests,null,AVAILABLE} 2017-11-07 13:25:12.843:INFO:osjs.AbstractConnector:main: Started ServerConnector@52102734{HTTP/1.1,[http/1.1]}{0.0.0.0:31892} 2017-11-07 13:25:12.843:INFO:osjs.Server:main: Started @4045ms Nov 07, 2017 1:25:13 PM org.openqa.selenium.server.htmlrunner.CoreTestCase run INFO: |open | /auth_mellon.php | | Nov 07, 2017 1:25:14 PM org.openqa.selenium.server.htmlrunner.CoreTestCase run INFO: |waitForPageToLoad | 3000 | | . . .etc \u0026lt;td\u0026gt;result:\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;PASS\u0026lt;/td\u0026gt; "},{"uri":"https://www.selenium.dev/documentation/pt-br/selenium_installation/installing_standalone_server/","title":"Instalando o servidor Standalone","tags":[],"description":"","content":"Se você planeja usar Grid, você deve baixar o arquivo selenium-server-standalone JAR. Todos os componentes estão disponíveis via selenium-server. O JAR Standalone contém tudo, incluindo o servidor Selenium remoto e as ligações do lado do cliente. Isso significa que se você usar o jar selenium-server-standalone em seu projeto, você não precisa adicionar selenium-java ou um jar específico do navegador.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-server\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; "},{"uri":"https://www.selenium.dev/documentation/pt-br/selenium_installation/","title":"Instalação do Selenium","tags":[],"description":"","content":"Instalação do Selenium A configuração do Selenium é bastante diferente da configuração de outras ferramentas comerciais. Para usar Selenium em seu projeto de automação, você precisa instalar as bibliotecas de linguagem para sua linguagem de escolha. Além disso, você precisará dos binários WebDriver para os navegadores que você deseja automatizar e executar testes.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/getting_started_with_webdriver/locating_elements/","title":"Localizando elementos","tags":[],"description":"","content":"Localizando elementos Uma das técnicas mais fundamentais para aprender ao usar o WebDriver é como encontrar elementos na página. WebDriver oferece uma série de tipos de seletores embutidos, entre eles encontrar um elemento por seu atributo de ID:\nJava Python C# Ruby JavaScript Kotlin WebElement cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;));   driver.find_element(By.ID, \u0026#34;cheese\u0026#34;)   IWebElement element = driver.FindElement(By.Id(\u0026#34;cheese\u0026#34;));   cheese = driver.find_element(id: \u0026#39;cheese\u0026#39;)   const cheese = driver.findElement(By.id(\u0026#39;cheese\u0026#39;));   val cheese: WebElement = driver.findElement(By.id(\u0026#34;cheese\u0026#34;))     Como visto no exemplo, a localização de elementos no WebDriver é feita no objeto da instância WebDriver. O método findElement(By) retorna outro tipo de objeto fundamental, o WebElement.\n WebDriver representa o navegador WebElement representa um nó DOM específico (um controle, por exemplo, um link ou input, etc.)  Depois de ter uma referência a um elemento da web que foi \u0026ldquo;encontrado\u0026rdquo;, você pode restringir o escopo de sua pesquisa usando a mesma chamada nessa instância do objeto:\nJava Python C# Ruby JavaScript Kotlin WebElement cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;)); WebElement cheddar = cheese.findElement(By.id(\u0026#34;cheddar\u0026#34;));   cheese = driver.find_element(By.ID, \u0026#34;cheese\u0026#34;) cheddar = cheese.find_elements_by_id(\u0026#34;cheddar\u0026#34;)   IWebElement cheese = driver.FindElement(By.Id(\u0026#34;cheese\u0026#34;)); IWebElement cheddar = cheese.FindElement(By.Id(\u0026#34;cheddar\u0026#34;));   cheese = driver.find_element(id: \u0026#39;cheese\u0026#39;) cheddar = cheese.find_element(id: \u0026#39;cheddar\u0026#39;)   const cheese = driver.findElement(By.id(\u0026#39;cheese\u0026#39;)); const cheddar = cheese.findElement(By.id(\u0026#39;cheddar\u0026#39;));   val cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;)) val cheddar = cheese.findElement(By.id(\u0026#34;cheddar\u0026#34;))     Você pode fazer isso porque ambos os tipos WebDriver e WebElement implementam a interface SearchContext. No WebDriver, isso é conhecido como interface baseada em função. As interfaces baseadas em funções permitem que você determine se uma implementação do driver suporta um determinado recurso. Essas interfaces são claramente definidas e tentam aderir a ter apenas uma única função de responsabilidade. Você pode ler mais sobre o design do WebDriver e quais funções são suportadas em quais drivers em Alguma outra seção que deve ser nomeada.\nConsequentemente, a interface By usada acima também suporta um número de estratégias de localização adicionais. Uma pesquisa aninhada pode não ser a estratégia de localização de cheese mais eficaz, pois requer dois comandos separados a serem emitidos para o navegador; primeiro pesquisando o DOM para um elemento com o ID \u0026ldquo;cheese\u0026rdquo;, em seguida, uma pesquisa por \u0026ldquo;cheddar\u0026rdquo; em um contexto restrito.\nPara melhorar um pouco o desempenho, devemos tentar usar um localizador mais específico: WebDriver suporta a procura de elementos por localizadores CSS, o que nos permite combinar os dois localizadores anteriores em uma única pesquisa:\nJava Python C# Ruby JavaScript Kotlin driver.findElement(By.cssSelector(\u0026#34;#cheese #cheddar\u0026#34;));   cheddar = driver.find_element_by_css_selector(\u0026#34;#cheese #cheddar\u0026#34;)   driver.FindElement(By.CssSelector(\u0026#34;#cheese #cheddar\u0026#34;));   driver.find_element(css: \u0026#39;#cheese #cheddar\u0026#39;)   const cheddar = driver.findElement(By.css(\u0026#39;#cheese #cheddar\u0026#39;));   driver.findElement(By.cssSelector(\u0026#34;#cheese #cheddar\u0026#34;))     Localizando mútliplos elementos É possível que o documento com o qual estamos trabalhando tenha uma lista ordenada dos queijos que mais gostamos:\n\u0026lt;ol id=cheese\u0026gt; \u0026lt;li id=cheddar\u0026gt;… \u0026lt;li id=brie\u0026gt;… \u0026lt;li id=rochefort\u0026gt;… \u0026lt;li id=camembert\u0026gt;… \u0026lt;/ol\u0026gt; Uma vez que mais queijo é indiscutivelmente melhor, e seria complicado ter que recuperar cada um dos itens individualmente, uma técnica melhor para buscar cheese é fazer uso da versão pluralizada findElements(By). Este método retorna uma coleção de elementos web. Se apenas um elemento for encontrado, ele ainda retornará uma coleção (de um elemento). Se nenhum elemento corresponder ao localizador, um lista vazia será retornada.\nJava Python C# Ruby JavaScript Kotlin List\u0026lt;WebElement\u0026gt; muchoCheese = driver.findElements(By.cssSelector(\u0026#34;#cheese li\u0026#34;));   mucho_cheese = driver.find_elements_by_css_selector(\u0026#34;#cheese li\u0026#34;)   IReadOnlyList\u0026lt;IWebElement\u0026gt; muchoCheese = driver.FindElements(By.CssSelector(\u0026#34;#cheese li\u0026#34;));   mucho_cheese = driver.find_elements(css: \u0026#39;#cheese li\u0026#39;)   const muchoCheese = driver.findElements(By.css(\u0026#39;#cheese li\u0026#39;));   val muchoCheese: List\u0026lt;WebElement\u0026gt; = driver.findElements(By.cssSelector(\u0026#34;#cheese li\u0026#34;))     Estratégias de seleção de elemento Existem oito estratégias diferentes de localização de elementos embutidas no WebDriver:\n   Localizador Descrição     class name Localiza elementos cujo nome de classe contém o valor de pesquisa (nomes de classes compostas não são permitidos)   css selector Localiza elementos que correspondem a um seletor CSS   id Localiza elementos cujo atributo de ID corresponde ao valor de pesquisa   name Localiza elementos cujo atributo NAME corresponde ao valor de pesquisa   link text Localiza elementos âncora cujo texto visível corresponde ao valor de pesquisa   partial link text Localiza elementos âncora cujo texto visível contém o valor da pesquisa. Se vários elementos forem correspondentes, apenas o primeiro será selecionado.   tag name Localiza elementos cujo nome de tag corresponde ao valor de pesquisa   xpath Localiza elementos que correspondem a uma expressão XPath    Dicas sobre como usar seletores No geral, se os IDs de HTML estiverem disponíveis, únicos e consistentemente previsíveis, eles são o método preferido para localizar um elemento uma página. Eles tendem a trabalhar muito rapidamente e dispensar muito processamento que vem com travessias de DOM complicadas.\nSe IDs exclusivos não estiverem disponíveis, um seletor CSS bem escrito é o método preferido de localização de um elemento. XPath funciona bem como CSS seletores, mas a sintaxe é complicada e frequentemente difícil de depurar. Embora os seletores XPath sejam muito flexíveis, eles não são tipicamente testados em performance por fornecedores de navegadores e tendem a ser bastante lentos.\nAs estratégias de seleção baseadas em linkText e partialLinkText têm desvantagens porque eles só funcionam em elementos de link. Além disso, eles chamam seletores XPath internamente no WebDriver.\nO nome da tag pode ser uma maneira perigosa de localizar elementos. tem frequentemente, vários elementos da mesma tag presentes na página. Isso é útil principalmente ao chamar o método _findElements(By) _ que retorna uma coleção de elementos.\nA recomendação é manter seus localizadores compactos e legíveis quanto possível. Pedir ao WebDriver para percorrer a estrutura DOM é uma operação cara, e quanto mais você pode restringir o escopo de sua pesquisa, melhor.\nLocalizadores relativos Selenium 4 traz localizadores relativos que eram anteriormente chamado de Localizadores Amigáveis. Esta funcionalidade foi adicionada para ajudá-lo a localizar elementos que estão próximos a outros elementos. Os localizadores relativos disponíveis são:\n above below toLeftOf toRightOf near  O método findElement agora aceita um novo método withTagName() que retorna um RelativeLocator.\nComo funciona Selenium usa a função JavaScript getBoundingClientRect() para encontrar os elementos relativos. Esta função retorna propriedades de um elemento, como right, left, bottom, and top.\nVamos considerar o exemplo abaixo para entender os localizadores relativos.\nabove() Retorna o WebElement, que aparece acima do elemento especificado\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement passwordField = driver.findElement(By.id(\u0026#34;password\u0026#34;)); WebElement emailAddressField = driver.findElement(withTagName(\u0026#34;input\u0026#34;) .above(passwordField));   #from selenium.webdriver.support.relative_locator import with_tag_name passwordField = driver.find_element(By.ID, \u0026#34;password\u0026#34;) emailAddressField = driver.find_element(with_tag_name(\u0026#34;input\u0026#34;).above(passwordField))   //using static OpenQA.Selenium.RelativeBy; IWebElement passwordField = driver.FindElement(By.Id(\u0026#34;password\u0026#34;)); IWebElement emailAddressField = driver.FindElement(WithTagName(\u0026#34;input\u0026#34;) .Above(passwordField));   password_field = driver.find_element(:id, \u0026#34;password\u0026#34;) email_address_field = driver.find_element(relative: {tag_name: \u0026#39;input\u0026#39;, above:password_field})   let passwordField = driver.findElement(By.id(\u0026#39;password\u0026#39;)); let emailAddressField = await driver.findElements(withTagName(\u0026#39;input\u0026#39;).above(passwordField));   val passwordField = driver.findElement(By.id(\u0026#34;password\u0026#34;)) val emailAddressField = driver.findElement(withTagName(\u0026#34;input\u0026#34;).above(passwordField))     below() Retorna o WebElement, que aparece abaixo do elemento especificado\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement emailAddressField = driver.findElement(By.id(\u0026#34;email\u0026#34;)); WebElement passwordField = driver.findElement(withTagName(\u0026#34;input\u0026#34;) .below(emailAddressField));   #from selenium.webdriver.support.relative_locator import with_tag_name emailAddressField = driver.find_element(By.ID, \u0026#34;email\u0026#34;) passwordField = driver.find_element(with_tag_name(\u0026#34;input\u0026#34;).below(emailAddressField))   //using static OpenQA.Selenium.RelativeBy; IWebElement emailAddressField = driver.FindElement(By.Id(\u0026#34;email\u0026#34;)); IWebElement passwordField = driver.FindElement(WithTagName(\u0026#34;input\u0026#34;) .Below(emailAddressField));   email_address_field = driver.find_element(:id, \u0026#34;email\u0026#34;) password_field = driver.find_element(relative: {tag_name: \u0026#39;input\u0026#39;, below: email_address_field})   let emailAddressField = driver.findElement(By.id(\u0026#39;email\u0026#39;)); let passwordField = await driver.findElements(withTagName(\u0026#39;input\u0026#39;).below(emailAddressField));   val emailAddressField = driver.findElement(By.id(\u0026#34;email\u0026#34;)) val passwordField = driver.findElement(withTagName(\u0026#34;input\u0026#34;).below(emailAddressField))     toLeftOf() Retorna o WebElement, que aparece à esquerda do elemento especificado\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement submitButton = driver.findElement(By.id(\u0026#34;submit\u0026#34;)); WebElement cancelButton = driver.findElement(withTagName(\u0026#34;button\u0026#34;) .toLeftOf(submitButton));   #from selenium.webdriver.support.relative_locator import with_tag_name submitButton = driver.find_element(By.ID, \u0026#34;submit\u0026#34;) cancelButton = driver.find_element(with_tag_name(\u0026#34;button\u0026#34;). to_left_of(submitButton))   //using static OpenQA.Selenium.RelativeBy; IWebElement submitButton = driver.FindElement(By.Id(\u0026#34;submit\u0026#34;)); IWebElement cancelButton = driver.FindElement(WithTagName(\u0026#34;button\u0026#34;) .LeftOf(submitButton));   submit_button = driver.find_element(:id, \u0026#34;submit\u0026#34;) cancel_button = driver.find_element(relative: {tag_name: \u0026#39;button\u0026#39;, left:submit_button})   let submitButton = driver.findElement(By.id(\u0026#34;submit\u0026#34;)); let cancelButton = await driver.findElements(withTagName(\u0026#34;button\u0026#34;).toLeftOf(submitButton));   val submitButton = driver.findElement(By.id(\u0026#34;submit\u0026#34;)) val cancelButton = driver.findElement(withTagName(\u0026#34;button\u0026#34;).toLeftOf(submitButton))     toRightOf() Retorna o WebElement, que aparece à direita do elemento especificado\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement cancelButton = driver.findElement(By.id(\u0026#34;cancel\u0026#34;)); WebElement submitButton = driver.findElement(withTagName(\u0026#34;button\u0026#34;) .toRightOf(cancelButton));   #from selenium.webdriver.support.relative_locator import with_tag_name cancelButton = driver.find_element(By.ID, \u0026#34;cancel\u0026#34;) submitButton = driver.find_element(with_tag_name(\u0026#34;button\u0026#34;). to_right_of(cancelButton))   //using static OpenQA.Selenium.RelativeBy; IWebElement cancelButton = driver.FindElement(By.Id(\u0026#34;cancel\u0026#34;)); IWebElement submitButton = driver.FindElement(WithTagName(\u0026#34;button\u0026#34;) .RightOf(cancelButton));   cancel_button = driver.find_element(:id, \u0026#34;cancel\u0026#34;) submit_button = driver.find_element(relative: {tag_name: \u0026#39;button\u0026#39;, right:cancel_button})   let cancelButton = driver.findElement(By.id(\u0026#39;cancel\u0026#39;)); let submitButton = await driver.findElements(withTagName(\u0026#39;button\u0026#39;).toRightOf(cancelButton));   val cancelButton = driver.findElement(By.id(\u0026#34;cancel\u0026#34;)) val submitButton = driver.findElement(withTagName(\u0026#34;button\u0026#34;).toRightOf(cancelButton))     near() Retorna o WebElement, que está no máximo a 50px de distância do elemento especificado.\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement emailAddressLabel = driver.findElement(By.id(\u0026#34;lbl-email\u0026#34;)); WebElement emailAddressField = driver.findElement(withTagName(\u0026#34;input\u0026#34;) .near(emailAddressLabel));   #from selenium.webdriver.support.relative_locator import with_tag_name emailAddressLabel = driver.find_element(By.ID, \u0026#34;lbl-email\u0026#34;) emailAddressField = driver.find_element(with_tag_name(\u0026#34;input\u0026#34;). near(emailAddressLabel))   //using static OpenQA.Selenium.RelativeBy; IWebElement emailAddressLabel = driver.FindElement(By.Id(\u0026#34;lbl-email\u0026#34;)); IWebElement emailAddressField = driver.FindElement(WithTagName(\u0026#34;input\u0026#34;) .Near(emailAddressLabel));   email_address_label = driver.find_element(:id, \u0026#34;lbl-email\u0026#34;) email_address_field = driver.find_element(relative: {tag_name: \u0026#39;input\u0026#39;, near: email_address_label})   let emailAddressLabel = driver.findElement(By.id(\u0026#34;lbl-email\u0026#34;)); let emailAddressField = await driver.findElements(withTagName(\u0026#34;input\u0026#34;).near(emailAddressLabel));   val emailAddressLabel = driver.findElement(By.id(\u0026#34;lbl-email\u0026#34;)) val emailAddressField = driver.findElement(withTagName(\u0026#34;input\u0026#34;).near(emailAddressLabel))     "},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/browser_manipulation/","title":"Manipulação do Browser","tags":[],"description":"","content":"Page being translated from English to Brazilian Portuguese. Do you speak Brazilian Portuguese? Help us to translate it by sending us pull requests!\n Ruby Ruby is not installed by default on Windows. Download the latest version and run the installer. You can leave all settings at default values, except at the Installation Destination and Optional Tasks screen check where you need to check the Add Ruby executables to your PATH checkbox. To drive any browser, you have to install selenium-webdriver Ruby gem. To install it, open command prompt and type this:\ngem install selenium-webdriver Or, if you use Bundler, add this line to your application\u0026rsquo;s Gemfile:\ngem \u0026#34;selenium-webdriver\u0026#34; And then execute the following command in command prompt:\nbundle install Internet Explorer Internet Explorer is installed by default on Windows, so no installation is needed. To drive Internet Explorer on Windows, you have to download the latest Internet Explorer Driver and put the file into a folder that is in PATH. To find out which directories are in PATH, type echo %PATH% in command prompt.\n$ echo %PATH% C:\\Ruby200\\bin;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem C:\\Ruby200\\bin looks like a good place. Unzip IEDriverServer file and move IEDriverServer.exe there.\nThis should open a new Internet Explorer window:\nrequire \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer Browser navigation Navigate to The first thing you will want to do after launching a browser is to open your website. This can be achieved in a single line:\nJava Python C# Ruby JavaScript Kotlin //Convenient driver.get(\u0026#34;https://selenium.dev\u0026#34;); //Longer way driver.navigate().to(\u0026#34;https://selenium.dev\u0026#34;);   driver.get(\u0026#34;https://selenium.dev\u0026#34;)   driver.Navigate().GoToUrl(@\u0026#34;https://selenium.dev\u0026#34;);   # Convenient way driver.get \u0026#39;https://selenium.dev\u0026#39; # Longer Way driver.navigate.to \u0026#39;https://selenium.dev\u0026#39;   await driver.get(\u0026#39;https://selenium.dev\u0026#39;);   //Convenient driver.get(\u0026#34;https://selenium.dev\u0026#34;) //Longer way driver.navigate().to(\u0026#34;https://selenium.dev\u0026#34;)     Get current URL You can read the current URL from the browser\u0026rsquo;s address bar using:\nJava Python C# Ruby JavaScript Kotlin driver.getCurrentUrl();  driver.current_url  driver.Url;   driver.current_url  await driver.getCurrentUrl();   driver.currentUrl    Back Pressing the browser\u0026rsquo;s back button:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().back();  driver.back()  driver.Navigate().Back();   driver.navigate.back  await driver.navigate().back();   driver.navigate().back()     Forward Pressing the browser\u0026rsquo;s forward button:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().forward();  driver.forward()  driver.Navigate().Forward();   driver.navigate.forward  await driver.navigate().forward();   driver.navigate().forward()    Refresh Refresh the current page:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().refresh();  driver.refresh()  driver.Navigate().Refresh();   driver.navigate.refresh  await driver.navigate().refresh();   driver.navigate().refresh()    Get title You can read the current page title from the browser:\nJava Python C# Ruby JavaScript Kotlin driver.getTitle();  driver.title  driver.Title;   driver.title  await driver.getTitle();   driver.title    Windows and tabs Get window handle WebDriver does not make the distinction between windows and tabs. If your site opens a new tab or window, Selenium will let you work with it using a window handle. Each window has a unique identifier which remains persistent in a single session. You can get the window handle of the current window by using:\nJava Python C# Ruby JavaScript Kotlin driver.getWindowHandle();  driver.current_window_handle  driver.CurrentWindowHandle;   driver.window_handle  await driver.getWindowHandle();   driver.windowHandle    Switching windows or tabs Clicking a link which opens in a new windowwill focus the new window or tab on screen, but WebDriver will not know which window the Operating System considers active. To work with the new window you will need to switch to it. If you have only two tabs or windows open, and you know which window you start with, by the process of elimination you can loop over both windows or tabs that WebDriver can see, and switch to the one which is not the original.\nHowever, Selenium 4 provides a new api NewWindow which creates a new tab (or) new window and automatically switches to it.\nJava Python C# Ruby JavaScript Kotlin //Store the ID of the original window String originalWindow = driver.getWindowHandle(); //Check we don\u0026#39;t have other windows open already assert driver.getWindowHandles().size() == 1; //Click the link which opens in a new window driver.findElement(By.linkText(\u0026#34;new window\u0026#34;)).click(); //Wait for the new window or tab wait.until(numberOfWindowsToBe(2)); //Loop through until we find a new window handle for (String windowHandle : driver.getWindowHandles()) { if(!originalWindow.contentEquals(windowHandle)) { driver.switchTo().window(windowHandle); break; } } //Wait for the new tab to finish loading content wait.until(titleIs(\u0026#34;Selenium documentation\u0026#34;));   from selenium import webdriver from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC # Start the driver with webdriver.Firefox() as driver: # Open URL driver.get(\u0026#34;https://seleniumhq.github.io\u0026#34;) # Setup wait for later wait = WebDriverWait(driver, 10) # Store the ID of the original window original_window = driver.current_window_handle # Check we don\u0026#39;t have other windows open already assert len(driver.window_handles) == 1 # Click the link which opens in a new window driver.find_element(By.LINK_TEXT, \u0026#34;new window\u0026#34;).click() # Wait for the new window or tab wait.until(EC.number_of_windows_to_be(2)) # Loop through until we find a new window handle for window_handle in driver.window_handles: if window_handle != original_window: driver.switch_to.window(window_handle) break # Wait for the new tab to finish loading content wait.until(EC.title_is(\u0026#34;SeleniumHQ Browser Automation\u0026#34;))   //Store the ID of the original window string originalWindow = driver.CurrentWindowHandle; //Check we don\u0026#39;t have other windows open already Assert.AreEqual(driver.WindowHandles.Count, 1); //Click the link which opens in a new window driver.FindElement(By.LinkText(\u0026#34;new window\u0026#34;)).Click(); //Wait for the new window or tab wait.Until(wd =\u0026gt; wd.WindowHandles.Count == 2); //Loop through until we find a new window handle foreach(string window in driver.WindowHandles) { if(originalWindow != window) { driver.SwitchTo().Window(window); break; } } //Wait for the new tab to finish loading content wait.Until(wd =\u0026gt; wd.Title == \u0026#34;Selenium documentation\u0026#34;);   #Store the ID of the original window original_window = driver.window_handle #Check we don\u0026#39;t have other windows open already assert(driver.window_handles.length == 1, \u0026#39;Expected one window\u0026#39;) #Click the link which opens in a new window driver.find_element(link: \u0026#39;new window\u0026#39;).click #Wait for the new window or tab wait.until { driver.window_handles.length == 2 } #Loop through until we find a new window handle driver.window_handles.each do |handle| if handle != original_window driver.switch_to.window handle break end end #Wait for the new tab to finish loading content wait.until { driver.title == \u0026#39;Selenium documentation\u0026#39;}   //Store the ID of the original window const originalWindow = await driver.getWindowHandle(); //Check we don\u0026#39;t have other windows open already assert((await driver.getAllWindowHandles()).length === 1); //Click the link which opens in a new window await driver.findElement(By.linkText(\u0026#39;new window\u0026#39;)).click(); //Wait for the new window or tab await driver.wait( async () =\u0026gt; (await driver.getAllWindowHandles()).length === 2, 10000 ); //Loop through until we find a new window handle const windows = await driver.getAllWindowHandles(); windows.forEach(async handle =\u0026gt; { if (handle !== originalWindow) { await driver.switchTo().window(handle); } }); //Wait for the new tab to finish loading content await driver.wait(until.titleIs(\u0026#39;Selenium documentation\u0026#39;), 10000);   //Store the ID of the original window val originalWindow = driver.getWindowHandle() //Check we don\u0026#39;t have other windows open already assert(driver.getWindowHandles().size() === 1) //Click the link which opens in a new window driver.findElement(By.linkText(\u0026#34;new window\u0026#34;)).click() //Wait for the new window or tab wait.until(numberOfWindowsToBe(2)) //Loop through until we find a new window handle for (windowHandle in driver.getWindowHandles()) { if (!originalWindow.contentEquals(windowHandle)) { driver.switchTo().window(windowHandle) break } } //Wait for the new tab to finish loading content wait.until(titleIs(\u0026#34;Selenium documentation\u0026#34;))     Create new window (or) new tab and switch Creates a new window (or) tab and will focus the new window or tab on screen. You don\u0026rsquo;t need to switch to work with the new window (or) tab. If you have more than two windows (or) tabs opened other than the new window, you can loop over both windows or tabs that WebDriver can see, and switch to the one which is not the original.\nNote: This feature works with Selenium 4 and later versions.\nJava Python C# Ruby JavaScript Kotlin // Opens a new tab and switches to new tab driver.switchTo().newWindow(WindowType.TAB); // Opens a new window and switches to new window driver.switchTo().newWindow(WindowType.WINDOW);   # Opens a new tab and switches to new tab driver.switch_to.new_window(\u0026#39;tab\u0026#39;) # Opens a new window and switches to new window driver.switch_to.new_window(\u0026#39;window\u0026#39;)   // Opens a new tab and switches to new tab driver.SwitchTo().NewWindow(WindowType.Tab) // Opens a new window and switches to new window driver.SwitchTo().NewWindow(WindowType.Window)   # Note: The new_window in ruby only opens a new tab (or) Window and will not switch automatically # The user has to switch to new tab (or) new window # Opens a new tab and switches to new tab driver.manage.new_window(:tab) # Opens a new window and switches to new window driver.manage.new_window(:window)   // Opens a new tab and switches to new tab await driver.switchTo().newWindow(\u0026#39;tab\u0026#39;); // Opens a new window and switches to new window await driver.switchTo().newWindow(\u0026#39;window\u0026#39;);   // Opens a new tab and switches to new tab driver.switchTo().newWindow(WindowType.TAB) // Opens a new window and switches to new window driver.switchTo().newWindow(WindowType.WINDOW)     Closing a window or tab When you are finished with a window or tab and it is not the last window or tab open in your browser, you should close it and switch back to the window you were using previously. Assuming you followed the code sample in the previous section you will have the previous window handle stored in a variable. Put this together and you will get:\nJava Python C# Ruby JavaScript Kotlin //Close the tab or window driver.close(); //Switch back to the old tab or window driver.switchTo().window(originalWindow);   #Close the tab or window driver.close() #Switch back to the old tab or window driver.switch_to.window(original_window)   //Close the tab or window driver.Close(); //Switch back to the old tab or window driver.SwitchTo().Window(originalWindow);   #Close the tab or window driver.close #Switch back to the old tab or window driver.switch_to.window original_window   //Close the tab or window await driver.close(); //Switch back to the old tab or window await driver.switchTo().window(originalWindow);   //Close the tab or window driver.close() //Switch back to the old tab or window driver.switchTo().window(originalWindow)     Forgetting to switch back to another window handle after closing a window will leave WebDriver executing on the now closed page, and will trigger a No Such Window Exception. You must switch back to a valid window handle in order to continue execution.\nQuitting the browser at the end of a session When you are finished with the browser session you should call quit, instead of close:\nJava Python C# Ruby JavaScript Kotlin driver.quit();  driver.quit()  driver.Quit();   driver.quit  await driver.quit();   driver.quit()     Quit will:  Close all the windows and tabs associated with that WebDriver session Close the browser process Close the background driver process Notify Selenium Grid that the browser is no longer in use so it can be used by another session (if you are using Selenium Grid)    Failure to call quit will leave extra background processes and ports running on your machine which could cause you problems later.\nSome test frameworks offer methods and annotations which you can hook into to tear down at the end of a test.\nJava Python C# Ruby JavaScript Kotlin /** * Example using JUnit * https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterAll.html */ @AfterAll public static void tearDown() { driver.quit(); }   # unittest teardown # https://docs.python.org/3/library/unittest.html?highlight=teardown#unittest.TestCase.tearDown def tearDown(self): self.driver.quit()   /* Example using Visual Studio\u0026#39;s UnitTesting https://msdn.microsoft.com/en-us/library/microsoft.visualstudio.testtools.unittesting.aspx */ [TestCleanup] public void TearDown() { driver.Quit(); }   # UnitTest Teardown # https://www.rubydoc.info/github/test-unit/test-unit/Test/Unit/TestCase def teardown @driver.quit end   /** * Example using Mocha * https://mochajs.org/#hooks */ after(\u0026#39;Tear down\u0026#39;, async function () { await driver.quit(); });   /** * Example using JUnit * https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterAll.html */ @AfterAll fun tearDown() { driver.quit() }     If not running WebDriver in a test context, you may consider using try / finally which is offered by most languages so that an exception will still clean up the WebDriver session.\nJava Python C# Ruby JavaScript Kotlin try { //WebDriver code here... } finally { driver.quit(); }   try: #WebDriver code here... finally: driver.quit()   try { //WebDriver code here... } finally { driver.Quit(); }   begin #WebDriver code here... ensure driver.quit end   try { //WebDriver code here... } finally { await driver.quit(); }   try { //WebDriver code here... } finally { driver.quit() }     Python\u0026rsquo;s WebDriver now supports the python context manager, which when using the with keyword can automatically quit the driver at the end of execution.\nwith webdriver.Firefox() as driver: # WebDriver code here... # WebDriver will automatically quit after indentation Frames and Iframes Frames are a now deprecated means of building a site layout from multiple documents on the same domain. You are unlikely to work with them unless you are working with an pre HTML5 webapp. Iframes allow the insertion of a document from an entirely different domain, and are still commonly used.\nIf you need to work with frames or iframes, WebDriver allows you to work with them in the same way. Consider a button within an iframe. If we inspect the element using the browser development tools, we might see the following:\n\u0026lt;div id=\u0026#34;modal\u0026#34;\u0026gt; \u0026lt;iframe id=\u0026#34;buttonframe\u0026#34; name=\u0026#34;myframe\u0026#34; src=\u0026#34;https://seleniumhq.github.io\u0026#34;\u0026gt; \u0026lt;button\u0026gt;Click here\u0026lt;/button\u0026gt; \u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; If it was not for the iframe we would expect to click on the button using something like:\nJava Python C# Ruby JavaScript Kotlin //This won\u0026#39;t work driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # This Wont work driver.find_element(By.TAG_NAME, \u0026#39;button\u0026#39;).click()   //This won\u0026#39;t work driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # This won\u0026#39;t work driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // This won\u0026#39;t work await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //This won\u0026#39;t work driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     However, if there are no buttons outside of the iframe, you might instead get a no such element error. This happens because Selenium is only aware of the elements in the top level document. To interact with the button, we will need to first switch to the frame, in a similar way to how we switch windows. WebDriver offers three ways of switching to a frame.\nUsing a WebElement Switching using a WebElement is the most flexible option. You can find the frame using your preferred selector and switch to it.\nJava Python C# Ruby JavaScript Kotlin //Store the web element WebElement iframe = driver.findElement(By.cssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); //Switch to the frame driver.switchTo().frame(iframe); //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # Store iframe web element iframe = driver.find_element(By.CSS_SELECTOR, \u0026#34;#modal \u0026gt; iframe\u0026#34;) # switch to selected iframe driver.switch_to.frame(iframe) # Now click on button driver.find_element(By.TAG_NAME, \u0026#39;button\u0026#39;).click()   //Store the web element IWebElement iframe = driver.FindElement(By.CssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); //Switch to the frame driver.SwitchTo().Frame(iframe); //Now we can click the button driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # Store iframe web element iframe = driver.find_element(:css,\u0026#39;#modal \u0026gt; iframe\u0026#39;) # Switch to the frame driver.switch_to.frame iframe # Now, Click on the button driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // Store the web element const iframe = driver.findElement(By.css(\u0026#39;#modal \u0026gt; iframe\u0026#39;)); // Switch to the frame await driver.switchTo().frame(iframe); // Now we can click the button await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //Store the web element val iframe = driver.findElement(By.cssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)) //Switch to the frame driver.switchTo().frame(iframe) //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     Using a name or ID If your frame or iframe has an id or name attribute, this can be used instead. If the name or ID is not unique on the page, then the first one found will be switched to.\nJava Python C# Ruby JavaScript Kotlin //Using the ID driver.switchTo().frame(\u0026#34;buttonframe\u0026#34;); //Or using the name instead driver.switchTo().frame(\u0026#34;myframe\u0026#34;); //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # Switch frame by id driver.switch_to.frame(\u0026#39;buttonframe\u0026#39;) # Now, Click on the button driver.find_element(By.TAG_NAME, \u0026#39;button\u0026#39;).click()   //Using the ID driver.SwitchTo().Frame(\u0026#34;buttonframe\u0026#34;); //Or using the name instead driver.SwitchTo().Frame(\u0026#34;myframe\u0026#34;); //Now we can click the button driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # Switch by ID driver.switch_to.frame \u0026#39;buttonframe\u0026#39; # Now, Click on the button driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // Using the ID await driver.switchTo().frame(\u0026#39;buttonframe\u0026#39;); // Or using the name instead await driver.switchTo().frame(\u0026#39;myframe\u0026#39;); // Now we can click the button await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //Using the ID driver.switchTo().frame(\u0026#34;buttonframe\u0026#34;) //Or using the name instead driver.switchTo().frame(\u0026#34;myframe\u0026#34;) //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     Using an index It is also possible to use the index of the frame, such as can be queried using window.frames in JavaScript.\nJava Python C# Ruby JavaScript Kotlin // Switches to the second frame driver.switchTo().frame(1);   # Switch to the second frame driver.switch_to.frame(1)   // Switches to the second frame driver.SwitchTo().Frame(1);   # switching to second iframe based on index iframe = driver.find_elements_by_tag_name(\u0026#39;iframe\u0026#39;)[1] # switch to selected iframe driver.switch_to.frame(iframe)   // Switches to the second frame await driver.switchTo().frame(1);   // Switches to the second frame driver.switchTo().frame(1)     Leaving a frame To leave an iframe or frameset, switch back to the default content like so:\nJava Python C# Ruby JavaScript Kotlin // Return to the top level driver.switchTo().defaultContent();   # switch back to default content driver.switch_to.default_content()   // Return to the top level driver.SwitchTo().DefaultContent();   # Return to the top level driver.switch_to.default_content   // Return to the top level await driver.switchTo().defaultContent();   // Return to the top level driver.switchTo().defaultContent()     Window management Screen resolution can impact how your web application renders, so WebDriver provides mechanisms for moving and resizing the browser window.\nGet window size Fetches the size of the browser window in pixels.\nJava Python C# Ruby JavaScript Kotlin //Access each dimension individually int width = driver.manage().window().getSize().getWidth(); int height = driver.manage().window().getSize().getHeight(); //Or store the dimensions and query them later Dimension size = driver.manage().window().getSize(); int width1 = size.getWidth(); int height1 = size.getHeight();   # Access each dimension individually width = driver.get_window_size().get(\u0026#34;width\u0026#34;) height = driver.get_window_size().get(\u0026#34;height\u0026#34;) # Or store the dimensions and query them later size = driver.get_window_size() width1 = size.get(\u0026#34;width\u0026#34;) height1 = size.get(\u0026#34;height\u0026#34;)   //Access each dimension individually int width = driver.Manage().Window.Size.Width; int height = driver.Manage().Window.Size.Height; //Or store the dimensions and query them later System.Drawing.Size size = driver.Manage().Window.Size; int width1 = size.Width; int height1 = size.Height;   # Access each dimension individually width = driver.manage.window.size.width height = driver.manage.window.size.height # Or store the dimensions and query them later size = driver.manage.window.size width1 = size.width height1 = size.height   // Access each dimension individually const { width, height } = await driver.manage().window().getRect(); // Or store the dimensions and query them later const rect = await driver.manage().window().getRect(); const width1 = rect.width; const height1 = rect.height;   //Access each dimension individually val width = driver.manage().window().size.width val height = driver.manage().window().size.height //Or store the dimensions and query them later val size = driver.manage().window().size val width1 = size.width val height1 = size.height     Set window size Restores the window and sets the window size. Java Python C# Ruby JavaScript Kotlin driver.manage().window().setSize(new Dimension(1024, 768));  driver.set_window_size(1024, 768)  driver.Manage().Window.Size = new Size(1024, 768);   driver.manage.window.resize_to(1024,768)  await driver.manage().window().setRect({ width: 1024, height: 768 });   driver.manage().window().size = Dimension(1024, 768)   \nGet window position Fetches the coordinates of the top left coordinate of the browser window.\nJava Python C# Ruby JavaScript Kotlin // Access each dimension individually int x = driver.manage().window().getPosition().getX(); int y = driver.manage().window().getPosition().getY(); // Or store the dimensions and query them later Point position = driver.manage().window().getPosition(); int x1 = position.getX(); int y1 = position.getY();   # Access each dimension individually x = driver.get_window_position().get(\u0026#39;x\u0026#39;) y = driver.get_window_position().get(\u0026#39;y\u0026#39;) # Or store the dimensions and query them later position = driver.get_window_position() x1 = position.get(\u0026#39;x\u0026#39;) y1 = position.get(\u0026#39;y\u0026#39;)   //Access each dimension individually int x = driver.Manage().Window.Position.X; int y = driver.Manage().Window.Position.Y; //Or store the dimensions and query them later Point position = driver.Manage().Window.Position; int x1 = position.X; int y1 = position.Y;   #Access each dimension individually x = driver.manage.window.position.x y = driver.manage.window.position.y # Or store the dimensions and query them later rect = driver.manage.window.rect x1 = rect.x y1 = rect.y   // Access each dimension individually const { x, y } = await driver.manage().window().getRect(); // Or store the dimensions and query them later const rect = await driver.manage().window().getRect(); const x1 = rect.x; const y1 = rect.y;   // Access each dimension individually val x = driver.manage().window().position.x val y = driver.manage().window().position.y // Or store the dimensions and query them later val position = driver.manage().window().position val x1 = position.x val y1 = position.y     Set window position Moves the window to the chosen position.\nJava Python C# Ruby JavaScript Kotlin // Move the window to the top left of the primary monitor driver.manage().window().setPosition(new Point(0, 0));   # Move the window to the top left of the primary monitor driver.set_window_position(0, 0)   // Move the window to the top left of the primary monitor driver.Manage().Window.Position = new Point(0, 0);   driver.manage.window.move_to(0,0)   // Move the window to the top left of the primary monitor await driver.manage().window().setRect({ x: 0, y: 0 });   // Move the window to the top left of the primary monitor driver.manage().window().position = Point(0,0)     Maximize window Enlarges the window. For most operating systems, the window will fill the screen, without blocking the operating system\u0026rsquo;s own menus and toolbars.\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().maximize();  driver.maximize_window()  driver.Manage().Window.Maximize();   driver.manage.window.maximize  await driver.manage().window().maximize();   driver.manage().window().maximize()    Minimize window Minimizes the window of current browsing context. The exact behavior of this command is specific to individual window managers.\nMinimize Window typically hides the window in the system tray.\nNote: This feature works with Selenium 4 and later versions.\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().minimize();  driver.minimize_window()  driver.Manage().Window.Minimize();   driver.manage.window.minimize  await driver.manage().window().minimize();   driver.manage().window().minimize()    Fullscreen window Fills the entire screen, similar to pressing F11 in most browsers.\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().fullscreen();  driver.fullscreen_window()  driver.Manage().Window.FullScreen();   driver.manage.window.full_screen  await driver.manage().window().fullscreen();   driver.manage().window().fullscreen()    TakeScreenshot Used to capture screenshot for current browsing context. The WebDriver endpoint screenshot returns screenshot which is encoded in Base64 format.\nJava Python C# Ruby JavaScript Kotlin import org.apache.commons.io.FileUtils; import org.openqa.selenium.chrome.ChromeDriver; import java.io.*; import org.openqa.selenium.*; public class SeleniumTakeScreenshot { public static void main(String args[]) throws IOException { WebDriver driver = new ChromeDriver(); driver.get(\u0026#34;http://www.example.com\u0026#34;); File scrFile = ((TakesScreenshot)driver).getScreenshotAs(OutputType.FILE); FileUtils.copyFile(scrFile, new File(\u0026#34;./image.png\u0026#34;)); driver.quit(); } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) # Returns and base64 encoded string into image driver.save_screenshot(\u0026#39;./image.png\u0026#39;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Support.UI; var driver = new ChromeDriver(); driver.Navigate().GoToUrl(\u0026#34;http://www.example.com\u0026#34;); Screenshot screenshot = (driver as ITakesScreenshot).GetScreenshot(); screenshot.SaveAsFile(\u0026#34;screenshot.png\u0026#34;, ScreenshotImageFormat.Png); // Format values are Bmp, Gif, Jpeg, Png, Tiff    require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://example.com/\u0026#39; # Takes and Stores the screenshot in specified path driver.save_screenshot(\u0026#39;./image.png\u0026#39;) end   let {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); let fs = require(\u0026#39;fs\u0026#39;); (async function example() { let driver = await new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Returns base64 encoded string  let encodedString = driver.takeScreenshot(); await fs.writeFileSync(\u0026#39;./image.png\u0026#39;, encodedString, \u0026#39;base64\u0026#39;); await driver.quit(); }())   import com.oracle.tools.packager.IOUtils.copyFile import org.openqa.selenium.* import org.openqa.selenium.chrome.ChromeDriver import java.io.File fun main(){ val driver = ChromeDriver() driver.get(\u0026#34;https://www.example.com\u0026#34;) val scrFile = (driver as TakesScreenshot).getScreenshotAs\u0026lt;File\u0026gt;(OutputType.FILE) copyFile(scrFile, File(\u0026#34;./image.png\u0026#34;)) driver.quit() }     TakeElementScreenshot Used to capture screenshot of an element for current browsing context. The WebDriver endpoint screenshot returns screenshot which is encoded in Base64 format.\nJava Python C# Ruby JavaScript Kotlin import org.apache.commons.io.FileUtils; import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; import java.io.File; import java.io.IOException; public class SeleniumelementTakeScreenshot { public static void main(String args[]) throws IOException { WebDriver driver = new ChromeDriver(); driver.get(\u0026#34;https://www.example.com\u0026#34;); WebElement element = driver.findElement(By.cssSelector(\u0026#34;h1\u0026#34;)); File scrFile = element.getScreenshotAs(OutputType.FILE); FileUtils.copyFile(scrFile, new File(\u0026#34;./image.png\u0026#34;)); driver.quit(); } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) ele = driver.find_element(By.CSS_SELECTOR, \u0026#39;h1\u0026#39;) # Returns and base64 encoded string into image ele.screenshot(\u0026#39;./image.png\u0026#39;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Support.UI; // Webdriver  var driver = new ChromeDriver(); driver.Navigate().GoToUrl(\u0026#34;http://www.example.com\u0026#34;); // Fetch element using FindElement  var webElement = driver.FindElement(By.CssSelector(\u0026#34;h1\u0026#34;)); // Screenshot for the element  var elementScreenshot = (webElement as ITakesScreenshot).GetScreenshot(); elementScreenshot.SaveAsFile(\u0026#34;screenshot_of_element.png\u0026#34;);   # Works with Selenium4-alpha7 Ruby bindings and above require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://example.com/\u0026#39; ele = driver.find_element(:css, \u0026#39;h1\u0026#39;) # Takes and Stores the element screenshot in specified path ele.save_screenshot(\u0026#39;./image.jpg\u0026#39;) end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); let fs = require(\u0026#39;fs\u0026#39;); (async function example() { let driver = await new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); let ele = await driver.findElement(By.css(\u0026#34;h1\u0026#34;)); // Captures the element screenshot  let encodedString = await ele.takeScreenshot(true); await fs.writeFileSync(\u0026#39;./image.png\u0026#39;, encodedString, \u0026#39;base64\u0026#39;); await driver.quit(); }())   import org.apache.commons.io.FileUtils import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.* import java.io.File fun main() { val driver = ChromeDriver() driver.get(\u0026#34;https://www.example.com\u0026#34;) val element = driver.findElement(By.cssSelector(\u0026#34;h1\u0026#34;)) val scrFile: File = element.getScreenshotAs(OutputType.FILE) FileUtils.copyFile(scrFile, File(\u0026#34;./image.png\u0026#34;)) driver.quit() }     Execute Script Executes JavaScript code snippet in the current context of a selected frame or window.\nJava Python C# Ruby JavaScript Kotlin //Creating the JavascriptExecutor interface object by Type casting\t JavascriptExecutor js = (JavascriptExecutor)driver; //Button Element  WebElement button =driver.findElement(By.name(\u0026#34;btnLogin\u0026#34;)); //Executing JavaScript to click on element  js.executeScript(\u0026#34;arguments[0].click();\u0026#34;, element); //Get return value from script  String text = (String) javascriptExecutor.executeScript(\u0026#34;return arguments[0].innerText\u0026#34;, element); //Executing JavaScript directly  js.executeScript(\u0026#34;console.log(\u0026#39;hello world\u0026#39;)\u0026#34;);   # code sample not available please raise a PR    // code sample not available please raise a PR    # code sample not available please raise a PR    // Stores the header element let header = await driver.findElement(By.css(\u0026#39;h1\u0026#39;)); // Executing JavaScript to capture innerText of header element let text = await driver.executeScript(\u0026#39;return arguments[0].innerText\u0026#39;, header);   // code sample not available please raise a PR      "},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/grid_4/graphql_support/","title":"Suporte a buscas em GraphQL","tags":[],"description":"","content":"GraphQL é uma linguagem de consulta para APIs e um runtime para atender a essas consultas com seus dados existentes. Ele dá aos usuários o poder de pedir exatamente o que precisam e nada mais.\nEnums Enums representam possíveis conjuntos de valores para um campo.\nPor exemplo, o objeto Node possui um campo chamado status. O estado é um enum (especificamente, do tipo Status) porque pode ser UP, DRAINING ou UNAVAILABLE.\nEscalares Escalares são valores primitivos: Int, Float, String, Boolean ou ID.\nAo chamar a API GraphQL, você deve especificar o subcampo aninhado até retornar apenas escalares.\nEstrutura do Schema A estrutura do esquema de grade é a seguinte:\n{ session(id: \u0026#34;\u0026lt;session-id\u0026gt;\u0026#34;) : { id, capabilities, startTime, uri, nodeId, nodeUri, sessionDurationMillis slot : { id, stereotype, lastStarted } } grid: { uri, totalSlots, usedSlots, sessionCount, nodes : [ { id, uri, status, maxSession, sessions : [ { id, capabilities, startTime, uri, nodeId, nodeUri, sessionDurationMillis slot : { id, stereotype, lastStarted } } ] capabilities, } ] } } Consultando GraphQL O melhor jeito de consultar GraphQL é utilizando requisições curl. GraphQL permite que você busque apenas os dados que você quer, nada mais, anda menos.\nAlguns exemplos de buscas em GraphQL estão abaixo. Você pode montar as queries como quiser.\nBuscando o número total de slots (totalSlots) e slots usados (usedSlots) na Grid: curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;query\u0026#34;: \u0026#34;{ grid { totalSlots, usedSlots } }\u0026#34;}\u0026#39; -s \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; Geralmente na máquina local o \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; será http://localhost:4444/graphql\nBuscando todos os detalhes da Sessão, Nó e Grid: curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;query\u0026#34;:\u0026#34;{ grid { nodes { id, uri, status, sessions {id, capabilities, startTime, uri, nodeId, nodeUri, sessionDurationMillis, slot {id, stereotype, lastStarted } ,uri }, maxSession, capabilities }, uri, totalSlots, usedSlots , sessionCount } }\u0026#34;}\u0026#39; -s \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; Buscando o número de sessões atual na Grid: curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;query\u0026#34;:\u0026#34;{ grid { sessionCount } }\u0026#34;}\u0026#39; -s \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; Buscando a contagem máxima de sessões na Grid: curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;query\u0026#34;:\u0026#34;{ grid { nodes { maxSession } } }\u0026#34;}\u0026#39; -s \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; Buscando todos os detalhes de todas as sessões de todos os nós na Grid: curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;query\u0026#34;:\u0026#34;{ grid { nodes { sessions { id, capabilities, startTime, uri, nodeId, nodeId, sessionDurationMillis } } } }\u0026#34;}\u0026#39; -s \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; Buscando informações dos slots de todas as sessões de cada Nó na Grid: curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;query\u0026#34;:\u0026#34;{ grid { nodes { sessions { id, slot { id, stereotype, lastStarted } } } } }\u0026#34;}\u0026#39; -s \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; Buscando informação da sessão para uma sessão específica: curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;query\u0026#34;:\u0026#34;{ session (id: \u0026#34;\u0026lt;session-id\u0026gt;\u0026#34;) { id, capabilities, startTime, uri, nodeId, nodeUri , slot { id, stereotype, lastStarted } } } \u0026#34;}\u0026#39; -s \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; Buscando os recursos de cada nó na Grid: curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;query\u0026#34;: \u0026#34;{ grid { nodes { capabilities } } }\u0026#34;}\u0026#39; -s \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; Buscando o status de cada Nó na Grid: curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;query\u0026#34;: \u0026#34;{ grid { nodes { status } } }\u0026#34;}\u0026#39; -s \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; Buscando a URI de cada Nó e da Grid: curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;query\u0026#34;: \u0026#34;{ grid { nodes { uri }, uri } }\u0026#34;}\u0026#39; -s \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; "},{"uri":"https://www.selenium.dev/documentation/pt-br/introduction/types_of_testing/","title":"Tipos de teste","tags":[],"description":"","content":"Teste de aceitação Este tipo de teste é feito para determinar se um recurso ou sistema atende às expectativas e requisitos do cliente. Este tipo de teste geralmente envolve cooperação ou feedback do cliente, sendo uma atividade de validação que responde a pergunta:\n Estamos construindo o produto certo?.\n Para aplicações web, a automação desse teste pode ser feita diretamente com o Selenium, simulando o comportamento esperado do usuário. Esta simulação pode ser feita por gravação / reprodução ou por meio dos diferentes idiomas suportados, conforme explicado nesta documentação. Observação: o teste de aceitação é um subtipo de teste funcional, ao qual algumas pessoas também podem se referir.\nTeste funcional Este tipo de teste é feito para determinar se um recurso ou sistema funciona corretamente sem problemas. Verifica o sistema em diferentes níveis para garantir que todos os cenários são cobertos e que o sistema faz o que está suposto fazer. É uma atividade de verificação que responde a pergunta:\n Estamos construindo o produto corretamente?.\n Isso geralmente inclui: os testes funcionam sem erros (404, exceções \u0026hellip;), de forma utilizável (redirecionamentos corretos), de forma acessível e atendendo às suas especificações (consulte teste de aceitação acima).\nPara aplicativos da web, a automação desse teste pode ser feito diretamente com o Selenium, simulando os retornos esperados. Esta simulação pode ser feita por gravação / reprodução ou por meio de os diferentes idiomas suportados, conforme explicado nesta documentação.\nTeste de performance/desempenho Como o próprio nome indica, testes de desempenho são feitos para medir o desempenho de um aplicativo.\nExistem dois subtipos principais para testes de desempenho:\nTeste de carga O teste de carga é feito para verificar o quão bem o aplicativo funciona sob diferentes cargas definidas (geralmente um determinado número de usuários conectados ao mesmo tempo).\nTeste de estresse O teste de estresse é feito para verificar o quão bem a aplicação funciona sob estresse (ou acima da carga máxima suportada).\nGeralmente, os testes de estresse são feitos executando alguns testes escritos com Selenium simulando diferentes usuários utilizando uma função específica no aplicativo da web e recuperando algumas medições significativas.\nIsso geralmente é feito por outras ferramentas que recuperam as métricas. Uma dessas ferramentas é a JMeter.\nPara um aplicativo da web, os detalhes a serem medidos incluem taxa de transferência, latência, perda de dados, tempos de carregamento de componentes individuais \u0026hellip;\nNota 1: todos os navegadores têm uma guia de desempenho em seus seção de ferramentas para desenvolvedores (acessível pressionando F12)\nNota 2: é um subtipo de teste não funcional já que isso geralmente é medido por sistema e não por função / recurso.\nTeste regressivo Esse teste geralmente é feito após uma alteração, correção ou adição de recurso.\nPara garantir que a mudança não quebrou nenhumas das funcionalidades, alguns testes já executados são executados novamente.\nO conjunto de testes re-executados pode ser total ou parcial e pode incluir vários tipos diferentes, dependendo da equipe de aplicação e desenvolvimento.\nDesenvolvimento orientado a testes (TDD) Em vez de um tipo de teste per se, o TDD é uma metodologia iterativa de desenvolvimento na qual os testes conduzem o design de um recurso.\nCada ciclo começa criando um conjunto de testes de unidade no qual o recurso deve eventualmente ser aprovado (eles devem falhar na primeira execução).\nDepois disso, ocorre o desenvolvimento para fazer os testes passarem. Os testes são executados novamente, iniciando outro ciclo e esse processo continua até que todos os testes sejam aprovados.\nVisa acelerar o desenvolvimento de um aplicativo com base no fato de que os defeitos custam menos quanto mais cedo são encontrados.\nDesenvolvimento orientado a comportamento (BDD) BDD também é uma metodologia de desenvolvimento iterativa com base no TDD acima, em que o objetivo é envolver todas as partes no desenvolvimento de um aplicativo.\nCada ciclo começa criando algumas especificações (que deve falhar). Em seguida, crie a os testes de unidade com falha (que também devem falhar) e, em seguida, faça o desenvolvimento.\nEste ciclo é repetido até que todos os tipos de testes sejam aprovados.\nPara fazer isso, uma linguagem de especificação é usada. Deve ser compreensível por todas as partes e ser simples, padronizada e explícita. A maioria das ferramentas usa Gherkin como esse idioma.\nO objetivo é ser capaz de detectar ainda mais erros do que TDD, visando potenciais erros de aceitação também e tornar a comunicação entre as partes mais fácil.\nUm conjunto de ferramentas está atualmente disponível para escrever as especificações e combiná-las com funções de código, como Cucumber ou SpecFlow.\nUm conjunto de ferramentas é construído em cima do Selenium para tornar este processo ainda mais rápido, transformando diretamente as especificações BDD em código executável. Alguns deles são JBehave, Capybara e Robot Framework.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/support_packages/working_with_select_elements/","title":"Trabalhando com elementos select","tags":[],"description":"","content":" Page being translated from English to Brazilian Portuguese. Do you speak Brazilian Portuguese? Help us to translate it by sending us pull requests!\n Select elements can require quite a bit of boiler plate code to automate. To reduce this, and make your tests cleaner, there is a Select class in the Selenium support package. To use it, you will need the following import statement:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.support.ui.Select;   from selenium.webdriver.support.select import Select   using OpenQA.Selenium.Support.UI   include Selenium::WebDriver::Support   // This feature is not implemented - Help us by sending a pr to implement this feature    import org.openqa.selenium.support.ui.Select     You are then able to create a Select object using a WebElement that references a \u0026lt;select\u0026gt; element.\nJava Python C# Ruby JavaScript Kotlin WebElement selectElement = driver.findElement(By.id(\u0026#34;selectElementID\u0026#34;)); Select selectObject = new Select(selectElement);   select_element = driver.find_element(By.ID,\u0026#39;selectElementID\u0026#39;) select_object = Select(select_element)   IWebElement selectElement = driver.FindElement(By.Id(\u0026#34;selectElementID\u0026#34;)); var selectObject = new SelectElement(selectElement);   select_element = driver.find_element(id: \u0026#39;selectElementID\u0026#39;) select_object = Select(select_element)   // This feature is not implemented - Help us by sending a pr to implement this feature    val selectElement = driver.findElement(By.id(\u0026#34;selectElementID\u0026#34;)) val selectObject = new Select(selectElement)     The Select object will now give you a series of commands that allow you to interact with a \u0026lt;select\u0026gt; element. First of all, there are different ways of selecting an option from the \u0026lt;select\u0026gt; element.\n\u0026lt;select\u0026gt; \u0026lt;option value=value1\u0026gt;Bread\u0026lt;/option\u0026gt; \u0026lt;option value=value2 selected\u0026gt;Milk\u0026lt;/option\u0026gt; \u0026lt;option value=value3\u0026gt;Cheese\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; There are three ways to select the first option from the above element:\nJava Python C# Ruby JavaScript Kotlin // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.selectByIndex(1); // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.selectByValue(\u0026#34;value1\u0026#34;); // Select an \u0026lt;option\u0026gt; based upon its text selectObject.selectByVisibleText(\u0026#34;Bread\u0026#34;);   # Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.select_by_index(1) # Select an \u0026lt;option\u0026gt; based upon its value attribute select_object.select_by_value(\u0026#39;value1\u0026#39;) # Select an \u0026lt;option\u0026gt; based upon its text select_object.select_by_visible_text(\u0026#39;Bread\u0026#39;)   // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.SelectByIndex(1); // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.SelectByValue(\u0026#34;value1\u0026#34;); // Select an \u0026lt;option\u0026gt; based upon its text  selectObject.SelectByText(\u0026#34;Bread\u0026#34;);   # Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.select_by(:index, 1) # Select an \u0026lt;option\u0026gt; based upon its value attribute select_object.select_by(:value, \u0026#39;value1\u0026#39;) # Select an \u0026lt;option\u0026gt; based upon its text select_object.select_by(:text, \u0026#39;Bread\u0026#39;)   // This feature is not implemented - Help us by sending a pr to implement this feature    // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.selectByIndex(1) // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.selectByValue(\u0026#34;value1\u0026#34;) // Select an \u0026lt;option\u0026gt; based upon its text selectObject.selectByVisibleText(\u0026#34;Bread\u0026#34;)     You can then check which options are selected by using:\nJava Python C# Ruby JavaScript Kotlin // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected List\u0026lt;WebElement\u0026gt; allSelectedOptions = selectObject.getAllSelectedOptions(); // Return a WebElement referencing the first selection option found by walking down the DOM WebElement firstSelectedOption = selectObject.getFirstSelectedOption();   # Return a list[WebElement] of options that have been selected all_selected_options = select_object.all_selected_options # Return a WebElement referencing the first selection option found by walking down the DOM first_selected_option = select_object.first_selected_option   // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected var allSelectedOptions = selectObject.AllSelectedOptions; // Return a WebElement referencing the first selection option found by walking down the DOM var firstSelectedOption = selectObject.AllSelectedOptions.FirstOrDefault();   # Return an Array[Element] of options that have been selected all_selected_options = select_object.selected_options # Return a WebElement referencing the first selection option found by walking down the DOM first_selected_option = select_object.first_selected_option   // This feature is not implemented - Help us by sending a pr to implement this feature    // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected val allSelectedOptions = selectObject.allSelectedOptions // Return a WebElement referencing the first selection option found by walking down the DOM val firstSelectedOption = selectObject.firstSelectedOption     Or you may just be interested in what \u0026lt;option\u0026gt; elements the \u0026lt;select\u0026gt; element contains:\nJava Python C# Ruby JavaScript Kotlin // Return a List\u0026lt;WebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains List\u0026lt;WebElement\u0026gt; allAvailableOptions = selectObject.getOptions();   # Return a list[WebElement] of options that the \u0026amp;lt;select\u0026amp;gt; element contains all_available_options = select_object.options   // Return a IList\u0026lt;IWebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains IList\u0026lt;IWebElement\u0026gt; allAvailableOptions = selectObject.Options;   # Return an Array[Element] of options that the \u0026amp;lt;select\u0026amp;gt; element contains all_available_options = select_object.options   // This feature is not implemented - Help us by sending a pr to implement this feature    // Return a List\u0026lt;WebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains val allAvailableOptions = selectObject.options     If you want to deselect any elements, you now have four options:\nJava Python C# Ruby JavaScript Kotlin // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.deselectByIndex(1); // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.deselectByValue(\u0026#34;value1\u0026#34;); // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.deselectByVisibleText(\u0026#34;Bread\u0026#34;); // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.deselectAll();   # Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.deselect_by_index(1) # Deselect an \u0026lt;option\u0026gt; based upon its value attribute select_object.deselect_by_value(\u0026#39;value1\u0026#39;) # Deselect an \u0026lt;option\u0026gt; based upon its text select_object.deselect_by_visible_text(\u0026#39;Bread\u0026#39;) # Deselect all selected \u0026lt;option\u0026gt; elements select_object.deselect_all()   // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.DeselectByIndex(1); // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.DeselectByValue(\u0026#34;value1\u0026#34;); // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.DeselectByText(\u0026#34;Bread\u0026#34;); // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.DeselectAll();   # Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.deselect_by(:index, 1) # Deselect an \u0026lt;option\u0026gt; based upon its value attribute select_object.deselect_by(:value, \u0026#39;value1\u0026#39;) # Deselect an \u0026lt;option\u0026gt; based upon its text select_object.deselect_by(:text, \u0026#39;Bread\u0026#39;) # Deselect all selected \u0026lt;option\u0026gt; elements select_object.deselect_all   // This feature is not implemented - Help us by sending a pr to implement this feature    // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.deselectByIndex(1) // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.deselectByValue(\u0026#34;value1\u0026#34;) // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.deselectByVisibleText(\u0026#34;Bread\u0026#34;) // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.deselectAll()     Finally, some \u0026lt;select\u0026gt; elements allow you to select more than one option. You can find out if your \u0026lt;select\u0026gt; element is one of these by using:\nJava Python C# Ruby JavaScript Kotlin Boolean doesThisAllowMultipleSelections = selectObject.isMultiple();   does_this_allow_multiple_selections = select_object.is_multiple   bool doesThisAllowMultipleSelections = selectObject.IsMultiple;   does_this_allow_multiple_selections = select_object.multiple?   // This feature is not implemented - Help us by sending a pr to implement this feature    val doesThisAllowMultipleSelections = selectObject.isMultiple     "},{"uri":"https://www.selenium.dev/documentation/pt-br/support_packages/mouse_and_keyboard_actions_in_detail/","title":"Ações do mouse em detalhe","tags":[],"description":"","content":" Page being translated from English to Brazilian Portuguese. Do you speak Brazilian Portuguese? Help us to translate it by sending us pull requests!\n Mouse represents a mouse event. Mouse actions are performed by using low-level interface which allows us to provide virtualized device input action to the web browser.\nclickAndHold It will move to the element and clicks (without releasing) in the middle of the given element.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class clickAndHold { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform click-and-hold action on the element  actionProvider.clickAndHold(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element searchBtn = driver.find_element(By.LINK_TEXT, \u0026#34;Sign in\u0026#34;) # Perform click-and-hold action on the element webdriver.ActionChains(driver).click_and_hold(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class ClickAndHold { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform click-and-hold action on the element  actionProvider.ClickAndHold(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Sign In\u0026#39; button web element sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Perform click-and-hold action on the element driver.action.click_and_hold(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function clickAndHold() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;google search\u0026#39; button web element  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Perform mouseMove to element and mouseDown (press) action on the element  await actions.move({origin:searchBtn}).press().perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;google search\u0026#39; button web element  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Perform click-and-hold action on the element  actionProvider.clickAndHold(searchBtn).build().perform() } finally { driver.quit() } }     contextClick This method firstly performs a mouse-move to the location of the element and performs the context-click (right click) on the given element.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class contextClick { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform context-click action on the element  actionProvider.contextClick(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element searchBtn = driver.find_element(By.LINK_TEXT, \u0026#34;Sign in\u0026#34;) # Perform context-click action on the element webdriver.ActionChains(driver).context_click(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class ContextClick { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform context-click action on the element  actionProvider.ContextClick(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Sign In\u0026#39; button web element sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Perform context-click action on the element driver.action.context_click(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function contextClick() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;google search\u0026#39; button web element  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Perform context-click action on the element  await actions.contextClick(searchBtn).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;google search\u0026#39; button web element  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Perform context-click action on the element  actionProvider.contextClick(searchBtn).build().perform() } finally { driver.quit() } }     doubleClick It will move to the element and performs a double-click in the middle of the given element.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class doubleClick { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform double-click action on the element  actionProvider.doubleClick(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element searchBtn = driver.find_element(By.LINK_TEXT, \u0026#34;Sign in\u0026#34;) # Perform double-click action on the element webdriver.ActionChains(driver).double_click(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DoubleClick { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform double-click action on the element  actionProvider.DoubleClick(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Sign In\u0026#39; button web element sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Perform double-click action on the element driver.action.double_click(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function doubleClick() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;google search\u0026#39; button web element  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Perform double-click action on the element  await actions.doubleClick(searchBtn).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;google search\u0026#39; button web element  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Perform double-click action on the element  actionProvider.doubleClick(searchBtn).build().perform() } finally { driver.quit() } }     moveToElement This method moves the mouse to the middle of the element. The element is also scrolled into the view on performing this action.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class moveToElement { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;Gmail\u0026#39; anchor web element  WebElement gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs mouse move action onto the element  actionProvider.moveToElement(gmailLink).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element gmailLink = driver.find_element(By.LINK_TEXT, \u0026#34;Gmail\u0026#34;) # Performs mouse move action onto the element webdriver.ActionChains(driver).move_to_element(gmailLink).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class MoveToElement { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement gmailLink = driver.FindElement(By.LinkText(\u0026#34;Gmail\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs mouse move action onto the element  actionProvider.MoveToElement(gmailLink).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Gmail\u0026#39; anchor web element gmail_link = driver.find_element(link_text: \u0026#39;Gmail\u0026#39;) # Performs mouse move action onto the element driver.action.move_to(gmail_link).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function moveToElement() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;Gmail\u0026#39; anchor web element  let gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); const actions = driver.actions({async: true}); // Performs mouse move action onto the element  await actions.move({origin:gmailLink}).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;Gmail\u0026#39; anchor web element  val gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)) val actionProvider = Actions(driver) // Performs mouse move action onto the element  actionProvider.moveToElement(gmailLink).build().perform() } finally { driver.quit() } }     moveByOffset: This method moves the mouse from its current position (or 0,0) by the given offset. If the coordinates are outside the view window, then the mouse will end up outside the browser window.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class moveByOffset { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;Gmail\u0026#39; anchor web element  WebElement gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); // Capture x and y offset positions of element  int xOffset = gmailLink.getRect().getX(); int yOffset = gmailLink.getRect().getY(); Actions actionProvider = new Actions(driver); // Performs mouse move action onto the offset position  actionProvider.moveByOffset(xOffset, yOffset).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element gmailLink = driver.find_element(By.LINK_TEXT, \u0026#34;Gmail\u0026#34;) #Set x and y offset positions of element xOffset = 100 yOffset = 100 # Performs mouse move action onto the element webdriver.ActionChains(driver).move_by_offset(xOffset,yOffset).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class MoveByOffset { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement gmailLink = driver.FindElement(By.LinkText(\u0026#34;Gmail\u0026#34;)); // Set x and y offset positions of element  int xOffset = 100; int yOffset = 100; Actions actionProvider = new Actions(driver); // Performs mouse move action onto the offset position  actionProvider.MoveByOffset(xOffset, yOffset).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Gmail\u0026#39; anchor web element gmail_link = driver.find_element(link_text: \u0026#39;Gmail\u0026#39;) # Capture x and y offset positions of element x_offset = gmail_link.rect.x y_offset = gmail_link.rect.y # Performs mouse move action onto the offset position driver.action.move_to_location(x_offset, y_offset).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function moveByOffset() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;Gmail\u0026#39; anchor web element  let gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); // Capture offset positions of element  let offset = await gmailLink.getRect(); let x = await offset.x; let y = await offset.y; const actions = driver.actions({async: true}); // Performs mouse move action onto the element  await actions.move({x:parseInt(x),y:parseInt(y)}).pause(3000).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;Gmail\u0026#39; anchor web element  val gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)) // Capture x and y offset positions of element  val xOffset = gmailLink.rect.getX() val yOffset = gmailLink.rect.getY() val actionProvider = Actions(driver) // Performs mouse move action onto the element  actionProvider.moveByOffset(xOffset, yOffset).build().perform() } finally { driver.quit() } }     dragAndDrop This method firstly performs a click-and-hold on the source element, moves to the location of the target element and then releases the mouse.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class dragAndDrop { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.dragAndDrop(sourceEle, targetEle).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Store \u0026#39;box A\u0026#39; as source element sourceEle = driver.find_element(By.ID, \u0026#34;draggable\u0026#34;) # Store \u0026#39;box B\u0026#39; as source element targetEle = driver.find_element(By.ID, \u0026#34;droppable\u0026#34;) # Performs drag and drop action of sourceEle onto the targetEle webdriver.ActionChains(driver).drag_and_drop(sourceEle,targetEle).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DragAndDrop { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.DragAndDrop(sourceEle, targetEle).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; # Store \u0026#39;box A\u0026#39; as source element source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) # Store \u0026#39;box B\u0026#39; as source element target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) # Performs drag and drop action of sourceEle onto the targetEle driver.action.drag_and_drop(source_ele, target_ele).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function dragAndDrop() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Store \u0026#39;box A\u0026#39; as source element  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); const actions = driver.actions({async: true}); // Performs drag and drop action of sourceEle onto the targetEle  await actions.dragAndDrop(sourceEle, targetEle).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Store \u0026#39;box A\u0026#39; as source element  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Store \u0026#39;box B\u0026#39; as source element  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val actionProvider = Actions(driver) // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.dragAndDrop(sourceEle, targetEle).build().perform() } finally { driver.quit() } }     dragAndDropBy This method firstly performs a click-and-hold on the source element, moves to the given offset and then releases the mouse.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class dragAndDropBy { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); int targetEleXOffset = targetEle.getLocation().getX(); int targetEleYOffset = targetEle.getLocation().getY(); Actions actionProvider = new Actions(driver); // Performs dragAndDropBy onto the target element offset position  actionProvider.dragAndDropBy(sourceEle, targetEleXOffset, targetEleYOffset).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Store \u0026#39;box A\u0026#39; as source element sourceEle = driver.find_element(By.ID, \u0026#34;draggable\u0026#34;) # Store \u0026#39;box B\u0026#39; as source element targetEle = driver.find_element(By.ID, \u0026#34;droppable\u0026#34;) targetEleXOffset = targetEle.location.get(\u0026#34;x\u0026#34;) targetEleYOffset = targetEle.location.get(\u0026#34;y\u0026#34;) # Performs dragAndDropBy onto the target element offset position webdriver.ActionChains(driver).drag_and_drop_by_offset(sourceEle, targetEleXOffset, targetEleYOffset).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DragAndDropToOffset { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); int targetEleXOffset = targetEle.Location.X; int targetEleYOffset = targetEle.Location.Y; Actions actionProvider = new Actions(driver); // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.DragAndDropToOffset(sourceEle, targetEleXOffset, targetEleYOffset).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; # Store \u0026#39;box A\u0026#39; as source element source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) # Capture x and y offset positions of element x_offset = target_ele.rect.x y_offset = target_ele.rect.y # Performs dragAndDropBy onto the target element offset position driver.action.drag_and_drop_by(source_ele, x_offset, y_offset).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function dragAndDropBy() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Store \u0026#39;box A\u0026#39; as source element  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); let offset = await targetEle.getRect(); let x = await offset.x; let y = await offset.y; const actions = driver.actions({async: true}); // Performs dragAndDropBy onto the target element offset position  await actions.dragAndDrop(sourceEle, {x:parseInt(x), y:parseInt(y)}).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Store \u0026#39;box A\u0026#39; as source element  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Store \u0026#39;box B\u0026#39; as source element  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val targetEleXOffset = targetEle.location.getX() val targetEleYOffset = targetEle.location.getY() val actionProvider = Actions(driver) // Performs dragAndDropBy onto the target element offset position  actionProvider.dragAndDropBy(sourceEle, targetEleXOffset, targetEleYOffset).build().perform() } finally { driver.quit() } }     release This action releases the depressed left mouse button. If WebElement is passed, it will release depressed left mouse button on the given WebElement\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class release { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); actionProvider.clickAndHold(sourceEle).moveToElement(targetEle).build().perform(); // Performs release event  actionProvider.release().build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Store \u0026#39;box A\u0026#39; as source element sourceEle = driver.find_element(By.ID, \u0026#34;draggable\u0026#34;) # Store \u0026#39;box B\u0026#39; as source element targetEle = driver.find_element(By.ID, \u0026#34;droppable\u0026#34;) # Performs dragAndDropBy onto the target element offset position webdriver.ActionChains(driver).click_and_hold(sourceEle).move_to_element(targetEle).perform() #Performs release event webdriver.ActionChains(driver).release().perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class Release { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); actionProvider.ClickAndHold(sourceEle).MoveToElement(targetEle).Build().Perform(); // Performs release event  actionProvider.Release().Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) driver.action.click_and_hold(source_ele).move_to(target_ele).perform # Performs release event driver.action.release.perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function release() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Store \u0026#39;box A\u0026#39; as source element  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); const actions = driver.actions({async: true}); await actions.move({origin:sourceEle}).press().perform(); // Performs release event on target element  await actions.move({origin:targetEle}).release().perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Store \u0026#39;box A\u0026#39; as source element  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Store \u0026#39;box B\u0026#39; as source element  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val actionProvider = Actions(driver) actionProvider.clickAndHold(sourceEle).moveToElement(targetEle).build().perform() // Performs release event  actionProvider.release().build().perform() } finally { driver.quit() } }     "},{"uri":"https://www.selenium.dev/documentation/pt-br/getting_started_with_webdriver/","title":"Começando com o WebDriver","tags":[],"description":"","content":"Começando com o WebDriver Selenium suporta automação de todos os principais navegadores do mercado por meio do uso do WebDriver. WebDriver é uma API e protocolo que define uma interface de linguagem neutra para controlar o comportamento dos navegadores da web. Cada navegador é apoiado por uma implementação WebDriver específica, chamada de driver. O driver é o componente responsável por delegar ao navegador, e lida com a comunicação de e para o Selenium e o navegador.\nEssa separação é parte de um esforço consciente para que os fornecedores de navegadores assumam a responsabilidade pela implementação de seus navegadores. Selenium faz uso desses drivers de terceiros sempre que possível, mas também fornece seus próprios drivers mantidos pelo projeto para os casos em que isso não é uma realidade.\nA estrutura do Selenium une todas essas peças por meio de uma interface voltada para o usuário que permite aos diferentes back-ends de navegador serem usados de forma transparente, permitindo a automação entre navegadores e plataformas cruzadas.\nMais detalhes sobre os drivers podem ser encontrados em Idiossincrasias do driver.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/waits/","title":"Esperas","tags":[],"description":"","content":" Page being translated from English to Brazilian Portuguese. Do you speak Brazilian Portuguese? Help us to translate it by sending us pull requests!\n WebDriver can generally be said to have a blocking API. Because it is an out-of-process library that instructs the browser what to do, and because the web platform has an intrinsically asynchronous nature, WebDriver does not track the active, real-time state of the DOM. This comes with some challenges that we will discuss here.\nFrom experience, most intermittent issues that arise from use of Selenium and WebDriver are connected to race conditions that occur between the browser and the user\u0026rsquo;s instructions. An example could be that the user instructs the browser to navigate to a page, then gets a no such element error when trying to find an element.\nConsider the following document:\n\u0026lt;!doctype html\u0026gt; \u0026lt;meta charset=utf-8\u0026gt; \u0026lt;title\u0026gt;Race Condition Example\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; var initialised = false; window.addEventListener(\u0026#34;load\u0026#34;, function() { var newElement = document.createElement(\u0026#34;p\u0026#34;); newElement.textContent = \u0026#34;Hello from JavaScript!\u0026#34;; document.body.appendChild(newElement); initialised = true; }); \u0026lt;/script\u0026gt; The WebDriver instructions might look innocent enough:\nJava Python C# Ruby JavaScript Kotlin driver.get(\u0026#34;file:///race_condition.html\u0026#34;); WebElement element = driver.findElement(By.tagName(\u0026#34;p\u0026#34;)); assertEquals(element.getText(), \u0026#34;Hello from JavaScript!\u0026#34;);   driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) el = driver.find_element(By.TAG_NAME, \u0026#34;p\u0026#34;) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   driver.Navigate().GoToUrl(\u0026#34;file:///race_condition.html\u0026#34;); IWebElement element = driver.FindElement(By.TagName(\u0026#34;p\u0026#34;)); assertEquals(element.Text, \u0026#34;Hello from JavaScript!\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;file:///race_condition.html\u0026#39; # Get and store Paragraph Text search_form = driver.find_element(:css,\u0026#39;p\u0026#39;).text \u0026#34;Hello from JavaScript!\u0026#34;.eql? search_form ensure driver.quit end   await driver.get(\u0026#39;file:///race_condition.html\u0026#39;); const element = driver.findElement(By.css(\u0026#39;p\u0026#39;)); assert.strictEqual(await element.getText(), \u0026#39;Hello from JavaScript!\u0026#39;);   driver.get(\u0026#34;file:///race_condition.html\u0026#34;) val element = driver.findElement(By.tagName(\u0026#34;p\u0026#34;)) assert(element.text == \u0026#34;Hello from JavaScript!\u0026#34;)     The issue here is that the default page load strategy used in WebDriver listens for the document.readyState to change to \u0026quot;complete\u0026quot; before returning from the call to navigate. Because the p element is added after the document has completed loading, this WebDriver script might be intermittent. It “might” be intermittent because no guarantees can be made about elements or events that trigger asynchronously without explicitly waiting—or blocking—on those events.\nFortunately, the normal instruction set available on the WebElement interface—such as WebElement.click and WebElement.sendKeys—are guaranteed to be synchronous, in that the function calls will not return (or the callback will not trigger in callback-style languages) until the command has been completed in the browser. The advanced user interaction APIs, Keyboard and Mouse, are exceptions as they are explicitly intended as “do what I say” asynchronous commands.\nWaiting is having the automated task execution elapse a certain amount of time before continuing with the next step.\nTo overcome the problem of race conditions between the browser and your WebDriver script, most Selenium clients ship with a wait package. When employing a wait, you are using what is commonly referred to as an explicit wait.\nExplicit wait Explicit waits are available to Selenium clients for imperative, procedural languages. They allow your code to halt program execution, or freeze the thread, until the condition you pass it resolves. The condition is called with a certain frequency until the timeout of the wait is elapsed. This means that for as long as the condition returns a falsy value, it will keep trying and waiting.\nSince explicit waits allow you to wait for a condition to occur, they make a good fit for synchronising the state between the browser and its DOM, and your WebDriver script.\nTo remedy our buggy instruction set from earlier, we could employ a wait to have the findElement call wait until the dynamically added element from the script has been added to the DOM:\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new ChromeDriver(); driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); // Initialize and wait till element(link) became clickable - timeout in 10 seconds WebElement firstResult = new WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;))); // Print the first result System.out.println(firstResult.getText());   from selenium.webdriver.support.ui import WebDriverWait def document_initialised(driver): return driver.execute_script(\u0026#34;return initialised\u0026#34;) driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) WebDriverWait(driver).until(document_initialised) el = driver.find_element(By.TAG_NAME, \u0026#34;p\u0026#34;) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   driver = new ChromeDriver(); driver.Url = \u0026#34;https://www.google.com/ncr\u0026#34;; driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;cheese\u0026#34; + Keys.Enter); WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10)); IWebElement firstResult = wait.Until(e =\u0026gt; e.FindElement(By.XPath(\u0026#34;//a/h3\u0026#34;))); Console.WriteLine(firstResult.Text);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) def document_initialised(driver) driver.execute_script(\u0026#39;return initialised\u0026#39;) end begin driver.get \u0026#39;file:///race_condition.html\u0026#39; wait.until{document_initialised driver} search_form = driver.find_element(:css,\u0026#39;p\u0026#39;).text \u0026#34;Hello from JavaScript!\u0026#34;.eql? search_form ensure driver.quit end   const documentInitialised = () =\u0026gt; driver.executeScript(\u0026#39;return initialised\u0026#39;); await driver.get(\u0026#39;file:///race_condition.html\u0026#39;); await driver.wait(() =\u0026gt; documentInitialised(), 10000); const element = driver.findElement(By.css(\u0026#39;p\u0026#39;)); assert.strictEqual(await element.getText(), \u0026#39;Hello from JavaScript!\u0026#39;);   driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER) // Initialize and wait till element(link) became clickable - timeout in 10 seconds val firstResult = WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;))) // Print the first result println(firstResult.text)     We pass in the condition as a function reference that the wait will run repeatedly until its return value is truthy. A “truthful” return value is anything that evaluates to boolean true in the language at hand, such as a string, number, a boolean, an object (including a WebElement), or a populated (non-empty) sequence or list. That means an empty list evaluates to false. When the condition is truthful and the blocking wait is aborted, the return value from the condition becomes the return value of the wait.\nWith this knowledge, and because the wait utility ignores no such element errors by default, we can refactor our instructions to be more concise:\nJava Python C# Ruby JavaScript Kotlin WebElement foo = new WebDriverWait(driver, Duration.ofSeconds(3)) .until(driver -\u0026gt; driver.findElement(By.name(\u0026#34;q\u0026#34;))); assertEquals(foo.getText(), \u0026#34;Hello from JavaScript!\u0026#34;);   from selenium.webdriver.support.ui import WebDriverWait driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) el = WebDriverWait(driver).until(lambda d: d.find_element_by_tag_name(\u0026#34;p\u0026#34;)) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   using (var driver = new FirefoxDriver()) { var foo = new WebDriverWait(driver, TimeSpan.FromSeconds(3)) .Until(drv =\u0026gt; drv.FindElement(By.Name(\u0026#34;q\u0026#34;))); Debug.Assert(foo.Text.Equals(\u0026#34;Hello from JavaScript!\u0026#34;)); }   driver.get \u0026#39;file:///race_condition.html\u0026#39; wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) ele = wait.until { driver.find_element(css: \u0026#39;p\u0026#39;)} foo = ele.text assert_match foo, \u0026#39;Hello from JavaScript\u0026#39;   let ele = await driver.wait(until.elementLocated(By.css(\u0026#39;p\u0026#39;)),10000); let foo = await ele.getText(); assert(foo == \u0026#34;Hello from JavaScript\u0026#34;);   driver.get(\u0026#34;file:///race_condition.html\u0026#34;) val ele = WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.presenceOfElementLocated(By.tagName(\u0026#34;p\u0026#34;))) assert(ele.text == \u0026#34;Hello from JavaScript!\u0026#34;)     In that example, we pass in an anonymous function (but we could also define it explicitly as we did earlier so it may be reused). The first and only argument that is passed to our condition is always a reference to our driver object, WebDriver. In a multi-threaded environment, you should be careful to operate on the driver reference passed in to the condition rather than the reference to the driver in the outer scope.\nBecause the wait will swallow no such element errors that are raised when the element is not found, the condition will retry until the element is found. Then it will take the return value, a WebElement, and pass it back through to our script.\nIf the condition fails, e.g. a truthful return value from the condition is never reached, the wait will throw/raise an error/exception called a timeout error.\nOptions The wait condition can be customised to match your needs. Sometimes it is unnecessary to wait the full extent of the default timeout, as the penalty for not hitting a successful condition can be expensive.\nThe wait lets you pass in an argument to override the timeout:\nJava Python C# Ruby JavaScript Kotlin new WebDriverWait(driver, Duration.ofSeconds(3)).until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;)));   WebDriverWait(driver, timeout=3).until(some_condition)   new WebDriverWait(driver, TimeSpan.FromSeconds(3)).Until(ExpectedConditions.ElementToBeClickable(By.XPath(\u0026#34;//a/h3\u0026#34;)));   wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) wait.until { driver.find_element(:id, \u0026#39;message\u0026#39;).displayed? }   await driver.wait(until.elementLocated(By.id(\u0026#39;foo\u0026#39;)), 30000);   WebDriverWait(driver, Duration.ofSeconds(3)).until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;)))     Expected conditions Because it is quite a common occurrence to have to synchronise the DOM and your instructions, most clients also come with a set of predefined expected conditions. As might be obvious by the name, they are conditions that are predefined for frequent wait operations.\nThe conditions available in the different language bindings vary, but this is a non-exhaustive list of a few:\n alert is present element exists element is visible title contains title is element staleness visible text  You can refer to the API documentation for each client binding to find an exhaustive list of expected conditions:\n Java\u0026rsquo;s org.openqa.selenium.support.ui.ExpectedConditions class Python\u0026rsquo;s selenium.webdriver.support.expected_conditions class .NET\u0026rsquo;s OpenQA.Selenium.Support.UI.ExpectedConditions type  Implicit wait There is a second type of wait that is distinct from explicit wait called implicit wait. By implicitly waiting, WebDriver polls the DOM for a certain duration when trying to find any element. This can be useful when certain elements on the webpage are not available immediately and need some time to load.\nImplicit waiting for elements to appear is disabled by default and will need to be manually enabled on a per-session basis. Mixing explicit waits and implicit waits will cause unintended consequences, namely waits sleeping for the maximum time even if the element is available or condition is true.\nWarning: Do not mix implicit and explicit waits. Doing so can cause unpredictable wait times. For example, setting an implicit wait of 10 seconds and an explicit wait of 15 seconds could cause a timeout to occur after 20 seconds.\nAn implicit wait is to tell WebDriver to poll the DOM for a certain amount of time when trying to find an element or elements if they are not immediately available. The default setting is 0, meaning disabled. Once set, the implicit wait is set for the life of the session.\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS); driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;); WebElement myDynamicElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;));   driver = Firefox() driver.implicitly_wait(10) driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) my_dynamic_element = driver.find_element(By.ID, \u0026#34;myDynamicElement\u0026#34;)   IWebDriver driver = new ChromeDriver(); driver.Manage().Timeouts().ImplicitWait = TimeSpan.FromSeconds(10); driver.Url = \u0026#34;http://somedomain/url_that_delays_loading\u0026#34;; IWebElement dynamicElement = driver.FindElement(By.Name(\u0026#34;dynamicElement\u0026#34;));   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox driver.manage.timeouts.implicit_wait = 10 begin driver.get \u0026#39;http://somedomain/url_that_delays_loading\u0026#39; search_form = driver.find_element(:id,\u0026#39;dynamic_element\u0026#39;) ensure driver.quit end   (async function(){ // Apply timeout for 10 seconds await driver.manage().setTimeouts( { implicit: 10000 } ); // Navigate to url await driver.get(\u0026#39;http://somedomain/url_that_delays_loading\u0026#39;); let webElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;)); }());   val driver = FirefoxDriver() driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS) driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) val myDynamicElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;))     FluentWait FluentWait instance defines the maximum amount of time to wait for a condition, as well as the frequency with which to check the condition.\nUsers may configure the wait to ignore specific types of exceptions whilst waiting, such as NoSuchElementException when searching for an element on the page.\nJava Python C# Ruby JavaScript Kotlin // Waiting 30 seconds for an element to be present on the page, checking // for its presence once every 5 seconds. Wait\u0026lt;WebDriver\u0026gt; wait = new FluentWait\u0026lt;WebDriver\u0026gt;(driver) .withTimeout(Duration.ofSeconds(30)) .pollingEvery(Duration.ofSeconds(5)) .ignoring(NoSuchElementException.class); WebElement foo = wait.until(new Function\u0026lt;WebDriver, WebElement\u0026gt;() { public WebElement apply(WebDriver driver) { return driver.findElement(By.id(\u0026#34;foo\u0026#34;)); } });   driver = Firefox() driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) wait = WebDriverWait(driver, 10, poll_frequency=1, ignored_exceptions=[ElementNotVisibleException, ElementNotSelectableException]) element = wait.until(EC.element_to_be_clickable((By.XPATH, \u0026#34;//div\u0026#34;)))   using (var driver = new FirefoxDriver()) { WebDriverWait wait = new WebDriverWait(driver, timeout: TimeSpan.FromSeconds(30)) { PollingInterval = TimeSpan.FromSeconds(5), }; wait.IgnoreExceptionTypes(typeof(NoSuchElementException)); var foo = wait.Until(drv =\u0026gt; drv.FindElement(By.Id(\u0026#34;foo\u0026#34;))); }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox exception = Selenium::WebDriver::Error::NoSuchElementError begin driver.get \u0026#39;http://somedomain/url_that_delays_loading\u0026#39; wait = Selenium::WebDriver::Wait.new(timeout: 30, interval: 5, message: \u0026#39;Timed out after 30 sec\u0026#39;, ignore: exception) foo = wait.until { driver.find_element(id: \u0026#39;foo\u0026#39;)} ensure driver.quit end   const {Builder, until} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); await driver.get(\u0026#39;http://somedomain/url_that_delays_loading\u0026#39;); // Waiting 30 seconds for an element to be present on the page, checking  // for its presence once every 5 seconds.  let foo = await driver.wait(until.elementLocated(By.id(\u0026#39;foo\u0026#39;)), 30000, \u0026#39;Timed out after 30 seconds\u0026#39;, 5000); })();   val wait = FluentWait\u0026lt;WebDriver\u0026gt;(driver) .withTimeout(Duration.ofSeconds(30)) .pollingEvery(Duration.ofSeconds(3)) .ignoring(NoSuchElementException::class.java) val foo = wait.until {it.findElement(By.id(\u0026#34;foo\u0026#34;)) }     "},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/grid_4/","title":"Grid 4","tags":[],"description":"","content":"Grid 4 Selenium Grid 4 é uma implementação nova e não compartilha a base de código da versão anterior.\nGrid 4 tem uma abordagem para tirar proveito de uma série de novas tecnologias para facilitar o escalonamento, permitindo ainda a execução local.\nPara obter todos os detalhes dos componentes do Grid 4, entenda como funciona e como definir o seu próprio. Navegue pelas seguintes seções.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/worst_practices/gmail_email_and_facebook_logins/","title":"Login via Gmail, email e Facebook","tags":[],"description":"","content":"Por vários motivos, fazer login em sites como Gmail e Facebook usando do WebDriver não é recomendado. Além de ser contra os termos de uso desses sites (onde você corre o risco de ter a conta encerrada), é lento e não confiável.\nA prática ideal é usar as APIs que os provedores de e-mail oferecem, ou no caso do Facebook, o serviço de ferramentas para desenvolvedores que expõe uma API para criar contas de teste, amigos e assim por diante. Embora usar uma API possa parecer um pouco trabalhoso, você será recompensado em velocidade, confiabilidade e estabilidade. A API também não deve mudar, enquanto as páginas da web e os localizadores de HTML mudam frequentemente e exigem que você atualize sua estrutura de teste.\nLogin em sites de terceiros usando WebDriver em qualquer ponto do seu teste aumenta o risco de seu teste falhar porque torna o teste mais longo. Uma regra geral é que testes mais longos são mais frágeis e não confiáveis.\nImplementações WebDriver que estão em conformidade com W3C também anotam o objeto navigator com uma propriedade WebDriver para que os ataques de negação de serviço possam ser mitigados.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/grid_4/grid_endpoints/","title":"Rotas da Grid","tags":[],"description":"","content":"Grid Status da Grid O status da Grid fornece o estado atual da grid. Consiste em detalhes sobre cada nó registrado. Para cada nó, o status inclui informações sobre a disponibilidade, sessões e slots do nó.\ncURL GET \u0026#39;http://localhost:4444/status\u0026#39; No modo Standalone, o URL da Grid é o endereço do servidor Standalone.\nNo modo Hub-Node, a URL da Grid é o endereço do servidor Hub.\nNo modo totalmente distribuído, a URL da Grid é o endereço do servidor do roteador.\nA URL padrão para todos os modos acima é http://localhost:4444.\nDistribuidor Remover Nó Para remover o Nó da Grid, use o comando cURL listado abaixo. Ele não interrompe nenhuma sessão em andamento em execução nesse nó. O Node continua rodando como está, a menos que seja explicitamente eliminado. O Distribuidor não está mais ciente do Nó e, portanto, qualquer solicitação de nova sessão correspondente não será encaminhado para esse Nó.\nNo modo Standalone, a URL do distribuidor é o endereço do servidor Standalone.\nNo modo Hub-Node, a URL do Distribuidor é o endereço do servidor Hub.\ncURL --request DELETE \u0026#39;http://localhost:4444/se/grid/distributor/node/\u0026lt;node-id\u0026gt;\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET: \u0026lt;secret\u0026gt; \u0026#39; No modo totalmente distribuído, a URL é o endereço do servidor Distribuidor.\ncURL --request DELETE \u0026#39;http://localhost:5553/se/grid/distributor/node/\u0026lt;node-id\u0026gt;\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET: \u0026lt;secret\u0026gt;\u0026#39; Se nenhum segredo de registro foi configurado durante a configuração da Grid, use\ncURL --request DELETE \u0026#39;http://\u0026lt;Distributor-URL\u0026gt;/se/grid/distributor/node/\u0026lt;node-id\u0026gt;\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET;\u0026#39; Drenar Nó O comando de drenagem de nó é para desligamento normal de nó. A drenagem para o Node após a conclusão de todas as sessões em andamento. No entanto, ele não aceita novas solicitações de sessão.\nNo modo Standalone, a URL do distribuidor é o endereço do servidor Standalone.\nNo modo Hub-Node, a URL do Distribuidor é o endereço do servidor Hub.\ncURL --request POST \u0026#39;http://localhost:4444/se/grid/distributor/node/\u0026lt;node-id\u0026gt;/drain\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET: \u0026lt;secret\u0026gt; \u0026#39; No modo totalmente distribuído, a URL é o endereço do servidor Distribuidor.\ncURL --request POST \u0026#39;http://localhost:5553/se/grid/distributor/node/\u0026lt;node-id\u0026gt;/drain\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET: \u0026lt;secret\u0026gt;\u0026#39; Se nenhum segredo de registro foi configurado durante a configuração da Grid, use\ncURL --request POST \u0026#39;http://\u0026lt;Distributor-URL\u0026gt;/se/grid/distributor/node/\u0026lt;node-id\u0026gt;/drain\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET;\u0026#39; Nó Os terminais nesta seção são aplicáveis ao modo Hub-Node e ao modo Grid totalmente distribuída, onde o Nó é executado de forma independente. A URL do Nó padrão é http://localhost:5555 no caso de um Nó. No caso de vários Nós, use Grid status para obter todos os detalhes do Nó e localizar o endereço do Nó.\nStatus O status do Nó é essencialmente uma verificação de integridade do Nó. O distribuidor executa ping no status do Nó em intervalos regulares e atualiza o modelo de Grid de acordo. O status inclui informações sobre disponibilidade, sessões e slots.\ncURL --request GET \u0026#39;http://localhost:5555/status\u0026#39; Drenagem O Distribuidor passa o comando [drain](# drain-node) para o Nó apropriado identificado pelo ID do Nó. Para drenar o Nó diretamente, use o comando cuRL listado abaixo. Ambos as rotas são válidas e produzem o mesmo resultado. Drenar termina as sessões em andamento antes de interromper o Nó.\ncURL --request POST \u0026#39;http://localhost:5555/se/grid/node/drain\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET: \u0026lt;secret\u0026gt;\u0026#39; Se nenhum segredo de registro foi configurado durante a configuração da Grid, use\ncURL --request POST \u0026#39;http://\u0026lt;node-URL\u0026gt;/se/grid/node/drain\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET;\u0026#39; Checar dono da sessão Para verificar se uma sessão pertence a um Nó, use o comando cURL listado abaixo.\ncURL --request GET \u0026#39;http://localhost:5555/se/grid/node/owner/\u0026lt;session-id\u0026gt;\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET: \u0026lt;secret\u0026gt;\u0026#39; Se nenhum segredo de registro foi configurado durante a configuração da Grid, use\ncURL --request GET \u0026#39;http://\u0026lt;bode-URL\u0026gt;/se/grid/node/owner/\u0026lt;session-id\u0026gt;\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET;\u0026#39; Ele retornará true se a sessão pertencer ao Nó, caso contrário, retornará false.\nDeletar sessão A exclusão da sessão encerra a sessão do WebDriver, fecha o driver e o remove do mapa de sessões ativas. Qualquer solicitação usando o id de sessão removido ou reutilizando a instância do driver gerará um erro.\ncURL --request DELETE \u0026#39;http://localhost:5555/se/grid/node/session/\u0026lt;session-id\u0026gt;\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET: \u0026lt;secret\u0026gt;\u0026#39; Se nenhum segredo de registro foi configurado durante a configuração da Grid, use\ncURL --request DELETE \u0026#39;http://\u0026lt;node-URL\u0026gt;/se/grid/node/session/\u0026lt;session-id\u0026gt;\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET;\u0026#39; Fila de Sessão Limpar a Fila de Sessão A Fila de Sessão contém as novas solicitações de sessão. Para limpar a fila, use o comando cURL listado abaixo. Limpar a fila rejeita todas as solicitações na fila. Para cada solicitação, o servidor retorna uma resposta de erro ao respectivo cliente. O resultado do comando clear é o número total de solicitações excluídas.\nNo modo Standalone, a URL queuer é o endereço do servidor Standalone.\nNo modo Hub-Node, a URL do enfileirador é o endereço do servidor Hub.\ncURL --request DELETE \u0026#39;http://localhost:4444/se/grid/newsessionqueuer/queue\u0026#39; No modo totalmente distribuído, a URL do enfileirador é o endereço do servidor do Enfileirador de Sessões.\ncURL --request DELETE \u0026#39;http://localhost:5559/se/grid/newsessionqueuer/queue\u0026#39; "},{"uri":"https://www.selenium.dev/documentation/pt-br/legacy_docs/selenium_ide/","title":"Selenium IDE Legado","tags":[],"description":"","content":"Introdução A Selenium-IDE (Integrated Development Environment) é a ferramenta que você usa para desenvolver seus casos de teste Selenium. É um plug-in do Firefox fácil de usar e é geralmente a maneira mais eficiente de desenvolver casos de teste. Ela também contém um menu de contexto que permite que você primeiro selecione um elemento de UI do navegador atualmente exibido na página e, em seguida, selecione de uma lista de comandos Selenium com parâmetros predefinidos de acordo com o contexto do elemento de UI selecionado. Isso não é apenas uma economia de tempo, mas também uma excelente maneira de aprender a sintaxe do script Selenium.\nEste capítulo é sobre a Selenium IDE e como usá-la efetivamente.\nInstalando a IDE Usando o Firefox, primeiro, baixe a IDE da página de downloads do SeleniumHQ.\nO Firefox irá protegê-lo contra a instalação de complementos de locais desconhecidos, então você precisará clicar em \u0026ldquo;Permitir\u0026rdquo; para prosseguir com a instalação, conforme mostrado na imagem a seguir.\nAo fazer download do Firefox, você verá a seguinte janela.\nSelecione Instalar Agora. A janela de complementos do Firefox aparece, mostrando primeiro uma barra de progresso, e quando o download for concluído, exibe o seguinte.\nReinicie o Firefox. Após a reinicialização do Firefox, você encontrará a Selenium-IDE listada no menu Ferramentas do Firefox.\nAbrindo a IDE Para executar a Selenium-IDE, simplesmente selecione-a no menu Ferramentas do Firefox. Ela abrirá como segue com uma janela de edição de script vazia e um menu para carregar ou criar novos casos de teste.\nFuncionalidades da IDE Barra de Menu O menu Arquivo tem opções para Caso de Teste e Suíte de Testes (conjunto de casos de teste). Usando isso, você pode adicionar um novo caso de teste, abrir um caso de teste, salvar um caso de teste, e exportar um caso de teste em uma linguagem de sua escolha. Você também pode abrir o caso de teste mais recente. Todas essas opções também estão disponíveis para a suíte de testes.\nO menu Editar permite copiar, colar, excluir, desfazer e selecionar todas as operações para editar os comandos em seu caso de teste. O menu Opções permite a mudança de configurações. Você pode definir o valor de tempo limite para certos comandos, extensões de usuário para o conjunto básico de comandos Selenium e especificar o formato (linguagem) usado ao salvar seus casos de teste. O menu Ajuda é o padrão Menu Ajuda do Firefox; há apenas um item neste menu - Documentação do elemento de UI - pertencente ao Selenium-IDE.\nBarra de Ferramentas A barra de ferramentas contém botões para controlar a execução de seus casos de teste, incluindo um recurso de etapas para depurar seus casos de teste. O botão mais à direita, aquele com o ponto vermelho, é o botão de gravação.\nControle de velocidade: controla a velocidade de execução do seu caso de teste.\nExecutar todos: executa todo a suíte de testes quando uma suíte de testes com vários casos de teste é carregado.\nExecutar: executa o teste atualmente selecionado. Quando apenas um único teste é carregado este botão e o botão Executar todos têm o mesmo efeito.\nPausar/Continuar: permite interromper e reiniciar um caso de teste em execução.\nStep: permite que você \u0026ldquo;avance\u0026rdquo; por um caso de teste, executando um comando de cada vez. Use para depurar casos de teste.\nModo TestRunner: permite que você execute o caso de teste em um navegador carregado com o Selenium-Core TestRunner. O TestRunner não é comumente usado agora e é provável seja descontinuado. Este botão é para avaliar casos de teste para compatibilidade com versões anteriores com o TestRunner. A maioria dos usuários provavelmente não precisará desse botão.\nAplicar regras de Rollup: Este recurso avançado permite sequências repetitivas de comandos do Selenium a serem agrupadas em uma única ação. A documentação detalhada sobre as regras de rollup podem ser encontradas na documentação do Elemento de UI no menu Ajuda.\nPainel de casos de teste Seu script é exibido no painel de casos de teste. Tem duas guias, uma para exibir o comando e seus parâmetros em um formato de “tabela” legível.\nA outra guia - Código Fonte exibe o caso de teste no formato nativo no qual o arquivo será armazenado. Por padrão, é HTML, embora possa ser alterado para uma linguagem de programação como Java ou C#, ou uma linguagem de script como Python. Consulte o menu Opções para obter detalhes. A visualização do Código Fonte também permite editar o caso de teste em sua forma bruta, incluindo operações de copiar, recortar e colar.\nOs campos de entrada de Comando, Destino e Valor exibem o comando atualmente selecionado junto com seus parâmetros. Estes são campos de entrada onde você pode modificar o comando atualmente selecionado. O primeiro parâmetro especificado para um comando na guia Referência do painel inferior sempre vai para o campo Destino. Se um segundo parâmetro é especificado pela guia Referência, ele sempre vai no campo Valor.\nSe você começar a digitar no campo Comando, uma lista suspensa será preenchida com base nos primeiros caracteres que você digitar; você pode então selecionar o comando que deseja no menu suspenso.\nPainel de Log / Referência / Elemento de UI / Rollup O painel inferior é usado para quatro funções diferentes - Log, Referência, Elemento de UI e Rollup - dependendo da guia selecionada.\nLog Quando você executa seu caso de teste, mensagens de erro e mensagens de informação mostrando o progresso são exibidas neste painel automaticamente, mesmo se você não selecionar a guia Log primeiro. Essas mensagens geralmente são úteis para depuração de casos de teste. Observe o botão Limpar para limpar o registro. Observe também que o botão Informações é um drop-down permitindo a seleção de diferentes níveis de informação para registrar.\nReferência A guia Referência é a seleção padrão sempre que você entrar ou modificar comandos e parâmetros Selenium no modo Tabela. No modo Tabela, o painel de Referência exibirá a documentação do comando atual. Ao inserir ou modificar comandos, seja do modo Tabela ou Código Fonte, é criticamente importante garantir que os parâmetros especificados nos campos Destino e Valor correspondem aos especificados na lista de parâmetros do painel Referência. O número de parâmetros fornecidos deve corresponder ao número especificado, a ordem dos parâmetros fornecidos deve corresponder à ordem especificada e os tipos de parâmetros fornecidos devem corresponder aos tipos especificados. Se houver uma incompatibilidade em qualquer uma dessas três áreas, o comando não funcionará corretamente.\nEmbora a guia Referência seja ótima como uma referência rápida, ainda é necessário consultar a documentação de referência do Selenium.\nElemento de UI e Rollup Informações detalhadas sobre esses dois painéis (que abrangem recursos avançados) podem ser encontradas na documentação do Elemento de UI no menu Ajuda do Selenium-IDE.\nConstruindo casos de teste Existem três métodos principais para desenvolver casos de teste. Frequentemente, um desenvolvedor de testes necessita de todas as três técnicas.\nGravando Muitos usuários de primeira viagem começam gravando um caso de teste de suas interações com um site. Quando a Selenium-IDE é aberta pela primeira vez, o botão de gravação é ativado por padrão. Se você não quiser que a Selenium-IDE comece a gravar automaticamente, você pode desligar isso indo em Opções \u0026gt; Opções… e desmarcando “Iniciar gravação imediatamente ao abrir.”\nDurante a gravação, a Selenium-IDE irá inserir comandos automaticamente em seu caso de teste com base em suas ações. Normalmente, isso incluirá:\n clicar em um link - comandos click ou clickAndWait inserir valores - comando type selecionar opções de uma caixa de listagem suspensa - comando select clicar em caixas de seleção ou botões de rádio - comando click  Aqui estão algumas “pegadinhas” para ficar atento:\n O comando type pode exigir o clique em alguma outra área da página da web para começar a gravar. Seguir um link geralmente registra um comando de clique. Frequentemente, você precisará mudar isso para clickAndWait para garantir que seu caso de teste pause até que a nova página seja completamente carregada. Caso contrário, seu caso de teste continuará executando comandos antes que a página carregue todos os seus elementos de UI. Isso causará uma falha de teste inesperada.  Adicionando verificações e asserções com o Menu de Contexto Seus casos de teste também precisarão verificar as propriedades de uma página da web. Isto requer comandos de asserção e verificação. Não descreveremos os detalhes desses comandos aqui; que estão no capítulo sobre Comandos do Selenium - “Selenese”. Aqui vamos simplesmente descrever como adicioná-los ao seu caso de teste.\nCom a gravação da Selenium-IDE, vá para o navegador exibindo sua aplicação de teste e clique com o botão direito em qualquer lugar da página. Você verá um menu de contexto mostrando comandos verificar e/ou declarar.\nNa primeira vez que você usa o Selenium, pode haver apenas um comando Selenium listado. Ao usar a IDE, no entanto, você encontrará comandos adicionais que serão rapidamente adicionados a este menu. A Selenium-IDE tentará prever qual comando, junto com os parâmetros, você precisará para um elemento de interface selecionado na atual página da web.\nVamos ver como isso funciona. Abra uma página da web de sua escolha e selecione um bloco de texto na página. Um parágrafo ou título funcionará bem. Agora, clique com o botão direito no texto selecionado. O menu de contexto deve fornecer um comando verifyTextPresent e o parâmetro sugerido deve ser o próprio texto.\nAlém disso, observe a opção Mostrar Todos os Comandos Disponíveis. Isso mostra muitos, muitos mais comandos, novamente, junto com parâmetros sugeridos, para testar seu elemento de UI atualmente selecionado.\nExperimente mais alguns elementos de UI. Tente clicar com o botão direito em uma imagem ou em um controle de usuário, como um botão ou uma caixa de seleção. Você pode precisar usar Mostrar Todos os Comandos Disponíveis para ver opções diferentes de verifyTextPresent. Depois de selecionar essas outras opções, os mais usados aparecerão no menu de contexto principal. Por exemplo, selecionar verifyElementPresent para uma imagem deve posteriormente fazer com que esse comando esteja disponível no menu de contexto principal na próxima vez que você selecionar uma imagem e clicar com o botão direito.\nNovamente, esses comandos serão explicados em detalhes no capítulo sobre comandos Selenium. Por enquanto, fique à vontade para usar a IDE para gravar e selecionar comandos em um caso de teste e, em seguida, execute-o. Você pode aprender muito sobre os comandos do Selenium simplesmente experimentando com a IDE.\nEditando Inserir comando Visualização Tabela Selecione o ponto em seu caso de teste onde deseja inserir o comando. No painel de caso de teste, clique com o botão esquerdo na linha onde deseja inserir um novo comando. Clique com o botão direito e selecione Inserir Comando; a IDE irá adicionar um espaço em branco imediatamente à frente da linha que você selecionou. Agora use os campos de edição de texto para inserir seu novo comando e seus parâmetros.\nVisualização Código Fonte Selecione o ponto em seu caso de teste onde deseja inserir o comando. No painel do caso de teste, clique com o botão esquerdo entre os comandos onde você deseja insira um novo comando e insira as tags HTML necessárias para criar uma linha de 3 colunas contendo o Comando, primeiro parâmetro (se for exigido pelo Comando), e segundo parâmetro (novamente, se for necessário para localizar um elemento) e terceiro parâmetro (novamente, se for necessário ter um valor). Exemplo:\n\u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Command\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;target (locator)\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Value\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; Inserir comentário Comentários podem ser adicionados para tornar seu caso de teste mais legível. Esses comentários são ignorados quando o caso de teste é executado.\nOs comentários também podem ser usados para adicionar espaço em branco vertical (uma ou mais linhas em branco) em seus testes; apenas crie comentários vazios. Um comando vazio causará um erro durante a execução; um comentário vazio, não.\nVisualização Tabela Selecione a linha em seu caso de teste onde deseja inserir o comentário. Clique com o botão direito e selecione Inserir Comentário. Agora use o campo Comando para inserir o comentário. Seu comentário aparecerá em roxo.\nVisualização Código Fonte Selecione o ponto em seu caso de teste onde deseja inserir o comentário. Adicione um comentário no estilo HTML, ou seja, \u0026lt;!-- seu comentário aqui --\u0026gt;\nEditar um comando ou comentário Visualização Tabela Basta selecionar a linha a ser alterada e editá-la usando os campos de comando, destino, e valor.\nVisualização Código Fonte Uma vez que a visualização do Código Fonte fornece o equivalente a um editor WYSIWYG (What You See Is What You Get), simplesmente modifique a linha que você deseja - comando, parâmetro ou comentário.\nAbrindo e salvando um caso de teste Como a maioria dos programas, existem comandos Salvar e Abrir no menu Arquivo. No entanto, o Selenium distingue entre casos de teste e suítes de teste. Para salvar seus testes Selenium-IDE para uso posterior, você pode salvar os casos de teste individualmente ou salvar a suíte de testes. Se os casos de teste de sua suíte de testes não foram salvos, você será solicitado a salvá-los antes de salvar a suíte.\nQuando você abre um caso de teste ou suíte existente, a Selenium-IDE exibe seu comandos do Selenium no painel de caso de teste.\nExecutando casos de teste A IDE fornece muitas opções para executar seu caso de teste. Você pode executar um caso de teste inteiro de uma vez, parar e iniciar, executar uma linha de cada vez, executar um único comando que você está desenvolvendo atualmente e pode fazer uma execução em lote de uma suíte de testes. A execução de casos de teste é muito flexível na IDE.\nExecutar um caso de teste\nClique no botão Executar para executar o caso de teste mostrado.\nExecutar uma suíte de testes\nClique no botão Executar Todos para executar todos os testes dentro da suíte de testes\nParar e Continuar\nO botão de Pausa pode ser utilizado para parar o caso de teste no meio da sua execução. O ícone do botão então muda para indicar que você pode Continuar. Para continuar, clique nele.\nParar no meio\nVocê pode definir um ponto de interrupção (breakpoint) no caso de teste para que ele pare em um comando específico. Isto é útil para depurar seu teste. Para definir um ponto de interrupção, selecione um comando, clique com o botão direito e a partir do Menu de Contexto selecione Alternar ponto de interrupção.\nComeçar do meio\nVocê pode preferir que a IDE comece a executar a partir de um comando específico no meio do caso de teste. Isto também pode ser usado para depuração. Para definir um ponto de começo, selecione o comando, clique com o botão direito e a partir do Menu de Contexto selecione Set/Clear Start Point.\nExecute um comando isolado\nDe um duplo-clique em qualquer comando para executá-lo. Isto é útil quando você está escrevendo um único comando. Permite testar imediatamente o comando sendo construído, quando não tem certeza se ele está certo. Você pode dar um duplo-clique para ver se o comando é executado corretamente. Isto também está disponível no Menu de Contexto.\nUsando uma URL base para executar casos de teste em diferentes domínios O campo URL base na parte superior da janela da Selenium-IDE é muito útil para permitir que os casos de teste sejam executados em diferentes domínios. Suponha que um site chamado http://news.portal.com tenha um site beta interno chamado http://beta.news.portal.com. Quaisquer casos de teste para esses sites que começam com um comando open devem especificar uma URL relativa como o argumento para abrir, em vez de uma URL absoluta (começando com um protocolo como http: ou https:). A Selenium-IDE irá então criar uma URL absoluta anexando o argumento do comando open no final do valor da URL base. Por exemplo, o caso de teste abaixo seria executado em http://news.portal.com/about.html:\nEste mesmo caso de teste com uma configuração de URL base modificada seria executado em http://beta.news.portal.com/about.html:\nComandos Selenium – “Selenese” Os comandos do Selenium, muitas vezes chamados de Selenese, são o conjunto de comandos que executam o seu testes. Uma sequência desses comandos é um script de teste. Aqui nós explicamos esses comandos em detalhes, e apresentamos as diversas opções que você tem ao testar a sua aplicação web usando o Selenium.\nSelenium fornece um conjunto rico de comandos para testar totalmente sua aplicação web quase de qualquer maneira que você possa imaginar. O conjunto de comandos é frequentemente chamado de Selenese. Esses comandos criam essencialmente uma linguagem de teste.\nEm Selenese, pode-se testar a existência de elementos de UI com base em suas tags HTML, testar a existência de um conteúdo específico, testar a existência de links quebrados, campos de entrada, opções de lista de seleção, envio de formulários e dados de tabela, entre outras coisas. Além do mais os comandos do Selenium suportam testes de tamanho de janela, posição do mouse, alertas, funcionalidade Ajax, janelas pop-up, tratamento de eventos e muitas outras características de aplicativos da web. A Referência de Comandos lista todos os comandos disponíveis.\nUm comando diz ao Selenium o que fazer. Os comandos do Selenium vêm em três \u0026ldquo;sabores\u0026rdquo;: Ações, Acessores e Asserções.\n  Ações são comandos que geralmente manipulam o estado do aplicativo. Elas fazem coisas como “clicar neste link” e “selecionar essa opção”. Se uma ação falhar ou tiver um erro, a execução do teste atual é interrompida.\nMuitas ações podem ser chamadas com o sufixo \u0026ldquo;AndWait\u0026rdquo;, por ex. “ClickAndWait”. Este sufixo diz ao Selenium que a ação fará com que o navegador faça uma chamada para o servidor, e que o Selenium deve aguardar o carregamento de uma nova página.\n  Acessores examinam o estado do aplicativo e armazenam os resultados em variáveis, por exemplo “StoreTitle”. Eles também são usados para gerar Asserções automaticamente.\n  Asserções são como Acessores, mas verificam se o estado da aplicação está em conformidade com o que é esperado. Os exemplos incluem “certifique-se de que o título da página é X” e “verifique se esta caixa de seleção está marcada”.\n  Todas as asserções do Selenium podem ser usadas em 3 modos: \u0026ldquo;assert\u0026rdquo;, \u0026ldquo;verify\u0026rdquo; e \u0026ldquo;wait for\u0026rdquo;. Por exemplo, você pode usar “assertText”, “verifyText” e “waitForText”. Quando uma asserção falha, o teste é abortado. Quando uma verificação falha, o teste continuará a execução, registrando a falha. Isso permite uma única asserção para certificar-se de que o aplicativo está na página correta, seguido por um monte de verificações para testar os valores dos campos do formulário, rótulos, etc.\nOs comandos \u0026ldquo;waitFor\u0026rdquo; aguardam até que alguma condição se torne verdadeira (o que pode ser útil para testar aplicativos Ajax). Eles terão sucesso imediatamente se a condição já é verdadeira. No entanto, eles falharão e interromperão o teste se a condição não se tornar verdadeira dentro da configuração de timeout atual (veja o setTimeout ação abaixo).\nSintaxe do Script Os comandos do Selenium são simples, consistem no comando e em dois parâmetros. Por exemplo:\n          verifyText //div//a[2] Login    Os parâmetros nem sempre são necessários, depende do comando. Em alguns casos ambos são necessários, em outros um parâmetro é necessário, e ainda em outros, o comando pode não ter nenhum parâmetro. Aqui estão mais alguns exemplos:\n          goBackAndWait     verifyTextPresent  Welcome to My Home Page   type id=phone (555) 666-7066   type id=address1 ${myVariableAddress}    A referência de comandos descreve os requisitos de parâmetro para cada comando.\nOs parâmetros variam, mas normalmente são:\n um localizador para identificar um elemento de UI em uma página. um padrão de texto para verificar ou fazer uma asserção do conteúdo esperado da página um padrão de texto ou uma variável Selenium para inserir texto em um campo de entrada ou para selecionar uma opção de uma lista de opções.  Localizadores, padrões de texto, variáveis Selenium e os próprios comandos são descritos em bastante detalhe na seção sobre Comandos do Selenium.\nOs scripts do Selenium que serão executados a partir da Selenium-IDE serão armazenados em um arquivo de texto HTML. Isso consiste em uma tabela HTML com três colunas. A primeira coluna identifica o comando Selenium, a segunda é um alvo e a última coluna contém um valor. A segunda e terceira colunas podem não exigir valores dependendo do comando Selenium escolhido, mas elas devem estar presentes. Cada linha da tabela representa um novo comando Selenium. Aqui está um exemplo de um teste que abre uma página, faz um asserção no título da página e, em seguida, verifica algum conteúdo na página:\n\u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;/download/\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;assertTitle\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;Downloads\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;verifyText\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;//h2\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;Downloads\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; Renderizado como uma tabela em um navegador, seria assim:\n          open /download/    assertTitle  Downloads   verifyText //h2 Downloads    A sintaxe HTML Selenese pode ser usada para escrever e executar testes sem exigir conhecimento de uma linguagem de programação. Com um conhecimento básico de Selenese e Selenium-IDE você pode produzir e executar casos de teste rapidamente.\nSuítes de Teste Uma suíte de testes é uma coleção de testes. Frequentemente, você executará todos os testes em uma suite de teste como um trabalho em lote contínuo.\nAo usar a Selenium-IDE, as suítes de testes também podem ser definidas usando um arquivo HTML simples. A sintaxe novamente é simples. Uma tabela HTML define uma lista de testes onde cada linha define o caminho do sistema de arquivos para cada teste. Um exemplo diz tudo.\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Test Suite Function Tests - Priority 1\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;b\u0026gt;Suite Of Tests\u0026lt;/b\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./Login.html\u0026#34;\u0026gt;Login\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./SearchValues.html\u0026#34;\u0026gt;Test Searching for Values\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./SaveValues.html\u0026#34;\u0026gt;Test Save\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Um arquivo semelhante a este permitiria executar todos os testes de uma vez, um após o outro, a partir da Selenium-IDE.\nAs suítes de testes também podem ser mantidas ao usar o Selenium-RC. Isso é feito via programação de várias maneiras. Normalmente Junit é usado para manter um conjunto de testes se estiver usando Selenium-RC com Java. Além disso, se C# é a linguagem escolhida, o Nunit pode ser utilizado. Se estiver usando uma linguagem interpretada como Python com Selenium-RC, então alguma programação simples seria envolvida na configuração de uma suíte. Uma vez que o motivo de usar Selenium-RC é se aproveitar da lógica de programação para o seu teste, geralmente não é um problema.\nComandos Selenium usados com frequencia Para concluir nossa introdução ao Selenium, mostraremos alguns comandos típicos. Estes são provavelmente os comandos mais comumente usados para construir testes.\nopen\nabre uma página usando a URL.\nclick/clickAndWait\nrealiza um clique e opcionalmente aguarda o carregamento de uma nova página.\nverifyTitle/assertTitle\nverifica se o título da página é o esperado.\nverifyTextPresent\nverifica se o texto esperado está em algum lugar da página.\nverifyElementPresent\nverifica se o elemento de UI esperado, definido pela tag HTML, está em algum lugar da página.\nverifyText\nverficia se o texto esperado e a tag HTML correspondente estão presentes na página.\nverifyTable\nverifica se o conteúdo da tabela é o esperado.\nwaitForPageToLoad\npausa a execução até que a nova página carregue. Chamado automaticamente quando clickAndWait é utilizado.\nwaitForElementPresent\npausa a execução até que um elemento HTML, definido por sua tag HTML, esteja presenta na página.\nVerificando elementos da página Verificar os elementos de UI em uma página da web é provavelmente o recurso mais comum dos seus testes automatizados. Selenese permite várias maneiras de verificar os elementos de UI. É importante que você entenda esses métodos diferentes porque eles definem o que você está realmente testando.\nPor exemplo, você vai testar se\u0026hellip;\n um elemento está presente em algum lugar da página? um texto específico está em algum lugar da página? um texto específico está em um local específico na página?  Por exemplo, se você estiver testando um título de texto, o texto e sua posição na parte superior da página provavelmente são relevantes para o seu teste. Se, no entanto, você está testando a existência de uma imagem na página inicial, e os web designers frequentemente alteram o arquivo de imagem específico junto com sua posição na página, então você só quer testar se uma imagem (em oposição à um arquivo de imagem específico) existe em algum lugar.\nAsserção ou Verificação? Escolher entre \u0026ldquo;assert\u0026rdquo; e \u0026ldquo;verify\u0026rdquo; se resume à conveniência e gerenciamento de falhas. Não vale a pena verificar se o primeiro parágrafo da página é correto se o seu teste já falhou ao verificar se o navegador está exibindo a página esperada. Se você não estiver na página correta, você provavelmente vai querer abortar seu caso de teste para poder investigar a causa e corrigir o(s) problema(s) imediatamente. Por outro lado, você pode querer verificar muitos atributos de uma página sem abortar o caso de teste na primeira falha pois isso permitirá que você analise todas as falhas na página e tome a ação apropriada. Efetivamente, um \u0026ldquo;assert\u0026rdquo; irá falhar no teste e abortar o caso de teste atual, enquanto um \u0026ldquo;verify\u0026rdquo; irá falhar no teste e continuar a executar o caso de teste.\nO melhor uso desse recurso é agrupar logicamente seus comandos de teste e iniciar cada grupo com um \u0026ldquo;assert\u0026rdquo; seguido por um ou mais comandos de \u0026ldquo;verify\u0026rdquo;. Segue um exemplo:\n   Command Target Value     open /download/    assertTitle  Downloads   verifyText //h2 Downloads   assertTable 1.2.1 Selenium IDE   verifyTable 1.2.2 June 3, 2008   verifyTable 1.2.3 1.0 beta 2    O exemplo acima primeiro abre uma página e, em seguida, faz uma asserção para saber se a página correta é carregada comparando o título com o valor esperado. Só se passar, o seguinte comando será executado e verificará se o texto está presente na localização esperada. O caso de teste, então, faz uma asserção para saber se a primeira coluna na segunda linha da primeira tabela contém o valor esperado, e somente se este for aprovado as células restantes nessa linha serão “verificadas”.\nverifyTextPresent O comando verifyTextPresent é usado para verificar se existe um texto específico em algum lugar na página. Leva um único argumento - o texto a ser verificado. Por exemplo:\n   Command Target Value     verifyTextPresent Marketing Analysis     Isso faria com que o Selenium procurasse e verificasse que a string de texto “Marketing Analysis” aparece em algum lugar na página que está sendo testada. Use verifyTextPresent quando você está interessado apenas no próprio texto estar presente na página. Não use isso quando você também precisa testar onde o texto está na página.\nverifyElementPresent Use este comando quando precisar testar a presença de um elemento de UI específico, em vez de seu conteúdo. Esta verificação não verifica o texto, apenas a tag HTML. Um uso comum é verificar a presença de uma imagem.\n   Command Target Value     verifyElementPresent //div/p/img     Este comando verifica se uma imagem, especificada pela existência de uma tag HTML \u0026lt;img\u0026gt;, está presente na página e aparece após uma tag \u0026lt;div\u0026gt; e uma tag \u0026lt;p\u0026gt;. O primeiro (e único) parâmetro é um localizador para informar o comando Selenese de como encontrar o elemento. Os localizadores são explicados na próxima seção.\nverifyElementPresent pode ser usado para verificar a existência de qualquer tag HTML dentro da página. Você pode verificar a existência de links, parágrafos, divisões \u0026lt;div\u0026gt;, etc. Aqui estão mais alguns exemplos.\n   Command Target Value     verifyElementPresent //div/p    verifyElementPresent //div/a    verifyElementPresent id=Login    verifyElementPresent link=Go to Marketing Research    verifyElementPresent //a[2]    verifyElementPresent //head/title     Esses exemplos ilustram a variedade de maneiras pelas quais um elemento de UI pode ser testado. Novamente, os localizadores são explicados na próxima seção.\nverifyText Use verifyText quando o texto e seu elemento de UI devem ser testados. verifyText deve usar um localizador. Se você escolher um localizador XPath ou DOM, você pode verificar se um texto específico aparece em um local específico na página em relação a outro componente na página.\n   Command Target Value     verifyText //table/tr/td/div/p This is my text and it occurs right after the div inside the table.    Localizando elementos Para muitos comandos do Selenium, um alvo é necessário. Este alvo identifica um elemento no conteúdo do aplicativo da web, e consiste na estratégia de localização seguida pela localização no formato locatorType = location. O tipo de localizador pode ser omitido em muitos casos. Os vários tipos de localizadores são explicados abaixo com exemplos para cada um.\nLocalizando pelo Identificador Este é provavelmente o método mais comum de localização de elementos e é o padrão quando nenhum tipo de localizador reconhecido é usado. Com esta estratégia, o primeiro elemento com o valor do atributo id correspondente ao local será usado. E se nenhum elemento tem um atributo id correspondente, então o primeiro elemento com um atributo name correspondente ao local será usado.\nPor exemplo, o código fonte da sua página pode ter atributos id e name do seguinte modo:\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt; As seguintes estratégias de localização retornariam os elementos do HTML acima indicado pelo número da linha:\n identifier=loginForm (3) identifier=password (5) identifier=continue (6) continue (6)  Como o tipo de localizador identifier é o padrão, o identifier = nos primeiros três exemplos acima não é necessário.\nLocalizando pelo id Este tipo de localizador é mais limitado do que o tipo Localizador por Identificador, mas também mais explícito. Use isto quando você souber o atributo id de um elemento.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  id=loginForm (3)  Localizando pelo name O tipo Localizador de Nome irá localizar o primeiro elemento com um atributo name correspondente. Se vários elementos tiverem o mesmo valor para um atributo name, então você pode usar filtros para refinar ainda mais sua estratégia de localização. O tipo de filtro padrão é value (correspondendo ao atributo value).\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  name=username (4) name=continue value=Clear (7) name=continue Clear (7) name=continue type=button (7)  Nota: Ao contrário de alguns tipos de localizadores XPath e DOM, os três tipos de localizadores acima permitem que o Selenium teste um elemento de UI independente de sua localização em a página. Portanto, se a estrutura e a organização da página forem alteradas, o teste ainda vai passar. Você pode ou não querer também testar se a página tem mudanças de estrutura. No caso em que os web designers frequentemente alteram a página, mas sua funcionalidade deve ser testada por regressão, testando via id e atributos de nome, ou realmente através de qualquer propriedade HTML, torna-se muito importante.\nLocalizando pelo XPath XPath é a linguagem usada para localizar nós em um documento XML. Como o HTML pode ser uma implementação de XML (XHTML), os usuários do Selenium podem aproveitar esta poderosa linguagem para encontrar elementos em seus aplicativos da web. XPath vai além (bem como apoia) os métodos simples de localização por atributos id ou name e abre todos os tipos de novas possibilidades, como localizar a terceira caixa de seleção na página.\nUma das principais razões para usar XPath é quando você não tem um id adequado ou atributo de nome para o elemento que você deseja localizar. Você pode usar XPath para localizar o elemento em termos absolutos (não recomendado) ou em relação a um elemento que possui um atributo id ou name. Localizadores XPath também podem ser usados para especificar elementos por meio de atributos diferentes de id e name.\nOs XPaths absolutos contêm a localização de todos os elementos da raiz (html) e como resultado, é provável que falhe com apenas o menor ajuste na aplicação. Ao encontrar um elemento próximo com um atributo id ou name (de preferência um elemento pai), você pode localizar seu elemento de destino com base no relacionamento. É muito menos provável que isso mude e pode tornar seus testes mais robustos.\nUma vez que apenas os localizadores xpath começam com \u0026ldquo;//\u0026quot;, não é necessário incluir o rótulo xpath= ao especificar um localizador XPath.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  xpath=/html/body/form[1] (3) - Caminho absoluto (seria quebrado se o HTML sofresse qualquer pequena mudança) //form[1] (3) - Primeiro elemento \u0026lt;form\u0026gt; no HTML xpath=//form[@id='loginForm'] (3) - O elemento \u0026lt;form\u0026gt; com o atributo \u0026lsquo;id\u0026rsquo; e o valor \u0026lsquo;loginForm\u0026rsquo; xpath=//form[input/@name='username'] (3) - Primeiro elemento \u0026lt;form\u0026gt; com um elemento filho \u0026lt;input\u0026gt; com o atributo \u0026lsquo;name\u0026rsquo; e o valor \u0026lsquo;username\u0026rsquo; //input[@name='username'] (4) - Primeiro elemento \u0026lt;input\u0026gt; com o atributo \u0026lsquo;name\u0026rsquo; e o valor \u0026lsquo;username\u0026rsquo; //form[@id='loginForm']/input[1] (4) - Primeiro elemento filho \u0026lt;input\u0026gt; do elemento \u0026lt;form\u0026gt; com o atributo \u0026lsquo;id\u0026rsquo; e o valor \u0026lsquo;loginForm\u0026rsquo; //input[@name='continue'][@type='button'] (7) - \u0026lt;input\u0026gt; com o atributo \u0026lsquo;name\u0026rsquo; e o valor \u0026lsquo;continue\u0026rsquo; e o atributo \u0026lsquo;type\u0026rsquo; e o valor \u0026lsquo;button\u0026rsquo; //form[@id='loginForm']/input[4] (7) - Quarto elemento filho \u0026lt;input\u0026gt; do elemento \u0026lt;form\u0026gt; com atributo \u0026lsquo;id\u0026rsquo; e valor \u0026lsquo;loginForm\u0026rsquo;  Esses exemplos cobrem alguns princípios básicos, mas para aprender mais, as seguintes referências são recomendadas:\n W3Schools XPath Tutorial W3C XPath Recommendation  Existem também alguns complementos do Firefox muito úteis que podem ajudar a descobrir o XPath de um elemento:\n XPath Checker - Pode ser usado para testar os resultados do XPath. Firebug - Sugestões de XPath é apenas um dos muitos recursos poderosos deste complemento muito útil.  Localizando hyperlinks pelo texto do link Este é um método simples de localizar um hiperlink em sua página da web usando o texto do link. Se dois links com o mesmo texto estiverem presentes, então a primeira correspondência será usada.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Are you sure you want to do this?\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;continue.html\u0026#34;\u0026gt;Continue\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;cancel.html\u0026#34;\u0026gt;Cancel\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  link=Continue (4) link=Cancel (5)  Localizando pelo DOM O Document Object Model representa um documento HTML e pode ser acessado usando JavaScript. Esta estratégia de localização usa um JavaScript que representa um elemento na página, que pode ser simplesmente a localização do elemento usando a notação hierárquica.\nUma vez que apenas os localizadores dom começam com \u0026ldquo;document\u0026rdquo;, não é necessário incluir o rótulo dom= ao especificar um localizador DOM.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  dom=document.getElementById('loginForm') (3) dom=document.forms['loginForm'] (3) dom=document.forms[0] (3) document.forms[0].username (4) document.forms[0].elements['username'] (4) document.forms[0].elements[0] (4) document.forms[0].elements[3] (7)  Você pode usar o próprio Selenium, bem como outros sites e extensões para explorar o DOM do seu aplicativo da web. Uma boa referência é a W3Schools.\nLocalizando pelo CSS CSS (Cascading Style Sheets) é uma linguagem para descrever a renderização de HTML e documentos XML. CSS usa seletores para vincular propriedades de estilo a elementos no documento. Esses seletores podem ser usados pelo Selenium como outra estratégia de localização.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input class=\u0026#34;required\u0026#34; name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input class=\u0026#34;required passfield\u0026#34; name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  css=form#loginForm (3) css=input[name=\u0026quot;username\u0026quot;] (4) css=input.required[type=\u0026quot;text\u0026quot;] (4) css=input.passfield (5) css=#loginForm input[type=\u0026quot;button\u0026quot;] (7) css=#loginForm input:nth-child(2) (5)  Para obter mais informações sobre seletores CSS, o melhor lugar para ir é a publicação do W3C. Você encontrará todas as referências lá.\nLocalizadores implícitos Você pode optar por omitir o tipo de localizador nas seguintes situações:\n  Localizadores sem uma estratégia de localização explicitamente definida utilizará a estratégia de localização padrão. Veja Localizando pelo Identificador.\n  Localizadores começando com \u0026ldquo;//\u0026rdquo; usarão a estratégia de localização XPath. Veja Localizando pelo XPath.\n  Os localizadores que começam com \u0026ldquo;document\u0026rdquo; usarão a estratégia do localização DOM. Veja Localizando pelo DOM\n  Padrões de texto Como os localizadores, padrões são um tipo de parâmetro frequentemente exigido pelos comandos Selenese. Exemplos de comandos que exigem padrões são verifyTextPresent, verifyTitle, verifyAlert, assertConfirmation, verifyText, e verifyPrompt. E como foi mencionado acima, os localizadores de link podem utilizar um padrão. Os padrões permitem que você descreva, por meio do uso de caracteres especiais, qual texto é esperado em vez de precisar especificar esse texto exatamente.\nExistem três tipos de padrões: globbing, expressões regulares e exato.\nPadrão de Globbing A maioria das pessoas está familiarizada com o uso de globbing em expansão de nome de arquivo em uma linha de comando DOS ou Unix / Linux como ls * .c. Neste caso, globbing é usado para exibir todos os arquivos no diretório atual que terminam com uma extensão .c. Globbing é bastante limitado. Apenas dois caracteres especiais são suportados na implementação do Selenium:\n* que é traduzido como \u0026ldquo;corresponder a qualquer coisa\u0026rdquo;, ou seja, nada, um único caractere ou muitos caracteres.\n[ ] (classe de caracteres) que é traduzido como \u0026ldquo;corresponder a qualquer caractere dentro dos colchetes.\u0026rdquo; Um travessão (hífen) pode ser usado como uma abreviação para especificar um intervalo de caracteres (que são contíguos no conjunto ASCII). Alguns exemplos tornarão clara a funcionalidade de uma classe de caracteres:\n[aeiou] corresponde a qualquer vogal minúscula\n[0-9] corresponde a qualquer dígito\n[a-zA-Z0-9] corresponde a qualquer caractere alfanumérico\nNa maioria dos outros contextos, globbing inclui um terceiro caractere especial, o ?. No entanto, os padrões de globbing do Selenium suportam apenas o asterisco e a classe de caracteres.\nPara especificar um parâmetro de padrão globbing para um comando Selenese, você pode prefixar o padrão com um rótulo glob:. No entanto, já que o padrão globbing é o padrão, você também pode omitir o rótulo e especificar apenas o padrão em si.\nAbaixo está um exemplo de dois comandos que usam padrões globbing. O texto real do link na página que está sendo testada foi \u0026ldquo;Film/Television Department\u0026rdquo;; usando um padrão em vez do texto exato, o comando click funcionará mesmo se o o texto do link for alterado para \u0026ldquo;Film \u0026amp; Television Department\u0026rdquo; ou \u0026ldquo;Film and Television Department\u0026rdquo;. O asterisco do padrão glob corresponderá a \u0026ldquo;qualquer coisa ou nada\u0026rdquo; entre a palavra \u0026ldquo;Film\u0026rdquo; e a palavra \u0026ldquo;Television\u0026rdquo;.\n   Command Target Value     click link=glob:Film*Television Department    verifyTitle glob:*Film*Television*     O título real da página acessada clicando no link era \u0026ldquo;De Anza Film And Television Department - Menu\u0026rdquo;. Usando um padrão em vez do texto exato, o verifyTitle vai passar enquanto as duas palavras \u0026ldquo;Film\u0026rdquo; e \u0026ldquo;Television\u0026rdquo; aparecerem (nessa ordem) em qualquer lugar no título da página. Por exemplo, se o proprietário da página encurtar o título apenas para \u0026ldquo;Film \u0026amp; Television Department\u0026rdquo;, o teste ainda seria aprovado. Usar um padrão para um link e um teste simples de que o link funcionou (como o verifyTitle acima faz) pode reduzir bastante a manutenção de tais casos de teste.\nPadrão de Expressões Regulares Os padrões de expressão regular são os mais poderosos dos três tipos de padrões que o Selenese suporta. Expressões regulares também são suportados pela maioria das linguagens de programação de alto nível, muitos editores de texto e uma série de ferramentas, incluindo utilitários grep, sed e awk da linha de comando Linux / Unix. Em Selenese, padrões de expressão regular permitem que um usuário execute muitas tarefas que iriam ser muito difíceis de outra forma. Por exemplo, suponha que seu teste precise garantir que uma determinada célula da tabela contivesse nada além de um número. regexp:[0-9]+ é um padrão simples que corresponderá a um número decimal de qualquer comprimento.\nEnquanto os padrões de Globbing do Selenese suportam apenas o * e [ ] (classe de caracteres), os padrões de expressão regular Selenese oferecem a mesma ampla gama de caracteres especiais que existem em JavaScript. Abaixo está um subconjunto desses caracteres especiais:\n   PATTERN MATCH     . qualquer caractere isolado   [ ] classe de caracteres: qualquer caractere definido dentros dos colchetes   * quantificação: 0 ou mais do caractere anterior (ou grupo)   + quantificação: 1 ou mais do caractere anterior (ou grupo)   ? quantificação: 0 ou 1 do caractere anterior (ou grupo)   {1,5} quantificação: 1 até 5 repetições do caractere anterior (ou grupo)   | alternação: o caractere/grupo na esquerda OU o caractere/grupo na direita   ( ) agrupamento: normalmente usado com alternação e/ou quantificação    Os padrões de expressão regular em Selenese precisam ser prefixados com regexp: ou regexpi:. O primeiro é sensível a maiúsculas e minúsculas; o último não faz distinção entre maiúsculas e minúsculas.\nAlguns exemplos ajudarão a esclarecer como os padrões de expressão regular podem ser usados com comandos Selenese. O primeiro usa o que é provavelmente o padrão de expressão regular mais comumente usado - .* (\u0026ldquo;ponto estrela\u0026rdquo;). Esta sequência de dois caracteres pode ser traduzida como \u0026ldquo;0 ou mais ocorrências de qualquer caractere\u0026rdquo; ou, mais simplesmente, \u0026ldquo;qualquer coisa ou nada.\u0026rdquo; É o equivalente do padrão globbing de um caractere * (um único asterisco).\n   Command Target Value     click link=glob:Film*Television Department    verifyTitle regexp:.*Film.*Television.*     O exemplo acima é funcionalmente equivalente ao exemplo anterior que usou padrões de globbing para este mesmo teste. As únicas diferenças são o prefixo (regexp: em vez de glob:) e o padrão \u0026ldquo;qualquer coisa ou nada\u0026rdquo; (.* em vez de apenas *).\nO exemplo mais complexo abaixo testa que a página de clima do Yahoo! para Anchorage, Alasca, contém informações sobre o horário do nascer do sol:\n   Command Target Value     open http://weather.yahoo.com/forecast/USAK0012.html    verifyTextPresent regexp:Sunrise: *[0-9]{1,2}:[0-9]{2} [ap]m     Vamos examinar a expressão regular acima em partes:\n         Sunrise: * A string Sunrise: seguida por 0 ou mais espaços   [0-9]{1,2} 1 ou 2 dígitos (para a hora do dia)   : O caractere : (sem caracteres especiais envolvidos)   [0-9]{2} 2 dígitos (para os minutos) seguidos de um espaço   [ap]m \u0026ldquo;a\u0026rdquo; ou \u0026ldquo;p\u0026rdquo; seguido por \u0026ldquo;m\u0026rdquo; (am ou pm)    Padrão Exato O tipo de padrão exato do Selenium é de utilidade marginal. Ele não usa nenhum caractere especial. Então, se você precisasse procurar um caractere de asterisco real (que é especial para globbing e padrões de expressão regular), o padrão exato seria uma maneira fazer isso. Por exemplo, se você quiser selecionar um item rotulado \u0026ldquo;Real*\u0026rdquo; em uma lista suspensa, o código a seguir pode funcionar ou não. O asterisco no padrão glob:Real* irá corresponder a qualquer coisa ou a nada. Portanto, se houvesse uma opção de seleção anterior rotulada \u0026ldquo;Números reais\u0026rdquo;, ser a opção selecionada em vez da opção \u0026ldquo;Real*\u0026quot;.\n   Command Target Value     select //select glob:Real *    A fim de garantir que o item \u0026ldquo;Real*\u0026rdquo; seja selecionado, o prefixo exact: pode ser usado para criar um padrão exato conforme mostrado abaixo:\n   Command Target Value     select //select exact:Real *    Mas o mesmo efeito pode ser alcançado escapando o asterisco em um padrão de expressão regular:\n   Command Target Value     select //select regexp:Real \\*    É bastante improvável que a maioria dos testadores precise procurar um asterisco ou um conjunto de colchetes com caracteres dentro deles (a classe de caracteres para padrões globbing). Assim, os padrões de globbing e os padrões de expressão regular são suficientes para a grande maioria de nós.\nOs comandos \u0026ldquo;AndWait\u0026rdquo; A diferença entre um comando e sua alternativa AndWait é que o comando regular (por exemplo, click) fará a ação e continuará com o seguinte comando o mais rápido possível, enquanto a alternativa AndWait (por exemplo, clickAndWait) diz ao Selenium para esperar que a página carregue após a ação ter sido realizada.\nA alternativa AndWait é sempre usada quando a ação faz com que o navegador navegue para outra página ou recarregue a atual.\nEsteja ciente, se você usar um comando AndWait para uma ação que não aciona uma navegação/atualização, seu teste falhará. Isto acontece porque o Selenium alcançará o timeout de AndWait sem ver nenhuma navegação ou atualização sendo feita, fazendo com que o Selenium lance uma exceção de timeout.\nOs comandos waitFor em aplicações Ajax Em aplicações web orientadas a AJAX, os dados são recuperados do servidor sem atualização da página. Usar os comandos AndWait não funcionará porque a página não é realmente atualizada. Pausar a execução do teste por um determinado período de tempo também não é uma boa abordagem, pois o elemento da web pode aparecer mais tarde ou antes do período estipulado dependendo da capacidade de resposta do sistema, carga ou outros fatores descontrolados do momento, levando a falhas de teste. A melhor abordagem seria esperar pelo elemento necessário em um período dinâmico e então continuar a execução assim que o elemento for encontrado.\nIsso é feito usando comandos waitFor, como waitForElementPresent ou waitForVisible, que espera dinamicamente, verificando a condição desejada a cada segundo e continuando para o próximo comando no script assim que a condição for atendida.\nSequências de avaliação e controle de fluxo Quando um script é executado, ele simplesmente é executado em sequência, um comando após o outro.\nSelenese, por si só, não suporta declarações de condição (if-else, etc.) ou iteração (for, while, etc.). Muitos testes úteis podem ser realizados sem fluxo de controle. No entanto, para um teste funcional de conteúdo dinâmico, possivelmente envolvendo múltiplas páginas, a lógica de programação é frequentemente necessária.\nQuando o controle de fluxo é necessário, existem três opções:\na) Execute o script usando Selenium-RC e uma biblioteca cliente, como Java ou PHP para utilizar os recursos de controle de fluxo da linguagem de programação.\nb) Execute um pequeno fragmento de JavaScript de dentro do script usando o comando storeEval.\nc) Instale a extensão goto_sel_ide.js.\nA maioria dos testadores exportará o script de teste para um arquivo de linguagem de programação que usa a API Selenium-RC (consulte o capítulo Selenium-IDE). No entanto, algumas organizações preferem executar seus scripts a partir do Selenium-IDE sempre que possível (por exemplo, quando eles têm muitas pessoas de nível júnior executando testes para eles, ou quando as habilidades de programação estão em falta). Se este for o seu caso, considere um snippet de JavaScript ou a extensão goto_sel_ide.js.\nComandos de armazenamento e variáveis Selenium Você pode usar variáveis Selenium para armazenar constantes no início de um script. Além disso, quando combinado com um design de teste baseado em dados (discutido em uma seção posterior), as variáveis Selenium podem ser usadas para armazenar valores passados para o seu programa de teste da linha de comando, de outro programa ou de um arquivo.\nO comando store é o mais básico dos muitos comandos de armazenamento e pode ser usado para simplesmente armazenar um valor constante em uma variável Selenium. Leva dois parâmetros, o valor do texto a ser armazenado e uma variável Selenium. Use as convenções de nomenclatura de variável padrão de apenas caracteres alfanuméricos quando escolher um nome para sua variável.\n   Command Target Value     store paul@mysite.org     Posteriormente em seu script, você desejará usar o valor armazenado de sua variável. Para acessar o valor de uma variável, coloque a variável em colchetes ({}) e preceda-a com um cifrão como a seguir.\n   Command Target Value     verifyText //div/p \\${userName}    Um uso comum de variáveis é armazenar a entrada para um campo input.\n   Command Target Value     type id=login \\${userName}    Variáveis Selenium podem ser usadas no primeiro ou segundo parâmetro e são interpretadas pelo Selenium antes de quaisquer outras operações realizadas pelo comando. Uma variável Selenium também pode ser usada em uma expressão de localização.\nExiste um comando de armazenamento equivalente para cada comando de verificação e asserção. Aqui são alguns comandos de armazenamento mais comumente usados.\nstoreElementPresent Isso corresponde a verifyElementPresent. Ele simplesmente armazena um valor booleano - \u0026ldquo;true\u0026rdquo; ou \u0026ldquo;false\u0026rdquo; - dependendo se o elemento de UI for encontrado.\nstoreText StoreText corresponde a verifyText. Ele usa um localizador para identificar um texto específico na página. O texto, se encontrado, é armazenado na variável. StoreText pode ser usado para extrair texto da página que está sendo testada.\nstoreEval Este comando leva um script como seu primeiro parâmetro. A incorporação de JavaScript no Selenese é abordada na próxima seção. StoreEval permite que o teste armazene o resultado da execução do script em uma variável.\nJavaScript e parâmetros Selenese JavaScript pode ser usado com dois tipos de parâmetros Selenese: script e não-script (geralmente expressões). Na maioria dos casos, você deseja acessar e/ou manipular uma variável de caso de teste dentro do snippet JavaScript usado como um parâmetro Selenese. Todas as variáveis criadas em seu caso de teste são armazenadas em um array associativo JavaScript. Uma matriz associativa tem índices de string em vez de índices numéricos sequenciais. A matriz associativa contendo as variáveis do seu caso de teste é chamada storedVars. Sempre que você quiser acessar ou manipular uma variável em um snippet de JavaScript, você deve consultá-la como storedVars[\u0026lsquo;yourVariableName\u0026rsquo;].\nUsando JavaScript com parâmetros de script Vários comandos Selenese especificam um parâmetro script incluindo assertEval, verifyEval, storeEval e waitForEval. Esses parâmetros não requerem sintaxe especial. Um usuário da Selenium-IDE simplesmente colocaria um snippet de código JavaScript no campo apropriado, normalmente o campo Target (porque um parâmetro script é normalmente o primeiro ou único parâmetro).\nO exemplo abaixo ilustra como um snippet de JavaScript pode ser usado para realizar um cálculo numérico simples:\n   Command Target Value     store 10 hits   storeXpathCount //blockquote blockquotes   storeEval storedVars[\u0026lsquo;hits\u0026rsquo;].storedVars[\u0026lsquo;blockquotes\u0026rsquo;] paragraphs    Este próximo exemplo ilustra como um snippet de JavaScript pode incluir chamadas para métodos, neste caso, os métodos toUpperCase e toLowerCasedo objeto JavaScript String.\n   Command Target Value     store Edith Wharton name   storeEval storedVars[\u0026lsquo;name\u0026rsquo;].toUpperCase() uc   storeEval storedVars[\u0026lsquo;name\u0026rsquo;].toUpperCase() lc    Usando JavaScript com parâmetros não-script JavaScript também pode ser usado para ajudar a gerar valores para parâmetros, mesmo quando o parâmetro não é especificado para ser do tipo script. No entanto, neste caso, uma sintaxe especial é necessária - o parâmetro inteiro deve ser prefixado por javascript{ com um } final, que envolve o snippet JavaScript, como em javascript{*yourCodeHere*}. Abaixo está um exemplo em que o segundo parâmetro do comando type\n value - é gerado através do código JavaScript usando esta sintaxe especial:     Command Target Value     store league of nations searchString   type q javascript{storedVars[\u0026lsquo;searchString\u0026rsquo;].toUpperCase()}    echo - O comando de print do Selenese Selenese tem um comando simples que permite imprimir texto para a saída do seu teste. Isso é útil para fornecer notas de progresso informativas em seu teste que são exibidas no console durante a execução. Essas notas também podem ser usadas para fornecer contexto em seus relatórios de resultados de teste, o que pode ser útil para descobrir onde existe um defeito em uma página, caso seu teste encontre um problema. Finalmente, declarações echo podem ser usadas para imprimir o conteúdo de variáveis Selenium.\n   Command Target Value     echo Testing page footer now.    echo Username is \\${userName}     Alertas, Popups e Múltiplas Janelas Suponha que você esteja testando uma página semelhante a esta.\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function output(resultText){ document.getElementById(\u0026#39;output\u0026#39;).childNodes[0].nodeValue=resultText; } function show_confirm(){ var confirmation=confirm(\u0026#34;Chose an option.\u0026#34;); if (confirmation==true){ output(\u0026#34;Confirmed.\u0026#34;); } else{ output(\u0026#34;Rejected!\u0026#34;); } } function show_alert(){ alert(\u0026#34;I\u0026#39;m blocking!\u0026#34;); output(\u0026#34;Alert is gone.\u0026#34;); } function show_prompt(){ var response = prompt(\u0026#34;What\u0026#39;s the best web QA tool?\u0026#34;,\u0026#34;Selenium\u0026#34;); output(response); } function open_window(windowName){ window.open(\u0026#34;newWindow.html\u0026#34;,windowName); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnConfirm\u0026#34; onclick=\u0026#34;show_confirm()\u0026#34; value=\u0026#34;Show confirm box\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnAlert\u0026#34; onclick=\u0026#34;show_alert()\u0026#34; value=\u0026#34;Show alert\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnPrompt\u0026#34; onclick=\u0026#34;show_prompt()\u0026#34; value=\u0026#34;Show prompt\u0026#34; /\u0026gt; \u0026lt;a href=\u0026#34;newWindow.html\u0026#34; id=\u0026#34;lnkNewWindow\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;New Window Link\u0026lt;/a\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnNewNamelessWindow\u0026#34; onclick=\u0026#34;open_window()\u0026#34; value=\u0026#34;Open Nameless Window\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnNewNamedWindow\u0026#34; onclick=\u0026#34;open_window(\u0026#39;Mike\u0026#39;)\u0026#34; value=\u0026#34;Open Named Window\u0026#34; /\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;span id=\u0026#34;output\u0026#34;\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; O usuário deve responder às caixas de alerta / confirmação, bem como mover o foco para as novas janelas pop-up abertas. Felizmente, o Selenium pode cobrir pop-ups de JavaScript.\nMas antes de começarmos a abordar alertas / confirmações / solicitações em detalhes individuais, é útil compreender a semelhança entre eles. Alertas, caixas de confirmação e todos os prompts têm variações do seguinte\n   Command Description     assertFoo(pattern) gera erro se o padrão não corresponder ao texto do pop-up   assertFooPresent gera erro se o pop-up estiver presente   assertFooNotPresent gera um erro se algum pop-up não estiver presente   storeFoo(variable) armazena o texto do pop-up em uma variável   storeFooPresent(variable) armazena o texto do pop-up em uma variável e retorna verdadeiro ou falso    Ao executar no Selenium, pop-ups de JavaScript não aparecerão. Isto é porque as chamadas de função são realmente substituídas em tempo de execução pelo próprio JavaScript do Selenium. No entanto, só porque você não pode ver o pop-up, não significa que você não tem que lidar com isso. Para lidar com um pop-up, você deve chamar sua função assertFoo(padrão). Se você falhar em fazer a asserção da presença de um pop-up, seu próximo comando será bloqueado e você obterá um erro semelhante ao seguinte [error] Error: There was an unexpected Confirmation! [Chose an option.]\nAlertas Vamos começar com alertas porque eles são os pop-ups mais simples de lidar. Para começar, abra o exemplo de HTML acima em um navegador e clique no botão \u0026ldquo;Show alert\u0026rdquo;. Você vai observar que, depois de fechar o alerta, o texto \u0026ldquo;Alert is gone.\u0026rdquo; é exibido na página. Agora execute as mesmas etapas com a gravação da Selenium IDE e verifique que o texto é adicionado após fechar o alerta. Seu teste será parecido com este:\n   Command Target Value     open /    click btnAlert    assertAlert I’m blocking!    verifyTextPresent Alert is gone.     Você pode estar pensando: \u0026ldquo;Isso é estranho, nunca tentei fazer uma asserção nesse alerta.\u0026rdquo; Mas isso é a Selenium-IDE manipulando e fechando o alerta para você. Se você remover essa etapa e repetir o teste você obterá o seguinte erro [error] Error: There was an unexpected Alert! [I'm blocking!]. Você deve incluir uma asserção do alerta para reconhecer sua presença.\nSe você apenas deseja verificar que um alerta está presente, mas não sabe ou não se importa o texto que ele contém, você pode usar assertAlertPresent. Isso retornará verdadeiro ou falso, sendo que falso faz o teste parar.\nConfirmações As confirmações se comportam da mesma forma que os alertas, com assertConfirmation e assertConfirmationPresent oferecendo as mesmas características de suas contrapartes de alerta. No entanto, por padrão, o Selenium selecionará OK quando uma confirmação for exibida. Tente gravar clicando no botão \u0026ldquo;Show confirm box\u0026rdquo; na página de amostra, mas clique no botão \u0026ldquo;Cancel\u0026rdquo; no pop-up e, em seguida, confirme o texto de saída. Seu teste pode ser semelhante a este:\n   Command Target Value     open /    click btnConfirm    chooseCancelOnNextConfirmation     assertConfirmation Choose an option.    verifyTextPresent Rejected     A função chooseCancelOnNextConfirmation diz ao Selenium que todas as seguintes confirmações devem retornar falso. Ela pode ser redefinido chamando chooseOkOnNextConfirmation.\nVocê vai notar que não pode repetir este teste, porque o Selenium reclama que há uma confirmação não tratada. Isso ocorre porque a ordem dos registros de eventos do Selenium-IDE faz com que o clique e chooseCancelOnNextConfirmation sejam colocados na ordem errada (faz sentido se você pensar sobre isso, o Selenium não pode saber que você está cancelando antes de abrir uma confirmação). Simplesmente troque esses dois comandos e seu teste funcionará bem.\nPrompts Os prompts se comportam da mesma forma que os alertas, com assertPrompt e assertPromptPresent oferecendo as mesmas características que suas contrapartes de alerta. Por padrão, o Selenium irá esperar você inserir dados quando o prompt for exibido. Tente gravar clicando no botão \u0026ldquo;Show prompt\u0026rdquo; na página de amostra e digite \u0026ldquo;Selenium\u0026rdquo; no prompt. Seu teste pode ser semelhante a este:\n   Command Target Value     open /    answerOnNextPrompt Selenium!    click id=btnPrompt    assertPrompt What’s the best web QA tool?    verifyTextPresent Selenium!     Se você escolher \u0026ldquo;Cancel\u0026rdquo; no prompt, poderá observar que answerOnNextPrompt simplesmente mostrará um alvo em branco. Selenium trata o cancelamento e uma entrada em branco no prompt basicamente como a mesma coisa.\nDepuração Depurar significa encontrar e corrigir erros em seu caso de teste. Isso é normal e parte do desenvolvimento.\nNão vamos ensinar depuração aqui, pois a maioria dos novos usuários do Selenium já terá alguma experiência básica com depuração. Se isso for novo para você, recomendamos que você pergunte a um dos desenvolvedores em sua organização.\nPontos de interrupção e pontos de começo O Sel-IDE suporta a configuração de pontos de interrupção e a capacidade de iniciar e interromper a execução de um caso de teste, de qualquer ponto dele. Ou seja, você pode executar até um comando específico no meio do caso de teste e inspecionar como o caso de teste se comporta nesse ponto. Para fazer isso, defina um ponto de interrupção no comando imediatamente antes daquele a ser examinado.\nPara definir um ponto de interrupção, selecione um comando, clique com o botão direito e no menu de contexto selecione Alternar ponto de interrupção (Toggle Breakpoint, em inglês). Em seguida, clique no botão Executar para executar seu caso de teste do início ao ponto de interrupção.\nÀs vezes também é útil executar um caso de teste de algum lugar no meio para o final ou até um ponto de interrupção após o ponto de partida. Por exemplo, suponha que seu caso de teste primeiro faz login no site e depois executa uma série de testes e você está tentando depurar um desses testes. No entanto, você só precisa fazer o login uma vez, mas precisa continuar executando novamente o seu teste conforme você o desenvolve. Você pode fazer o login uma vez e, em seguida, executar seu caso de teste de um ponto de início colocado após a parte de login do seu caso de teste. Isso vai evitar que você tenha que fazer logout manualmente sempre que executar novamente.\nPara definir um ponto de partida, selecione um comando, clique com o botão direito e do contexto no menu selecione Definir / Limpar Ponto Inicial (Set/Clear Start Point, em inglês). Em seguida, clique no botão Executar para executar o caso de teste começando naquele ponto inicial.\nAvançando por etapas em um caso de teste Para executar um caso de teste, um comando de cada vez (\u0026ldquo;percorrê-lo\u0026rdquo;), siga estes passos:\n  Inicie o caso de teste em executando com o botão Executar na barra de ferramentas.\n  Pare imediatamente o caso de teste em execução com o botão Pausar.\n  Selecione repetidamente o botão Etapa.\n  Botão Localizar O botão Localizar é usado para ver qual elemento da interface do usuário atualmente exibido página da web (no navegador) é usado no comando Selenium atualmente selecionado. Isso é útil ao construir um localizador para o primeiro parâmetro de um comando (consulte a seção sobre: ref:locators \u0026lt;locators-section\u0026gt; no capítulo Comandos do Selenium). Ele pode ser usado com qualquer comando que identifica um elemento de UI em uma página da web, ou seja, click, clickAndWait, type e certos comandos assert e verify, entre outros.\nNa visualização de Tabela, selecione qualquer comando que tenha um parâmetro localizador. Clique no botão Localizar. Agora olhe na página da web: deve haver um retângulo verde brilhante envolvendo o elemento especificado pelo parâmetro localizador.\nCódigo Fonte da página para depuração Muitas vezes, ao depurar um caso de teste, você simplesmente deve olhar para o código fonte da página (o HTML da página da web que você está tentando testar) para determinar um problema. O Firefox torna isso mais fácil. Simplesmente clique com o botão direito na página da web e selecione \u0026lsquo;Exibir-\u0026gt; Código-fonte da página. O HTML é aberto em uma janela separada. Use seu recurso de pesquisa (Editar =\u0026gt; Encontrar) para procurar uma palavra-chave para encontrar o HTML do elemento de UI que você está tentando testar.\nComo alternativa, selecione apenas a parte da página da web para a qual deseja ver o código fonte. Em seguida, clique com o botão direito na página da web e selecione Exibir Código Fonte da Seleção. Neste caso, a janela HTML separada conterá apenas uma pequena quantidade de código fonte, com destaque na parte que representa a sua seleção.\nAssistência de localizador Sempre que a Selenium-IDE registra um argumento do tipo localizador, ela armazena informações adicionais que permitem ao usuário visualizar outros possíveis argumentos do tipo localizador que podem ser usados em seu lugar. Este recurso pode ser muito útil para aprender mais sobre localizadores e muitas vezes é necessário para ajudar a construir um tipo de localizador diferente do tipo que foi registrado.\nEsta assistência do localizador é apresentada na janela Selenium-IDE como um menu suspenso acessível na extremidade direita do campo Destino (Target, em inglês) (somente quando o campo Destino contém um argumento do tipo localizador registrado). Abaixo está uma captura de tela mostrando o conteúdo desse menu suspenso para um comando. Observe que a primeira coluna do menu suspenso fornece localizadores alternativos, enquanto a segunda coluna indica o tipo de cada alternativa.\nProgramando uma suíte de testes Uma suíte de testes é uma coleção de casos de teste que é exibida no painel mais à esquerda na IDE. O painel da suíte de testes pode ser aberto ou fechado manualmente selecionando um pequeno ponto no meio da borda direita do painel (que é a borda esquerda da janela inteira da Selenium-IDE se o painel estiver fechado).\nO painel da suíte de testes será aberto automaticamente quando uma suíte de testes existente é aberta ou quando o usuário seleciona o item Novo Caso de Teste (New Test Case, em inglês) no menu Arquivo. Neste último caso, o novo caso de teste aparecerá imediatamente abaixo do caso de teste anterior.\nA Selenium-IDE também suporta o carregamento de casos de teste pré-existentes usando Arquivo -\u0026gt; Adicionar Caso de Teste. Isso permite que você adicione casos de teste existentes a um novo conjunto de testes.\nUm arquivo de suíte de testes é um arquivo HTML que contém uma tabela de uma coluna. Cada célula de cada linha na seção contém um link para um caso de teste. O exemplo abaixo é de um conjunto de testes contendo quatro casos de teste:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Sample Selenium Test Suite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table cellpadding=\u0026#34;1\u0026#34; cellspacing=\u0026#34;1\u0026#34; border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;Test Cases for De Anza A-Z Directory Links\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./a.html\u0026#34;\u0026gt;A Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./b.html\u0026#34;\u0026gt;B Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./c.html\u0026#34;\u0026gt;C Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./d.html\u0026#34;\u0026gt;D Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Observação: os arquivos do caso de teste não devem ser colocados no mesmo local do arquivo do conjunto de testes que os invoca. E em sistemas Mac OS e Linux, esse é realmente o caso. No entanto, no momento em que este livro foi escrito, um bug impedia os usuários do Windows de ser capaz de colocar os casos de teste em outro lugar que não com o conjunto de testes que os invoca.\nExtensões de usuário As extensões de usuário são arquivos JavaScript que permitem criar as suas próprias personalizações e recursos para adicionar funcionalidade adicional. Frequentemente, isso está na forma de comandos personalizados, embora esta extensibilidade não se limite a comandos adicionais.\nExistem várias extensões úteis criadas por usuários.\nIMPORTANTE: ESTA SEÇÃO ESTÁ DESATUALIZADA - REVISAREMOS EM BREVE.\n extensões: http://wiki.openqa.org/display/SEL/Contributed+User-Extensions  Extensão goto_sel_ide.js:\nTalvez a mais popular de todas as extensões da Selenium-IDE é aquela que fornece controle de fluxo na forma de loops while e condicionais primitivas. Esta extensão é a goto_sel_ide.js_. Para um exemplo de como usar a funcionalidade fornecida por esta extensão, veja a página criada pelo autor.\nPara instalar esta extensão, coloque o nome do caminho da extensão em seu computador no campo Selenium Core extensions da Selenium-IDE Opções =\u0026gt; Opções =\u0026gt; Geral.\nDepois de selecionar o botão OK, você deve fechar e reabrir a Selenium-IDE para que o arquivo de extensões seja lido. Qualquer mudança que você fizer em uma extensão também exigirá que você feche e reabra a Selenium-IDE.\nInformações sobre como escrever suas próprias extensões podem ser encontradas perto da parte inferior do documento Selenium Reference.\nÀs vezes, pode ser muito útil depurar passo a passo a Selenium IDE e sua Extensão do usuário. O único depurador que parece capaz de depurar as extensões baseadas em XUL / Chrome é o Venkman, que é suportada no Firefox até a versão 32 (incluída). A depuração passo a passo foi verificada para funcionar com Firefox 32 e Selenium IDE 2.9.0.\nFormato Formato, no menu Opções, permite que você selecione uma linguagem para salvar e exibir o caso de teste. O padrão é HTML.\nSe você for usar Selenium-RC para executar seus casos de teste, este recurso é usado para traduzir seu caso de teste em uma linguagem de programação. Selecione a linguagem, por exemplo Java ou PHP, que você usará com Selenium-RC para o desenvolvimento dos seus programas de teste. Em seguida, simplesmente salve o caso de teste usando Arquivo =\u0026gt; Exportar Caso de Teste Como. Seu caso de teste será traduzido para uma série de funções na linguagem que você escolher. Essencialmente, o código do programa que suporta o seu teste é gerado para você por Selenium-IDE.\nAlém disso, observe que se o código gerado não atender às suas necessidades, você pode alterar editando um arquivo de configuração que define o processo de geração. Cada linguagem com suporte possui definições de configuração que podem ser editadas. Isto está em Opções =\u0026gt; Opções =\u0026gt; Formatos.\nExecutando testes da Selenium-IDE em diferentes navegadores Embora o Selenium-IDE só possa executar testes no Firefox, os testes desenvolvidos com Selenium-IDE podem ser executados em outros navegadores, usando uma interface de linha de comando simples que invoca o servidor Selenium-RC. Este tópico é abordado na seção: ref: Executar testes Selenese \u0026lt;html-suite\u0026gt; no capítulo Selenium-RC. A opção de linha de comando -htmlSuite é o recurso específico de interesse.\nSolução de problemas Abaixo está uma lista de pares de imagem / explicação que descrevem fontes de problemas com Selenium-IDE:\nTable view is not available with this format.\nEsta mensagem pode ser exibida ocasionalmente na guia Tabela quando a Selenium IDE é lançada. A solução alternativa é fechar e reabrir a Selenium IDE. Veja a issue 1008. Para maiores informações. Se você é capaz de reproduzir isso de forma confiável, por favor forneça detalhes para que possamos trabalhar em uma correção.\n error loading test case: no command found\nVocê usou File =\u0026gt; Open para tentar abrir um arquivo de suíte de testes. Use File =\u0026gt; Open Test Suite em vez disso.\nUma solicitação de aprimoramento foi levantada para melhorar esta mensagem de erro. Veja a issue 1010.\n Este tipo de erro pode indicar um problema de tempo, ou seja, o elemento especificado por um localizador em seu comando não foi totalmente carregado quando o comando foi executado. Tente colocar um pause 5000 antes do comando para determinar se o problema está realmente relacionado ao tempo. Em caso afirmativo, investigue usando um comando waitFor* ou *AndWait apropriado antes do comando com falha.\n Sempre que sua tentativa de usar a substituição de variável falha, como é o caso para o comando open acima, isso indica que você não criou realmente a variável cujo valor você está tentando acessar. Isto é às vezes devido a colocar a variável no campo Valor quando deve estar no campo Destino ou vice-versa. No exemplo acima, os dois parâmetros para o comando store foram erroneamente colocados na ordem inversa do que é necessário. Para qualquer comando Selenese, o primeiro parâmetro obrigatório deve ir no campo Destino e o segundo parâmetro obrigatório (se houver) deve ir no campo Valor.\n error loading test case: [Exception\u0026hellip; \u0026ldquo;Component returned failure code: 0x80520012 (NS_ERROR_FILE_NOT_FOUND) [nsIFileInputStream.init]\u0026rdquo; nresult: \u0026ldquo;0x80520012 (NS_ERROR_FILE_NOT_FOUND)\u0026rdquo; location: \u0026ldquo;JS frame :: chrome://selenium-ide/content/file-utils.js :: anonymous :: line 48\u0026rdquo; data: no]\nUm dos casos de teste em seu conjunto de testes não pode ser encontrado. Certifique-se de que o caso de teste está realmente localizado onde o conjunto de testes indica que ele está localizado. Além disso, certifique-se de que seus arquivos de caso de teste tenham a extensão .html em seus nomes de arquivo e no arquivo de suíte de testes onde são referenciados.\nUma solicitação de aprimoramento foi levantada para melhorar esta mensagem de erro. Veja a issue 1011.\n O conteúdo do seu arquivo de extensão não foi lido pela Selenium-IDE. Certifique-se de ter especificado o nome do caminho adequado para o arquivo de extensões via Options =\u0026gt; Options =\u0026gt; General no campo Selenium Core extensions. Além disso, a Selenium-IDE deve ser reiniciada após qualquer alteração em um arquivo de extensões ou no conteúdo do campo Selenium Core extensions.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/mock_external_services/","title":"Simulação de serviços externos","tags":[],"description":"","content":"Eliminar as dependências de serviços externos melhorará muito a velocidade e estabilidade de seus testes.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/introduction/about_this_documentation/","title":"Sobre esta documentação","tags":[],"description":"","content":"Essa documentação, como o próprio código, são mantidos 100% por voluntários dentro da comunidade Selenium. Muitos têm usado desde o seu início, mas muitos mais o usam há pouco tempo, e dedicaram seu tempo para ajudar a melhorar a experiência de integração para novos usuários.\nSe houver algum problema com a documentação, queremos saber! A melhor maneira de comunicar um problema é visitar https://github.com/seleniumhq/seleniumhq.github.io/issues e pesquise se o problema já foi ou não arquivado. Se não, fique à vontade para abrir um!\nMuitos membros da comunidade frequentam o canal IRC #selenium em irc.freenode.net. Sinta-se à vontade para entrar e fazer perguntas e se você receber ajuda que você acha que poderia ser útil nessa documentação, certifique-se de adicionar sua contribuição! Podemos atualizar essa documentação, mas é muito mais fácil para todos quando recebemos contribuições de fora dos committers normais.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/support_classes/","title":"Classes de suporte","tags":[],"description":"","content":"As classes de suporte do WebDriver são fornecidas para simplificar a manutenção do seu código. Eles fornecem uma boa abstração para fazer a modelagem de elemento(s) HTML como objetos de domínio mais fáceis, também fornecendo métodos auxiliares para tornar o uso de tais objetos fácil de se pensar. Vamos aprender sobre:\n Estratégias de localizador Eventos LoadableComponent ThreadGuard etc.  Vamos começar:\nThreadGuard  Esta classe está disponível apenas no Java Binding\n ThreadGuard verifica se um driver é chamado apenas da mesma thread que o criou. Problemas de threading, especialmente durante a execução de testes em paralelo, podem ter erros misteriosos e difíceis de diagnosticar. Usar este wrapper evita esta categoria de erros e gerará uma exceção quando isso acontecer.\nO exemplo a seguir simula um conflito de threads:\npublic class DriverClash { //thread main (id 1) criou este driver  private WebDriver protectedDriver = ThreadGuard.protect(new ChromeDriver()); static { System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;\u0026lt;Set path to your Chromedriver\u0026gt;\u0026#34;); } //Thread-1 (id 24) está chamando o mesmo driver causando o conflito  Runnable r1 = () -\u0026gt; {protectedDriver.get(\u0026#34;https://selenium.dev\u0026#34;);}; Thread thr1 = new Thread(r1); void runThreads(){ thr1.start(); } public static void main(String[] args) { new DriverClash().runThreads(); } } O resultado mostrado abaixo:\nException in thread \u0026#34;Thread-1\u0026#34; org.openqa.selenium.WebDriverException: Thread safety error; this instance of WebDriver was constructed on thread main (id 1)and is being accessed by thread Thread-1 (id 24) This is not permitted and *will* cause undefined behaviour Conforme visto no exemplo:\n protectedDriver será criado no tópico principal Usamos Java Runnable para ativar um novo processo e uma nova Thread para executar o processo Ambas as Threads entrarão em conflito porque a thread principal não tem protectedDriver em sua memória. ThreadGuard.protect lançará uma exceção.  Nota: Isso não substitui a necessidade de usar ThreadLocal para gerenciar drivers durante a execução em paralelo.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/worst_practices/test_dependency/","title":"Dependência entre testes","tags":[],"description":"","content":"Uma ideia comum e um equívoco sobre o teste automatizado é sobre uma ordem de testes específica. Seus testes devem ser executados em qualquer ordem, e não depender da conclusão de outros testes para ter sucesso.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/improved_reporting/","title":"Relatórios melhorados","tags":[],"description":"","content":"O Selenium não foi projetado para relatar sobre o status de casos de teste. Aproveitar os recursos de relatórios integrados de frameworks de teste unitários é um bom começo. A maioria dos frameworks de teste unitários podem gerar relatórios formatados em xUnit ou HTML. Relatórios xUnit são populares para importar resultados para um servidor de integração contínua (CI) como Jenkins, Travis, Bamboo, etc. Aqui estão alguns links para obter mais informações sobre resultados de relatórios em vários idiomas.\nNUnit 3 Console Runner\nNUnit 3 Console Command Line\nxUnit getting test results in TeamCity\nxUnit getting test results in CruiseControl.NET\nxUnit getting test results in Azure DevOps\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/","title":"WebDriver","tags":[],"description":"","content":"WebDriver O WebDriver manipula um navegador nativamente, como um usuário faria, seja localmente ou em uma máquina remota usando o servidor Selenium, marca um salto em termos de automação do navegador.\nSelenium WebDriver refere-se a ambas as ligações de linguagem e as implementações do código de controle do navegador individual. Isso é comumente referido como apenas WebDriver.\nSelenium WebDriver é uma recomendação W3C\n  WebDriver é projetado como uma interface de programação simples e mais concisa.\n  WebDriver é uma API compacta orientada a objetos.\n  Ele manipula o navegador de forma eficaz.\n  "},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/js_alerts_prompts_and_confirmations/","title":"Alertas, prompts e confirmações JavaScript","tags":[],"description":"","content":" Page being translated from English to Brazilian Portuguese. Do you speak Brazilian Portuguese? Help us to translate it by sending us pull requests!\n WebDriver provides an API for working with the three types of native popup messages offered by JavaScript. These popups are styled by the browser and offer limited customisation.\nAlerts The simplest of these is referred to as an alert, which shows a custom message, and a single button which dismisses the alert, labelled in most browsers as OK. It can also be dismissed in most browsers by pressing the close button, but this will always do the same thing as the OK button. See an example alert.\nWebDriver can get the text from the popup and accept or dismiss these alerts.\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See an example alert\u0026#34;)).click(); //Wait for the alert to be displayed and store it in a variable Alert alert = wait.until(ExpectedConditions.alertIsPresent()); //Store the alert text in a variable String text = alert.getText(); //Press the OK button alert.accept();   # Click the link to activate the alert driver.find_element(By.LINK_TEXT, \u0026#34;See an example alert\u0026#34;).click() # Wait for the alert to be displayed and store it in a variable alert = wait.until(expected_conditions.alert_is_present()) # Store the alert text in a variable text = alert.text # Press the OK button alert.accept()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See an example alert\u0026#34;)).Click(); //Wait for the alert to be displayed and store it in a variable IAlert alert = wait.Until(ExpectedConditions.AlertIsPresent()); //Store the alert text in a variable string text = alert.Text; //Press the OK button alert.Accept();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See an example alert\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Store the alert text in a variable alert_text = alert.text # Press on OK button alert.accept   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See an example alert\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Store the alert text in a variable let alertText = await alert.getText(); //Press the OK button await alert.accept(); // Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See an example alert\u0026#34;)).click() //Wait for the alert to be displayed and store it in a variable val alert = wait.until(ExpectedConditions.alertIsPresent()) //Store the alert text in a variable val text = alert.getText() //Press the OK button alert.accept()     Confirm A confirm box is similar to an alert, except the user can also choose to cancel the message. See a sample confirm.\nThis example also shows a different approach to storing an alert:\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample confirm\u0026#34;)).click(); //Wait for the alert to be displayed wait.until(ExpectedConditions.alertIsPresent()); //Store the alert in a variable Alert alert = driver.switchTo().alert(); //Store the alert in a variable for reuse String text = alert.getText(); //Press the Cancel button alert.dismiss();   # Click the link to activate the alert driver.find_element(By.LINK_TEXT, \u0026#34;See a sample confirm\u0026#34;).click() # Wait for the alert to be displayed wait.until(expected_conditions.alert_is_present()) # Store the alert in a variable for reuse alert = driver.switch_to.alert # Store the alert text in a variable text = alert.text # Press the Cancel button alert.dismiss()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See a sample confirm\u0026#34;)).Click(); //Wait for the alert to be displayed wait.Until(ExpectedConditions.AlertIsPresent()); //Store the alert in a variable IAlert alert = driver.SwitchTo().Alert(); //Store the alert in a variable for reuse string text = alert.Text; //Press the Cancel button alert.Dismiss();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See a sample confirm\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Store the alert text in a variable alert_text = alert.text # Press on Cancel button alert.dismiss   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See a sample confirm\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Store the alert text in a variable let alertText = await alert.getText(); //Press the Cancel button await alert.dismiss(); // Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample confirm\u0026#34;)).click() //Wait for the alert to be displayed wait.until(ExpectedConditions.alertIsPresent()) //Store the alert in a variable val alert = driver.switchTo().alert() //Store the alert in a variable for reuse val text = alert.text //Press the Cancel button alert.dismiss()     Prompt Prompts are similar to confirm boxes, except they also include a text input. Similar to working with form elements, you can use WebDriver\u0026rsquo;s send keys to fill in a response. This will completely replace the placeholder text. Pressing the cancel button will not submit any text. See a sample prompt.\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample prompt\u0026#34;)).click(); //Wait for the alert to be displayed and store it in a variable Alert alert = wait.until(ExpectedConditions.alertIsPresent()); //Type your message alert.sendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button alert.accept();   # Click the link to activate the alert driver.find_element(By.LINK_TEXT, \u0026#34;See a sample prompt\u0026#34;).click() # Wait for the alert to be displayed wait.until(expected_conditions.alert_is_present()) # Store the alert in a variable for reuse alert = Alert(driver) # Type your message alert.send_keys(\u0026#34;Selenium\u0026#34;) # Press the OK button alert.accept()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See a sample prompt\u0026#34;)).Click(); //Wait for the alert to be displayed and store it in a variable IAlert alert = wait.Until(ExpectedConditions.AlertIsPresent()); //Type your message alert.SendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button alert.Accept();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See a sample prompt\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Type a message alert.send_keys(\u0026#34;selenium\u0026#34;) # Press on Ok button alert.accept   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See a sample prompt\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Type your message await alert.sendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button await alert.accept(); //Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample prompt\u0026#34;)).click() //Wait for the alert to be displayed and store it in a variable val alert = wait.until(ExpectedConditions.alertIsPresent()) //Type your message alert.sendKeys(\u0026#34;Selenium\u0026#34;) //Press the OK button alert.accept()     "},{"uri":"https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/avoid_sharing_state/","title":"Evite compartilhamento de estado","tags":[],"description":"","content":"Embora mencionado em vários lugares, vale a pena mencionar novamente. Garanta que os testes são isolados uns dos outros.\n  Não compartilhe dados de teste. Imagine vários testes em que cada um consulta o banco de dados para pedidos válidos antes de escolher um para executar uma ação. Caso dois testes peguem a mesma ordem, provavelmente você obterá um comportamento inesperado.\n  Limpe dados desatualizados no aplicativo que podem ser obtidos por outro teste, por exemplo registros de pedidos inválidos.\n  Crie uma nova instância do WebDriver por teste. Isso ajuda a garantir o isolamento do teste e torna a paralelização mais simples.\n  "},{"uri":"https://www.selenium.dev/documentation/pt-br/worst_practices/performance_testing/","title":"Teste de performance/desempenho","tags":[],"description":"","content":"Teste de desempenho usando Selenium e WebDriver geralmente não é recomendado. Não porque é incapaz, mas porque não é otimizado para o trabalho e é improvável que você obtenha bons resultados.\nPode parecer ideal para teste de desempenho no contexto do usuário, mas um conjunto de testes WebDriver estão sujeitos a muitos pontos de fragilidade externa e interna que estão além do seu controle; por exemplo, velocidade de inicialização do navegador, velocidade dos servidores HTTP, resposta de servidores de terceiros que hospedam JavaScript ou CSS, e a penalidade de instrumentação da própria implementação do WebDriver. A variação nesses pontos causará variação em seus resultados. É difícil separar a diferença entre o desempenho do seu site e o desempenho de recursos externos, e também é difícil dizer qual é a penalidade de desempenho para usar WebDriver no navegador, especialmente se você estiver injetando scripts.\nA outra atração potencial é \u0026ldquo;economizar tempo\u0026rdquo; - execução de testes funcionais e de desempenho ao mesmo tempo. No entanto, os testes funcionais e de desempenho têm objetivos opostos. Para testar a funcionalidade, um testador pode precisar ser paciente e aguarde o carregamento, mas isso irá turvar os resultados do teste de desempenho e vice-versa.\nPara melhorar o desempenho do seu site, você precisará ser capaz de analisar o desempenho geral independente das diferenças de ambiente, identificar práticas de código ruins, repartição do desempenho de recursos individuais (ou seja, CSS ou JavaScript), para saber o que melhorar. Existem ferramentas de teste de desempenho disponíveis que podem fazer este trabalho, que fornecem relatórios e análises, e podem até fazer sugestões de melhorias.\nPacotes de exemplo (código aberto) a serem usados ​​são: JMeter\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/support_packages/working_with_cookies/","title":"Trabalhando com cookies","tags":[],"description":"","content":" Page being translated from English to Brazilian Portuguese. Do you speak Brazilian Portuguese? Help us to translate it by sending us pull requests!\n A cookie is a small piece of data that is sent from a website and stored in your computer. Cookies are mostly used to recognise the user and load the stored information.\nWebDriver API provides a way to interact with cookies with built-in methods:\nAdd Cookie It is used to add a cookie to the current browsing context. Add Cookie only accepts a set of defined serializable JSON object. Here is the link to the list of accepted JSON key values\nFirst of all, you need to be on the domain that the cookie will be valid for. If you are trying to preset cookies before you start interacting with a site and your homepage is large / takes a while to load an alternative is to find a smaller page on the site (typically the 404 page is small, e.g. http://example.com/some404page)\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class addCookie { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); // Adds the cookie into current browser context  driver.manage().addCookie(new Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() driver.get(\u0026#34;http://www.example.com\u0026#34;) # Adds the cookie into current browser context driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;})   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace AddCookie { class AddCookie { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Adds the cookie into current browser context  driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; # Adds the cookie into current browser context driver.manage.add_cookie(name: \u0026#34;key\u0026#34;, value: \u0026#34;value\u0026#34;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // set a cookie on the current domain  await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;}); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Adds the cookie into current browser context  driver.manage().addCookie(Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)) } finally { driver.quit() } }     Get Named Cookie It returns the serialized cookie data matching with the cookie name among all associated cookies.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class getCookieNamed { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  Cookie cookie1 = driver.manage().getCookieNamed(\u0026#34;foo\u0026#34;); System.out.println(cookie1); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) # Adds the cookie into current browser context driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;bar\u0026#34;}) # Get cookie details with named cookie \u0026#39;foo\u0026#39; print(driver.get_cookie(\u0026#34;foo\u0026#34;))   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace GetCookieNamed { class GetCookieNamed { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  var cookie = driver.Manage().Cookies.GetCookieNamed(\u0026#34;foo\u0026#34;); System.Console.WriteLine(cookie); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;foo\u0026#34;, value: \u0026#34;bar\u0026#34;) # Get cookie details with named cookie \u0026#39;foo\u0026#39; puts driver.manage.cookie_named(\u0026#39;foo\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // set a cookie on the current domain  await driver.manage().addCookie({name:\u0026#39;foo\u0026#39;, value: \u0026#39;bar\u0026#39;}); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  driver.manage().getCookie(\u0026#39;foo\u0026#39;).then(function (cookie) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookie); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)) // Get cookie details with named cookie \u0026#39;foo\u0026#39;  val cookie = driver.manage().getCookieNamed(\u0026#34;foo\u0026#34;) println(cookie) } finally { driver.quit() } }     Get All Cookies It returns a ‘successful serialized cookie data’ for current browsing context. If browser is no longer available it returns error.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; import java.util.Set; public class getAllCookies { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); // Add few cookies  driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Get All available cookies  Set\u0026lt;Cookie\u0026gt; cookies = driver.manage().getCookies(); System.out.println(cookies); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Get all available cookies print(driver.get_cookies())   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace GetAllCookies { class GetAllCookies { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Get All available cookies  var cookies = driver.Manage().Cookies.AllCookies; } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # Get all available cookies puts driver.manage.all_cookies ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Add few cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Get all Available cookies  driver.manage().getCookies().then(function (cookies) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookies); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)) driver.manage().addCookie(Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)) // Get All available cookies  val cookies = driver.manage().cookies println(cookies) } finally { driver.quit() } }     Delete Cookie It deletes the cookie data matching with the provided cookie name.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class deleteCookie { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); Cookie cookie1 = new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;); driver.manage().addCookie(cookie1); // delete a cookie with name \u0026#39;test1\u0026#39;  driver.manage().deleteCookieNamed(\u0026#34;test1\u0026#34;); /* Selenium Java bindings also provides a way to delete cookie by passing cookie object of current browsing context */ driver.manage().deleteCookie(cookie1); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Delete a cookie with name \u0026#39;test1\u0026#39; driver.delete_cookie(\u0026#34;test1\u0026#34;)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace DeleteCookie { class DeleteCookie { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); var cookie = new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;); driver.Manage().Cookies.AddCookie(cookie); // delete a cookie with name \u0026#39;test1\u0026#39;\t driver.Manage().Cookies.DeleteCookieNamed(\u0026#34;test1\u0026#34;); // Selenium .net bindings also provides a way to delete  // cookie by passing cookie object of current browsing context  driver.Manage().Cookies.DeleteCookie(cookie); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # delete a cookie with name \u0026#39;test1\u0026#39; driver.manage.delete_cookie(\u0026#39;test1\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Add few cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Delete a cookie with name \u0026#39;test1\u0026#39;  await driver.manage().deleteCookie(\u0026#39;test1\u0026#39;); // Get all Available cookies  driver.manage().getCookies().then(function (cookies) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookies); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)) val cookie1 = Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;) driver.manage().addCookie(cookie1) // delete a cookie with name \u0026#39;test1\u0026#39;  driver.manage().deleteCookieNamed(\u0026#34;test1\u0026#34;) // delete cookie by passing cookie object of current browsing context.  driver.manage().deleteCookie(cookie1) } finally { driver.quit() } }     Delete All Cookies It deletes all the cookies of the current browsing context.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class deleteAllCookies { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // deletes all cookies  driver.manage().deleteAllCookies(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Deletes all cookies driver.delete_all_cookies()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace DeleteAllCookies { class DeleteAllCookies { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // deletes all cookies  driver.Manage().Cookies.DeleteAllCookies(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # deletes all cookies driver.manage.delete_all_cookies ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Add few cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Delete all cookies  await driver.manage().deleteAllCookies(); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)) driver.manage().addCookie(Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)) // deletes all cookies  driver.manage().deleteAllCookies() } finally { driver.quit() } }     Same-Site Cookie Attribute It allows a user to instruct browsers to control whether cookies are sent along with the request initiated by third party sites. It is introduced to prevent CSRF (Cross-Site Request Forgery) attacks.\nSame-Site cookie attribute accepts two parameters as instructions\nStrict: When the sameSite attribute is set as Strict, the cookie will not be sent along with requests initiated by third party websites.\nLax: When you set a cookie sameSite attribute to Lax, the cookie will be sent along with the GET request initiated by third party website.\nNote: As of now this feature is landed in chrome(80+version), Firefox(79+version) and works with Selenium 4 and later versions.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class cookieTest { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); Cookie cookie = new Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Strict\u0026#34;).build(); Cookie cookie1 = new Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Lax\u0026#34;).build(); driver.manage().addCookie(cookie); driver.manage().addCookie(cookie1); System.out.println(cookie.getSameSite()); System.out.println(cookie1.getSameSite()); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() driver.get(\u0026#34;http://www.example.com\u0026#34;) # Adds the cookie into current browser context with sameSite \u0026#39;Strict\u0026#39; (or) \u0026#39;Lax\u0026#39; driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;, \u0026#39;sameSite\u0026#39;: \u0026#39;Strict\u0026#39;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;, \u0026#39;sameSite\u0026#39;: \u0026#39;Lax\u0026#39;}) cookie1 = driver.get_cookie(\u0026#39;foo\u0026#39;) cookie2 = driver.get_cookie(\u0026#39;foo1\u0026#39;) print(cookie1) print(cookie2)   // Please raise a PR    require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; # Adds the cookie into current browser context with sameSite \u0026#39;Strict\u0026#39; (or) \u0026#39;Lax\u0026#39; driver.manage.add_cookie(name: \u0026#34;foo\u0026#34;, value: \u0026#34;bar\u0026#34;, same_site: \u0026#34;Strict\u0026#34;) driver.manage.add_cookie(name: \u0026#34;foo1\u0026#34;, value: \u0026#34;bar\u0026#34;, same_site: \u0026#34;Lax\u0026#34;) puts driver.manage.cookie_named(\u0026#39;foo\u0026#39;) puts driver.manage.cookie_named(\u0026#39;foo1\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // set a cookie on the current domain with sameSite \u0026#39;Strict\u0026#39; (or) \u0026#39;Lax\u0026#39;  await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;, sameSite:\u0026#39;Strict\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;, sameSite:\u0026#39;Lax\u0026#39;}); console.log(await driver.manage().getCookie(\u0026#39;key\u0026#39;)); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;http://www.example.com\u0026#34;) val cookie = Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Strict\u0026#34;).build() val cookie1 = Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Lax\u0026#34;).build() driver.manage().addCookie(cookie) driver.manage().addCookie(cookie1) println(cookie.getSameSite()) println(cookie1.getSameSite()) } finally { driver.quit() } }     "},{"uri":"https://www.selenium.dev/documentation/pt-br/remote_webdriver/","title":"WebDriver Remoto","tags":[],"description":"","content":"WebDriver Remoto Você pode usar o WebDriver remotamente da mesma forma que o usaria localmente. A principal diferença é que um WebDriver remoto precisa ser configurado para que possa executar seus testes em uma máquina separada.\nUm WebDriver remoto é composto por duas peças: um cliente e um servidor. O cliente é o seu teste WebDriver e o servidor é simplesmente um Servlet Java, que pode ser hospedado em qualquer servidor de aplicativo JEE moderno.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/","title":"Diretrizes e recomendações","tags":[],"description":"","content":"Diretrizes e recomendações Uma nota sobre \u0026ldquo;Melhores práticas\u0026rdquo;: evitamos intencionalmente a frase \u0026ldquo;Melhores Práticas\u0026rdquo; nesta documentação. Nenhuma abordagem funciona para todas as situações. Preferimos a ideia de \u0026ldquo;Diretrizes e Recomendações\u0026rdquo;. Nós encorajamos que você leia e decida cuidadosamente quais abordagens funcionarão para você em seu ambiente específico.\nO teste funcional é difícil de acertar por muitos motivos. Como se o estado, a complexidade e as dependências do aplicativo não tornassem o teste suficientemente difícil, lidar com navegadores (especialmente com incompatibilidades entre navegadores) torna a escrita de bons testes um desafio.\nSelenium fornece ferramentas para facilitar a interação funcional do usuário, mas não o ajuda a escrever suítes de teste bem arquitetadas. Neste capítulo, oferecemos conselhos, diretrizes e recomendações sobre como abordar a automação funcional de páginas da web.\nEste capítulo registra os padrões de design de software populares entre muitos dos usuários do Selenium que tiveram sucesso ao longo dos anos.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/test_independency/","title":"Independência de Testes","tags":[],"description":"","content":"Escreva cada teste como sua própria unidade. Escreva os testes de uma forma que não seja dependente de outros testes para concluir:\nDigamos que existe um sistema de gerenciamento de conteúdo com o qual você pode criar algum conteúdo personalizado que então aparece em seu site como um módulo após publicação, e pode levar algum tempo para sincronizar entre o CMS e a aplicação.\nUma maneira errada de testar seu módulo é que o conteúdo seja criado e publicado em um teste e, em seguida, verificar o módulo em outro teste. Este teste não é viável, pois o conteúdo pode não estar disponível imediatamente para o outro teste após a publicação.\nEm vez disso, você pode criar um conteúdo stub que pode ser ligado e desligado dentro do teste e use-o para validar o módulo. Contudo, para a criação de conteúdo, você ainda pode ter um teste separado.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/worst_practices/link_spidering/","title":"Navegação por links","tags":[],"description":"","content":"Usar o WebDriver para navegar por links não é uma prática recomendada. Não porque não pode ser feito, mas porque WebDriver definitivamente não é a ferramenta ideal para isso. O WebDriver precisa de tempo para inicializar, e pode levar vários segundos, até um minuto dependendo de como seu teste é escrito, apenas para chegar à página e atravessar o DOM.\nEm vez de usar o WebDriver para isso, você poderia economizar muito tempo executando um comando curl, ou usando uma biblioteca como BeautifulSoup uma vez que esses métodos não dependem em criar um navegador e navegar para uma página. Você está economizando muito tempo por não usar o WebDriver para essa tarefa.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/http_proxies/","title":"Proxies Http","tags":[],"description":"","content":"Um servidor proxy atua como intermediário para solicitações entre um cliente e um servidor. De forma simples, o tráfego flui através do servidor proxy a caminho do endereço que você solicitou e de volta.\nUm servidor proxy para scripts de automação com Selenium pode ser útil para:\n Capturar o tráfego da rede Simular chamadas de back-end feitas pelo site Acessar o site necessário em uma rede complexa topologias ou restrições / políticas corporativas estritas.  Se você estiver em um ambiente corporativo, e um navegador não consegue se conectar a um URL, isso é provavelmente porque o ambiente precisa de um proxy para ser acessado.\nO Selenium WebDriver fornece uma maneira de configurações de proxy:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.Proxy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.chrome.ChromeOptions; public class proxyTest { public static void main(String[] args) { Proxy proxy = new Proxy(); proxy.setHttpProxy(\u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34;); ChromeOptions options = new ChromeOptions(); options.setCapability(\u0026#34;proxy\u0026#34;, proxy); WebDriver driver = new ChromeDriver(options); driver.get(\u0026#34;https://www.google.com/\u0026#34;); driver.manage().window().maximize(); driver.quit(); } }   from selenium import webdriver PROXY = \u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34; webdriver.DesiredCapabilities.FIREFOX[\u0026#39;proxy\u0026#39;] = { \u0026#34;httpProxy\u0026#34;: PROXY, \u0026#34;ftpProxy\u0026#34;: PROXY, \u0026#34;sslProxy\u0026#34;: PROXY, \u0026#34;proxyType\u0026#34;: \u0026#34;MANUAL\u0026#34;, } with webdriver.Firefox() as driver: # Open URL driver.get(\u0026#34;https://selenium.dev\u0026#34;)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; public class ProxyTest{ public static void Main() { ChromeOptions options = new ChromeOptions(); Proxy proxy = new Proxy(); proxy.Kind = ProxyKind.Manual; proxy.IsAutoDetect = false; proxy.SslProxy = \u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34;; options.Proxy = proxy; options.AddArgument(\u0026#34;ignore-certificate-errors\u0026#34;); IWebDriver driver = new ChromeDriver(options); driver.Navigate().GoToUrl(\u0026#34;https://www.selenium.dev/\u0026#34;); } }   # este código foi escrito com Selenium 4 proxy = Selenium::WebDriver::Proxy.new(http: \u0026#39;\u0026lt;HOST:PORT\u0026gt;\u0026#39;) cap = Selenium::WebDriver::Remote::Capabilities.chrome(proxy: proxy) driver = Selenium::WebDriver.for(:chrome, capabilities: cap) driver.get(\u0026#39;http://google.com\u0026#39;)   let webdriver = require(\u0026#39;selenium-webdriver\u0026#39;); let chrome = require(\u0026#39;selenium-webdriver/chrome\u0026#39;); let proxy = require(\u0026#39;selenium-webdriver/proxy\u0026#39;); let opts = new chrome.Options(); (async function example() { opts.setProxy(proxy.manual({http: \u0026#39;\u0026lt;HOST:PORT\u0026gt;\u0026#39;})); let driver = new webdriver.Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .setChromeOptions(opts) .build(); try { await driver.get(\u0026#34;https://selenium.dev\u0026#34;); } finally { await driver.quit(); } }());   import org.openqa.selenium.Proxy import org.openqa.selenium.WebDriver import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions class proxyTest { fun main() { val proxy = Proxy() proxy.setHttpProxy(\u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34;) val options = ChromeOptions() options.setCapability(\u0026#34;proxy\u0026#34;, proxy) val driver: WebDriver = ChromeDriver(options) driver[\u0026#34;https://www.google.com/\u0026#34;] driver.manage().window().maximize() driver.quit() } }     "},{"uri":"https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/consider_using_a_fluent_api/","title":"Considere usar uma API fluente","tags":[],"description":"","content":"Martin Fowler cunhou o termo \u0026ldquo;API Fluent\u0026rdquo;. Selenium já implementa algo assim em sua classe FluentWait, que é pretende ser uma alternativa à classe padrão Wait. Você pode habilitar o padrão de design de API fluente em seu objeto de página e, em seguida, consulte a página de pesquisa do Google com um snippet de código como este:\ndriver.get( \u0026#34;http://www.google.com/webhp?hl=en\u0026amp;amp;tab=ww\u0026#34; ); GoogleSearchPage gsp = new GoogleSearchPage(); gsp.withFluent().setSearchString().clickSearchButton(); A classe de objeto da página do Google com este comportamento fluente pode ser assim:\npublic class GoogleSearchPage extends LoadableComponent\u0026lt;GoogleSearchPage\u0026gt; { private final WebDriver driver; private GSPFluentInterface gspfi; public class GSPFluentInterface { private GoogleSearchPage gsp; public GSPFluentInterface(GoogleSearchPage googleSearchPage) { gsp = googleSearchPage; } public GSPFluentInterface clickSearchButton() { gsp.searchButton.click(); return this; } public GSPFluentInterface setSearchString( String sstr ) { clearAndType( gsp.searchField, sstr ); return this; } } @FindBy(id = \u0026#34;gbqfq\u0026#34;) private WebElement searchField; @FindBy(id = \u0026#34;gbqfb\u0026#34;) private WebElement searchButton; public GoogleSearchPage(WebDriver driver) { gspfi = new GSPFluentInterface( this ); this.get(); // Se load() falhar, chama isLoaded() até que a página termine de carregar  PageFactory.initElements(driver, this); // Inicializa WebElements na página  } public GSPFluentInterface withFluent() { return gspfi; } public void clickSearchButton() { searchButton.click(); } public void setSearchString( String sstr ) { clearAndType( searchField, sstr ); } @Override protected void isLoaded() throws Error { Assert.assertTrue(\u0026#34;Google search page is not yet loaded.\u0026#34;, isSearchFieldVisible() ); } @Override protected void load() { if ( isSFieldPresent ) { Wait\u0026lt;WebDriver\u0026gt; wait = new WebDriverWait( driver, Duration.ofSeconds(3) ); wait.until( visibilityOfElementLocated( By.id(\u0026#34;gbqfq\u0026#34;) ) ).click(); } } } "},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/page_loading_strategy/","title":"Estratégia de carregamento de página","tags":[],"description":"","content":"Define a estratégia de carregamento de página da sessão atual. Por padrão, quando o Selenium WebDriver carrega uma página, segue a normal pageLoadStrategy. É sempre recomendado parar de baixar outros recursos (como imagens, css, js) quando o carregamento da página leva muito tempo.\nA propriedade document.readyState de um documento descreve o estado de carregamento do documento atual. Por padrão, o WebDriver vai adiar a resposta a uma chamada para driver.get() (ou) driver.navigate().To() até que o estado de documento pronto seja completo\nEm aplicações SPA (como Angular, React, Ember) uma vez que o conteúdo dinâmico já está carregado (ou seja, quando o status de pageLoadStrategy for COMPLETE), clicar em um link ou realizar alguma ação na página não fará uma nova solicitação para o servidor, pois o conteúdo é carregado dinamicamente no lado do cliente sem uma atualização da página.\nOs aplicativos SPA podem carregar muitas visualizações dinamicamente sem quaisquer solicitações do servidor, então pageLoadStrategy sempre mostrará o status COMPLETO até fazemos um novo driver.get () e driver.navigate().To()\nWebDriver pageLoadStrategy suporta os seguintes valores:\nnormal Isso fará com que o Selenium WebDriver espere até que a página inteira seja carregada. Quando definido como normal, o Selenium WebDriver espera até que o disparo do evento load seja retornado.\nPor padrão, normal é definido como navegador se nenhum for fornecido.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;normal\u0026#39; driver = webdriver.Chrome(options=options) # Navegar para Url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.Normal; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;normal\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;normal\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     eager Isso fará com que o Selenium WebDriver espere até que o documento HTML inicial seja completamente carregado e analisado, e descarta o carregamento de CSS, imagens e subframes.\nQuando definido como eager, o Selenium WebDriver espera até que o disparo de evento DOMContentLoaded seja retornado.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.EAGER); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;eager\u0026#39; driver = webdriver.Chrome(options=options) # Navegar para Url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.Eager; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;eager\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;eager\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.EAGER) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     none Quando definido como none, o Selenium WebDriver apenas espera até que a página inicial seja baixada.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.NONE); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;none\u0026#39; driver = webdriver.Chrome(options=options) # Navegar para Url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.None; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;none\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;none\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.NONE) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     "},{"uri":"https://www.selenium.dev/documentation/pt-br/worst_practices/","title":"Piores práticas","tags":[],"description":"","content":"Piores práticas "},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/web_element/","title":"Elemento Web","tags":[],"description":"","content":" Page being translated from English to Brazilian Portuguese. Do you speak Brazilian Portuguese? Help us to translate it by sending us pull requests!\n WebElement represents a DOM element. WebElements can be found by searching from the document root using a WebDriver instance, or by searching under another WebElement.\nWebDriver API provides built-in methods to find the WebElements which are based on different properties like ID, Name, Class, XPath, CSS Selectors, link Text, etc.\nFind Element It is used to find an element and returns a first matching single WebElement reference, that can be used for future element actions\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.get(\u0026#34;http://www.google.com\u0026#34;); // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element WebElement searchBox = driver.findElement(By.name(\u0026#34;q\u0026#34;)); searchBox.sendKeys(\u0026#34;webdriver\u0026#34;);   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Firefox() driver.get(\u0026#34;http://www.google.com\u0026#34;) # Get search box element from webElement \u0026#39;q\u0026#39; using Find Element search_box = driver.find_element(By.NAME, \u0026#34;q\u0026#34;) search_box.send_keys(\u0026#34;webdriver\u0026#34;)   IWebDriver driver = new FirefoxDriver(); driver.Url = \u0026#34;http://www.google.com\u0026#34;; // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element IWebElement searchbox = driver.FindElement(By.Name(\u0026#34;q\u0026#34;)); searchbox.SendKeys(\u0026#34;webdriver\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; # Get search box element from webElement \u0026#39;q\u0026#39; using Find Element search_bar = driver.find_element(name: \u0026#39;q\u0026#39;) # Perform action using WebElement search_bar.send_keys \u0026#39;Webdriver\u0026#39; ensure driver.quit end   let {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); driver = new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); (async function test(){ //Navigate to url await driver.get(\u0026#39;http://www.google.com\u0026#39;); // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element let searchBar = driver.findElement(By.name(\u0026#39;q\u0026#39;)); //Perform action using WebElement await searchBar.sendKeys(\u0026#39;Webdriver\u0026#39;); })();   val driver = FirefoxDriver() driver.get(\u0026#34;http://www.google.com\u0026#34;) // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element val searchBox = driver.findElement(By.name(\u0026#34;q\u0026#34;)) searchBox.sendKeys(\u0026#34;webdriver\u0026#34;)     Find Elements Similar to \u0026lsquo;Find Element\u0026rsquo;, but returns a list of matching WebElements. To use a particular WebElement from the list, you need to loop over the list of elements to perform action on selected element.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; import java.util.List; public class findElementsExample { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); try { driver.get(\u0026#34;https://example.com\u0026#34;); // Get all the elements available with tag name \u0026#39;p\u0026#39;  List\u0026lt;WebElement\u0026gt; elements = driver.findElements(By.tagName(\u0026#34;p\u0026#34;)); for (WebElement element : elements) { System.out.println(\u0026#34;Paragraph text:\u0026#34; + element.getText()); } } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Firefox() # Navigate to Url driver.get(\u0026#34;https://www.example.com\u0026#34;) # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = driver.find_elements(By.TAG_NAME, \u0026#39;p\u0026#39;) for e in elements: print(e.text)   using OpenQA.Selenium; using OpenQA.Selenium.Firefox; using System.Collections.Generic; namespace FindElementsExample { class FindElementsExample { public static void Main(string[] args) { IWebDriver driver = new FirefoxDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Get all the elements available with tag name \u0026#39;p\u0026#39;  IList \u0026lt; IWebElement \u0026gt; elements = driver.FindElements(By.TagName(\u0026#34;p\u0026#34;)); foreach(IWebElement e in elements) { System.Console.WriteLine(e.Text); } } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://www.example.com\u0026#39; # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = driver.find_elements(:tag_name,\u0026#39;p\u0026#39;) elements.each { |e| puts e.text } ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Get all the elements available with tag \u0026#39;p\u0026#39;  let elements = await driver.findElements(By.css(\u0026#39;p\u0026#39;)); for(let e of elements) { console.log(await e.getText()); } } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.firefox.FirefoxDriver fun main() { val driver = FirefoxDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Get all the elements available with tag name \u0026#39;p\u0026#39;  val elements = driver.findElements(By.tagName(\u0026#34;p\u0026#34;)) for (element in elements) { println(\u0026#34;Paragraph text:\u0026#34; + element.text) } } finally { driver.quit() } }     Find Element From Element It is used to find a child element within the context of parent element. To achieve this, the parent WebElement is chained with \u0026lsquo;findElement\u0026rsquo; to access child elements\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.get(\u0026#34;http://www.google.com\u0026#34;); WebElement searchForm = driver.findElement(By.tagName(\u0026#34;form\u0026#34;)); WebElement searchBox = searchForm.findElement(By.name(\u0026#34;q\u0026#34;)); searchBox.sendKeys(\u0026#34;webdriver\u0026#34;);   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Firefox() driver.get(\u0026#34;http://www.google.com\u0026#34;) search_form = driver.find_element(By.TAG_NAME, \u0026#34;form\u0026#34;) search_box = search_form.find_element(By.NAME, \u0026#34;q\u0026#34;) search_box.send_keys(\u0026#34;webdriver\u0026#34;)   IWebDriver driver = new FirefoxDriver(); driver.Url = \u0026#34;http://www.google.com\u0026#34;; IWebElement searchForm = driver.FindElement(By.TagName(\u0026#34;form\u0026#34;)); IWebElement searchbox = searchForm.FindElement(By.Name(\u0026#34;q\u0026#34;)); searchbox.SendKeys(\u0026#34;webdriver\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; # Get and store DOM element \u0026#39;\u0026lt;form\u0026gt;\u0026#39; search_form = driver.find_element(name: \u0026#39;f\u0026#39;) # Get search box element from webElement \u0026#39;form\u0026#39; search_bar = search_form.find_element(name: \u0026#39;q\u0026#39;) # Perform action using WebElement search_bar.send_keys \u0026#39;Webdriver\u0026#39; ensure driver.quit end   let {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); driver = new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); (async function test(){ //Navigate to url await driver.get(\u0026#39;http://www.google.com\u0026#39;); //Get and store DOM element \u0026#39;\u0026lt;form\u0026gt;\u0026#39; let searchForm = driver.findElement(By.name(\u0026#39;f\u0026#39;)); //Get search box element from webElement \u0026#39;form\u0026#39; let searchBar = searchForm.findElement(By.name(\u0026#39;q\u0026#39;)); //Perform action using WebElement await searchBar.sendKeys(\u0026#39;Webdriver\u0026#39;); })();   val driver = FirefoxDriver() driver.get(\u0026#34;http://www.google.com\u0026#34;) val searchForm = driver.findElement(By.tagName(\u0026#34;form\u0026#34;)) val searchBox = searchForm.findElement(By.name(\u0026#34;q\u0026#34;)) searchBox.sendKeys(\u0026#34;webdriver\u0026#34;)     Find Elements From Element It is used to find the list of matching child WebElements within the context of parent element. To achieve this, the parent WebElement is chained with \u0026lsquo;findElements\u0026rsquo; to access child elements\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import java.util.List; public class findElementsFromElement { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;https://example.com\u0026#34;); // Get element with tag name \u0026#39;div\u0026#39;  WebElement element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)); // Get all the elements available with tag name \u0026#39;p\u0026#39;  List\u0026lt;WebElement\u0026gt; elements = element.findElements(By.tagName(\u0026#34;p\u0026#34;)); for (WebElement e : elements) { System.out.println(e.getText()); } } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() driver.get(\u0026#34;https://www.example.com\u0026#34;) # Get element with tag name \u0026#39;div\u0026#39; element = driver.find_element(By.TAG_NAME, \u0026#39;div\u0026#39;) # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = element.find_elements(By.TAG_NAME, \u0026#39;p\u0026#39;) for e in elements: print(e.text)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using System.Collections.Generic; namespace FindElementsFromElement { class FindElementsFromElement { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Get element with tag name \u0026#39;div\u0026#39;  IWebElement element = driver.FindElement(By.TagName(\u0026#34;div\u0026#34;)); // Get all the elements available with tag name \u0026#39;p\u0026#39;  IList \u0026lt; IWebElement \u0026gt; elements = element.FindElements(By.TagName(\u0026#34;p\u0026#34;)); foreach(IWebElement e in elements) { System.Console.WriteLine(e.Text); } } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to URL driver.get \u0026#39;https://www.example.com\u0026#39; # Get element with tag name \u0026#39;div\u0026#39; element = driver.find_element(:tag_name,\u0026#39;div\u0026#39;) # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = element.find_elements(:tag_name,\u0026#39;p\u0026#39;) elements.each { |e| puts e.text } ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Get element with tag name \u0026#39;div\u0026#39;  let element = driver.findElement(By.css(\u0026#34;div\u0026#34;)); // Get all the elements available with tag name \u0026#39;p\u0026#39;  let elements = await element.findElements(By.css(\u0026#34;p\u0026#34;)); for(let e of elements) { console.log(await e.getText()); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Get element with tag name \u0026#39;div\u0026#39;  val element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)) // Get all the elements available with tag name \u0026#39;p\u0026#39;  val elements = element.findElements(By.tagName(\u0026#34;p\u0026#34;)) for (e in elements) { println(e.text) } } finally { driver.quit() } }     Get Active Element It is used to track (or) find DOM element which has the focus in the current browsing context.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class activeElementTest { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.findElement(By.cssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).sendKeys(\u0026#34;webElement\u0026#34;); // Get attribute of current active element  String attr = driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); System.out.println(attr); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() driver.get(\u0026#34;https://www.google.com\u0026#34;) driver.find_element(By.CSS_SELECTOR, \u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;).send_keys(\u0026#34;webElement\u0026#34;) # Get attribute of current active element attr = driver.switch_to.active_element.get_attribute(\u0026#34;title\u0026#34;) print(attr)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace ActiveElement { class ActiveElement { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://www.google.com\u0026#34;); driver.FindElement(By.CssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).SendKeys(\u0026#34;webElement\u0026#34;); // Get attribute of current active element  string attr = driver.SwitchTo().ActiveElement().GetAttribute(\u0026#34;title\u0026#34;); System.Console.WriteLine(attr); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.google.com\u0026#39; driver.find_element(css: \u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;).send_keys(\u0026#39;webElement\u0026#39;) # Get attribute of current active element attr = driver.switch_to.active_element.attribute(\u0026#39;title\u0026#39;) puts attr ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); await driver.get(\u0026#39;https://www.google.com\u0026#39;); await driver.findElement(By.css(\u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;)).sendKeys(\u0026#34;webElement\u0026#34;); // Get attribute of current active element  let attr = await driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); console.log(`${attr}`) })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://www.google.com\u0026#34;) driver.findElement(By.cssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).sendKeys(\u0026#34;webElement\u0026#34;) // Get attribute of current active element  val attr = driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;) print(attr) } finally { driver.quit() } }     Is Element Enabled This method is used to check if the connected Element is enabled or disabled on a webpage. Returns a boolean value, True if the connected element is enabled in the current browsing context else returns false.\nJava Python C# Ruby JavaScript Kotlin //navigates to url  driver.get(\u0026#34;https://www.google.com/\u0026#34;); //returns true if element is enabled else returns false  boolean value = driver.findElement(By.name(\u0026#34;btnK\u0026#34;)).isEnabled();   # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Returns true if element is enabled else returns false value = driver.find_element(By.NAME, \u0026#39;btnK\u0026#39;).is_enabled()   // Navigate to Url driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store the WebElement IWebElement element = driver.FindElement(By.Name(\u0026#34;btnK\u0026#34;)); // Prints true if element is enabled else returns false System.Console.WriteLine(element.Enabled);   # Navigate to url driver.get \u0026#39;http://www.google.com/\u0026#39; # Returns true if element is enabled else returns false ele = driver.find_element(name: \u0026#39;btnK\u0026#39;).enabled?   // Navigate to url await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Resolves Promise and returns boolean value let element = await driver.findElement(By.name(\u0026#34;btnK\u0026#34;)).isEnabled();   //navigates to url  driver.get(\u0026#34;https://www.google.com/\u0026#34;) //returns true if element is enabled else returns false  val attr = driver.findElement(By.name(\u0026#34;btnK\u0026#34;)).isEnabled()     Is Element Selected This method determines if the referenced Element is Selected or not. This method is widely used on Check boxes, radio buttons, input elements, and option elements.\nReturns a boolean value, True if referenced element is selected in the current browsing context else returns false.\nJava Python C# Ruby JavaScript Kotlin //navigates to url  driver.get(\u0026#34;https://the-internet.herokuapp.com/checkboxes\u0026#34;); //returns true if element is checked else returns false  boolean value = driver.findElement(By.cssSelector(\u0026#34;input[type=\u0026#39;checkbox\u0026#39;]:first-of-type\u0026#34;)).isSelected();   # Navigate to url driver.get(\u0026#34;https://the-internet.herokuapp.com/checkboxes\u0026#34;) # Returns true if element is checked else returns false value = driver.find_element(By.CSS_SELECTOR, \u0026#34;input[type=\u0026#39;checkbox\u0026#39;]:first-of-type\u0026#34;).is_selected()   // Navigate to Url driver.Navigate().GoToUrl(\u0026#34;https://the-internet.herokuapp.com/checkboxes\u0026#34;); // Returns true if element ins checked else returns false bool value = driver.FindElement(By.CssSelector(\u0026#34;input[type=\u0026#39;checkbox\u0026#39;]:last-of-type\u0026#34;)).Selected;   # Navigate to url driver.get \u0026#39;https://the-internet.herokuapp.com/checkboxes\u0026#39; # Returns true if element is checked else returns false ele = driver.find_element(css: \u0026#34;input[type=\u0026#39;checkbox\u0026#39;]:last-of-type\u0026#34;).selected?   // Navigate to url await driver.get(\u0026#39;https://the-internet.herokuapp.com/checkboxes\u0026#39;); // Returns true if element ins checked else returns false let res = await driver.findElement(By.css(\u0026#34;input[type=\u0026#39;checkbox\u0026#39;]:last-of-type\u0026#34;)).isSelected();   //navigates to url  driver.get(\u0026#34;https://the-internet.herokuapp.com/checkboxes\u0026#34;) //returns true if element is checked else returns false  val attr = driver.findElement(By.cssSelector(\u0026#34;input[type=\u0026#39;checkbox\u0026#39;]:first-of-type\u0026#34;)).isSelected()     Get Element TagName It is used to fetch the TagName of the referenced Element which has the focus in the current browsing context.\nJava Python C# Ruby JavaScript Kotlin //navigates to url  driver.get(\u0026#34;https://www.example.com\u0026#34;); //returns TagName of the element  String value = driver.findElement(By.cssSelector(\u0026#34;h1\u0026#34;)).getTagName();   # Navigate to url driver.get(\u0026#34;https://www.example.com\u0026#34;) # Returns TagName of the element attr = driver.find_element(By.CSS_SELECTOR, \u0026#34;h1\u0026#34;).tag_name   // Navigate to Url driver.Navigate().GoToUrl(\u0026#34;https://www.example.com\u0026#34;); // Returns TagName of the element string attr = driver.FindElement(By.CssSelector(\u0026#34;h1\u0026#34;)).TagName;   # Navigate to url driver.get \u0026#39;https://www.example.com\u0026#39; # Returns TagName of the element attr = driver.find_element(css: \u0026#34;h1\u0026#34;).tag_name   // Navigate to URL await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Returns TagName of the element let value = await driver.findElement(By.css(\u0026#39;h1\u0026#39;)).getTagName();   //navigates to url  driver.get(\u0026#34;https://www.example.com\u0026#34;) //returns TagName of the element  val attr = driver.findElement(By.cssSelector(\u0026#34;h1\u0026#34;)).getTagName()     Get Element Rect It is used to fetch the dimensions and coordinates of the referenced element.\nThe fetched data body contain the following details:\n X-axis position from the top-left corner of the element y-axis position from the top-left corner of the element Height of the element Width of the element  Java Python C# Ruby JavaScript Kotlin // Navigate to url driver.get(\u0026#34;https://www.example.com\u0026#34;); // Returns height, width, x and y coordinates referenced element Rectangle res = driver.findElement(By.cssSelector(\u0026#34;h1\u0026#34;)).getRect(); // Rectangle class provides getX,getY, getWidth, getHeight methods System.out.println(res.getX());   # Navigate to url driver.get(\u0026#34;https://www.example.com\u0026#34;) # Returns height, width, x and y coordinates referenced element res = driver.find_element(By.CSS_SELECTOR, \u0026#34;h1\u0026#34;).rect   // Navigate to Url driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); var res = driver.FindElement(By.CssSelector(\u0026#34;h1\u0026#34;)); // Return x and y coordinates referenced element System.Console.WriteLine(res.Location); // Returns height, width System.Console.WriteLine(res.Size);   # Navigate to url driver.get \u0026#39;https://www.example.com\u0026#39; # Returns height, width, x and y coordinates referenced element res = driver.find_element(css: \u0026#34;h1\u0026#34;).rect   // Navigate to url await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Returns height, width, x and y coordinates referenced element let element = await driver.findElement(By.css(\u0026#34;h1\u0026#34;)).getRect();   // Navigate to url driver.get(\u0026#34;https://www.example.com\u0026#34;) // Returns height, width, x and y coordinates referenced element val res = driver.findElement(By.cssSelector(\u0026#34;h1\u0026#34;)).rect // Rectangle class provides getX,getY, getWidth, getHeight methods println(res.getX())     Get Element CSS Value Retrieves the value of specified computed style property of an element in the current browsing context.\nJava Python C# Ruby JavaScript Kotlin // Navigate to Url driver.get(\u0026#34;https://www.example.com\u0026#34;); // Retrieves the computed style property \u0026#39;color\u0026#39; of linktext String cssValue = driver.findElement(By.linkText(\u0026#34;More information...\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;);   # Navigate to Url driver.get(\u0026#39;https://www.example.com\u0026#39;) # Retrieves the computed style property \u0026#39;color\u0026#39; of linktext cssValue = driver.findElement(By.LINK_TEXT, \u0026#34;More information...\u0026#34;).value_of_css_property(\u0026#39;color\u0026#39;)   // Navigate to Url driver.Navigate().GoToUrl(\u0026#34;https://www.example.com\u0026#34;); // Retrieves the computed style property \u0026#39;color\u0026#39; of linktext String cssValue = driver.FindElement(By.LinkText(\u0026#34;More information...\u0026#34;)).GetCssValue(\u0026#34;color\u0026#34;);   # Navigate to Url driver.get \u0026#39;https://www.example.com\u0026#39; # Retrieves the computed style property \u0026#39;color\u0026#39; of linktext cssValue = driver.find_element(:link_text, \u0026#39;More information...\u0026#39;).css_value(\u0026#39;color\u0026#39;)   // Navigate to Url await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Retrieves the computed style property \u0026#39;color\u0026#39; of linktext let cssValue = await driver.findElement(By.linkText(\u0026#34;More information...\u0026#34;)).getCssValue(\u0026#39;color\u0026#39;);   // Navigate to Url driver.get(\u0026#34;https://www.example.com\u0026#34;) // Retrieves the computed style property \u0026#39;color\u0026#39; of linktext val cssValue = driver.findElement(By.linkText(\u0026#34;More information...\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;)     Get Element Text Retrieves the rendered text of the specified element.\nJava Python C# Ruby JavaScript Kotlin // Navigate to url driver.get(\u0026#34;https://example.com\u0026#34;); // Retrieves the text of the element String text = driver.findElement(By.cssSelector(\u0026#34;h1\u0026#34;)).getText();   # Navigate to url driver.get(\u0026#34;https://www.example.com\u0026#34;) # Retrieves the text of the element text = driver.find_element(By.CSS_SELECTOR, \u0026#34;h1\u0026#34;).text   // Please provide a pr for code sample    # Navigate to url driver.get \u0026#39;https://www.example.com\u0026#39; # Retrieves the text of the element text = driver.find_element(:css, \u0026#39;h1\u0026#39;).text   // Navigate to URL await driver.get(\u0026#39;http://www.example.com\u0026#39;); // retrieves the text of the element let text = await driver.findElement(By.css(\u0026#39;h1\u0026#39;)).getText();   // Navigate to URL driver.get(\u0026#34;https://www.example.com\u0026#34;) // retrieves the text of the element val text = driver.findElement(By.cssSelector(\u0026#34;h1\u0026#34;)).getText()     "},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/","title":"Grid","tags":[],"description":"","content":"Grid Selenium Grid permite a execução de scripts WebDriver em máquinas remotas (virtuais ou reais) por meio de comandos de roteamento enviados pelo cliente para instâncias remotas do navegador. Seu objetivo é fornecer uma maneira fácil de executar testes em paralelo em várias máquinas.\nSelenium Grid nos permite executar testes em paralelo em várias máquinas e gerenciar diferentes versões e configurações do navegador centralmente (em vez de em cada teste individual).\nA Selenium Grid não é uma bala de prata. Ela resolve um subconjunto de problemas comuns de delegação e distribuição, mas não irá, por exemplo, gerenciar sua infraestrutura, e pode não atender às suas necessidades específicas.\nObserve que a Grid 3 não é mais compatível e o projeto Selenium recomenda usar a Grid 4\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/fresh_browser_per_test/","title":"Navegador novo por teste","tags":[],"description":"","content":"Comece cada teste a partir de um estado limpo conhecido. Idealmente, ligue uma nova máquina virtual para cada teste. Se ligar uma nova máquina virtual não for prático, pelo menos inicie um novo WebDriver para cada teste. Para Firefox, inicie um WebDriver com seu perfil conhecido.\nFirefoxProfile profile = new FirefoxProfile(new File(\u0026#34;pathToFirefoxProfile\u0026#34;)); WebDriver driver = new FirefoxDriver(profile); "},{"uri":"https://www.selenium.dev/documentation/pt-br/support_packages/chrome_devtools/","title":"Chrome Devtools","tags":[],"description":"","content":"As versões alfa do Selenium 4 têm aguardado suporte nativo para o protocolo Chrome DevTools por meio da interface \u0026ldquo;DevTools\u0026rdquo;. Isso nos ajuda a obter propriedades de desenvolvimento do Chrome, como cache de aplicativo, busca, rede, desempenho, criador de perfil, tempo de recurso, segurança e domínios de CDP de destino, etc.\nChrome DevTools é um conjunto de ferramentas de desenvolvedor da web integradas diretamente no navegador Google Chrome. DevTools pode ajudá-lo a editar páginas dinamicamente e diagnosticar problemas rapidamente, o que, em última análise, ajuda a criar sites melhores e mais rápidos.\nEmulando Geolocalização: Alguns aplicativos têm diferentes recursos e funcionalidades em diferentes locais. Automatizar esses aplicativos é difícil porque é difícil emular as localizações geográficas no navegador usando o Selenium. Mas com a ajuda de Devtools, podemos facilmente emulá-los. O trecho de código abaixo demonstra isso.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.devtools.DevTools; public void geoLocationTest(){ ChromeDriver driver = new ChromeDriver(); Map coordinates = new HashMap() {{ put(\u0026#34;latitude\u0026#34;, 50.2334); put(\u0026#34;longitude\u0026#34;, 0.2334); put(\u0026#34;accuracy\u0026#34;, 1); }}; driver.executeCdpCommand(\u0026#34;Emulation.setGeolocationOverride\u0026#34;, coordinates); driver.get(\u0026#34;\u0026lt;your site url\u0026gt;\u0026#34;); }   # Por favor inclua um PR para adicionar um exemplo de código   using System.Threading.Tasks; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.DevTools; // Replace the version to match the Chrome version using OpenQA.Selenium.DevTools.V87.Emulation; namespace dotnet_test { class Program { public static void Main(string[] args) { GeoLocation().GetAwaiter().GetResult(); } public static async Task GeoLocation() { ChromeDriver driver = new ChromeDriver(); DevToolsSession devToolsSession = driver.CreateDevToolsSession(); var geoLocationOverrideCommandSettings = new SetGeolocationOverrideCommandSettings(); geoLocationOverrideCommandSettings.Latitude = 51.507351; geoLocationOverrideCommandSettings.Longitude = -0.127758; geoLocationOverrideCommandSettings.Accuracy = 1; await devToolsSession .GetVersionSpecificDomains\u0026lt;OpenQA.Selenium.DevTools.V87.DevToolsSessionDomains\u0026gt;() .Emulation .SetGeolocationOverride(geoLocationOverrideCommandSettings); driver.Url = \u0026#34;\u0026lt;your site url\u0026gt;\u0026#34;; } } }   # Please raise a PR to add code sample   // Please raise a PR to add code sample    import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.devtools.DevTools fun main() { val driver = ChromeDriver() val coordinates : HashMap\u0026lt;String, Any\u0026gt; = HashMap\u0026lt;String, Any\u0026gt; () coordinates.put(\u0026#34;latitude\u0026#34;, 50.2334) coordinates.put(\u0026#34;longitude\u0026#34;, 0.2334) coordinates.put(\u0026#34;accuracy\u0026#34;, 1) driver.executeCdpCommand(\u0026#34;Emulation.setGeolocationOverride\u0026#34;, coordinates) driver.get(\u0026#34;https://www.google.com\u0026#34;) }     "},{"uri":"https://www.selenium.dev/documentation/pt-br/driver_idiosyncrasies/","title":"Idiossincrasias do driver","tags":[],"description":"","content":"Idiossincrasias do driver "},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/keyboard/","title":"Teclado","tags":[],"description":"","content":" Page being translated from English to Brazilian Portuguese. Do you speak Brazilian Portuguese? Help us to translate it by sending us pull requests!\n Keyboard represents a KeyBoard event. KeyBoard actions are performed by using low-level interface which allows us to provide virtualized device input to the web browser.\nsendKeys The sendKeys types a key sequence in DOM element even if modifier key sequence is encountered. Here are the list of possible keystrokes that WebDriver Supports.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.Keys;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.firefox.FirefoxDriver;\rpublic class HelloSelenium {\rpublic static void main(String[] args) {\rWebDriver driver = new FirefoxDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;);\r// Enter text \u0026#34;q\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;q\u0026#34; + Keys.ENTER);\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Firefox()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element(By.NAME, \u0026#34;q\u0026#34;).send_keys(\u0026#34;webdriver\u0026#34; + Keys.ENTER)\r \rusing (var driver = new FirefoxDriver())\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;webdriver\u0026#34; + Keys.Enter);\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :firefox\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;webdriver\u0026#39;, :return\rensure\rdriver.quit\rend\r \rconst {Builder, By, Key} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Enter text \u0026#34;webdriver\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;webdriver\u0026#39;, Key.ENTER);\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.firefox.FirefoxDriver\rfun main() {\rval driver = FirefoxDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Enter text \u0026#34;q\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;q\u0026#34; + Keys.ENTER)\r} finally {\rdriver.quit()\r}\r}\r \r  keyDown The keyDown is used to simulate action of pressing a modifier key(CONTROL, SHIFT, ALT)\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new ChromeDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;);\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;webdriver\u0026#34; + Keys.ENTER);\rActions actionProvider = new Actions(driver);\rAction keydown = actionProvider.keyDown(Keys.CONTROL).sendKeys(\u0026#34;a\u0026#34;).build();\rkeydown.perform();\r} finally {\rdriver.quit();\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Chrome()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element(By.NAME, \u0026#34;q\u0026#34;).send_keys(\u0026#34;webdriver\u0026#34; + Keys.ENTER)\r# Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r webdriver.ActionChains(driver).key_down(Keys.CONTROL).send_keys(\u0026#34;a\u0026#34;).perform()\r \rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;webdriver\u0026#34; + Keys.Enter);\r// Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r Actions actionProvider = new Actions(driver);\rIAction keydown = actionProvider.KeyDown(Keys.Control).SendKeys(\u0026#34;a\u0026#34;).Build();\rkeydown.Perform();\r}\rfinally\r{\rdriver.Quit();\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;webdriver\u0026#39;, :return\r# Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r driver.action.key_down(:control).send_keys(\u0026#39;a\u0026#39;).perform\rensure\rdriver.quit\rend\r \r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Enter text \u0026#34;webdriver\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;webdriver\u0026#39;, Key.ENTER);\r// Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r await driver.actions().keyDown(Key.CONTROL).sendKeys(\u0026#39;a\u0026#39;).perform();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.chrome.ChromeDriver\rimport org.openqa.selenium.interactions.Actions\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;webdriver\u0026#34; + Keys.ENTER)\rval action = Actions(driver)\r// Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r action.keyDown(Keys.CONTROL).sendKeys(\u0026#34;a\u0026#34;).build().perform()\r} finally {\rdriver.quit()\r}\r}\r \r  keyUp The keyUp is used to simulate key-up (or) key-release action of a modifier key(CONTROL, SHIFT, ALT)\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.Keys;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.WebElement;\rimport org.openqa.selenium.firefox.FirefoxDriver;\rimport org.openqa.selenium.interactions.Actions;\rpublic class HelloSelenium {\rpublic static void main(String[] args) {\rWebDriver driver = new FirefoxDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;);\rActions action = new Actions(driver);\r// Store google search box WebElement\r WebElement search = driver.findElement(By.name(\u0026#34;q\u0026#34;));\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.keyDown(Keys.SHIFT).sendKeys(search,\u0026#34;qwerty\u0026#34;).keyUp(Keys.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).perform();\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Chrome()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Store google search box WebElement\r search = driver.find_element(By.NAME, \u0026#34;q\u0026#34;)\raction = webdriver.ActionChains(driver)\r# Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.key_down(Keys.SHIFT).send_keys_to_element(search, \u0026#34;qwerty\u0026#34;).key_up(Keys.SHIFT).send_keys(\u0026#34;qwerty\u0026#34;).perform()\r \rusing OpenQA.Selenium;\rusing OpenQA.Selenium.Chrome;\rusing OpenQA.Selenium.Interactions;\rnamespace HelloSelenium\r{\rclass HelloSelenium\r{\rpublic static void Main(string[] args)\r{\rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\rActions action = new Actions(driver);\r// Store google search box WebElement\r IWebElement search = driver.FindElement(By.Name(\u0026#34;q\u0026#34;));\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.KeyDown(Keys.Shift).SendKeys(search, \u0026#34;qwerty\u0026#34;).KeyUp(Keys.Shift).SendKeys(\u0026#34;qwerty\u0026#34;).Perform();\r}\rfinally {\rdriver.Quit();\r}\r}\r}\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Store google search box WebElement\r search = driver.find_element(name: \u0026#39;q\u0026#39;)\r# Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r driver.action.key_down(:shift).send_keys(search,\u0026#39;qwerty\u0026#39;).key_up(:shift).send_keys(\u0026#34;qwerty\u0026#34;).perform\rensure\rdriver.quit\rend\r \rconst {Builder, By, Key} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Store google search box WebElement\r let search = driver.findElement(By.name(\u0026#39;q\u0026#39;));\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r await driver.actions().click(search).keyDown(Key.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).keyUp(Key.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).perform();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.chrome.ChromeDriver\rimport org.openqa.selenium.interactions.Actions\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Store google search box WebElement\r val search = driver.findElement(By.name(\u0026#34;q\u0026#34;))\rval action = Actions(driver)\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.keyDown(Keys.SHIFT).sendKeys(search, \u0026#34;qwerty\u0026#34;).keyUp(Keys.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).build().perform()\r} finally {\rdriver.quit()\r}\r}\r \r  clear Clears the content of an editable element. This is only applied for the elements which is editable and interactable, otherwise Selenium returns the error (invalid element state (or) Element not interactable)\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.WebElement;\rimport org.openqa.selenium.chrome.ChromeDriver;\rpublic class clear {\rpublic static void main(String[] args) {\rWebDriver driver = new ChromeDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://www.google.com\u0026#34;);\r// Store \u0026#39;SearchInput\u0026#39; element\r WebElement searchInput = driver.findElement(By.name(\u0026#34;q\u0026#34;));\rsearchInput.sendKeys(\u0026#34;selenium\u0026#34;);\r// Clears the entered text\r searchInput.clear();\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rdriver = webdriver.Chrome()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Store \u0026#39;SearchInput\u0026#39; element\r SearchInput = driver.find_element(By.NAME, \u0026#34;q\u0026#34;)\rSearchInput.send_keys(\u0026#34;selenium\u0026#34;)\r# Clears the entered text\r SearchInput.clear()\r \rusing OpenQA.Selenium;\rusing OpenQA.Selenium.Chrome;\rusing System;\rnamespace SnipetProjectDelete\r{\rclass Program\r{\rstatic void Main(string[] args)\r{\rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(@\u0026#34;https://www.google.com\u0026#34;);\r// Store \u0026#39;SearchInput\u0026#39; element\r IWebElement searchInput = driver.FindElement(By.Name(\u0026#34;q\u0026#34;));\rsearchInput.SendKeys(\u0026#34;selenium\u0026#34;);\r// Clears the entered text\r searchInput.Clear();\r}\rfinally\r{\rdriver.Quit();\r}\r}\r}\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# store \u0026#39;search_input\u0026#39; element\r search_input = driver.find_element(name: \u0026#39;q\u0026#39;)\rsearch_input.send_keys(\u0026#39;selenium\u0026#39;)\r# Clears the entered text\r search_input.clear\rensure\rdriver.quit\rend\r \rconst {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Store \u0026#39;SearchInput\u0026#39; element\r let searchInput = driver.findElement(By.name(\u0026#39;q\u0026#39;));\rawait searchInput.sendKeys(\u0026#34;selenium\u0026#34;);\r// Clears the entered text\r await searchInput.clear();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.chrome.ChromeDriver\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://www.google.com\u0026#34;)\r// Store \u0026#39;searchInput\u0026#39; element\r val searchInput = driver.findElement(By.name(\u0026#34;q\u0026#34;))\rsearchInput.sendKeys(\u0026#34;selenium\u0026#34;)\r// Clears the entered text\r searchInput.clear()\r} finally {\rdriver.quit()\r}\r}\r \r  "},{"uri":"https://www.selenium.dev/documentation/pt-br/support_packages/","title":"Pacotes de suporte","tags":[],"description":"","content":"Pacotes de suporte "},{"uri":"https://www.selenium.dev/documentation/pt-br/legacy_docs/","title":"Legado","tags":[],"description":"","content":"Legado Nesta seção você pode encontrar toda a documentação relacionada aos componentes legados do Selenium. Isso deve ser mantido puramente por razões históricas e não como um incentivo para o uso obsoleto componentes.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/front_matter/","title":"Prefácio","tags":[],"description":"","content":"Prefácio "},{"uri":"https://www.selenium.dev/documentation/pt-br/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://www.selenium.dev/documentation/pt-br/contributing/","title":"Contribuindo com o Site e Documentação do Selenium","tags":[],"description":"","content":"Selenium é um grande projeto de software, seu site e documentação são fundamentais para entender como as coisas funcionam e aprender maneiras eficazes de explorar seu potencial.\nEste projeto contém o site e a documentação do Selenium. Isto é um esforço contínuo (não direcionado a nenhuma versão específica) para fornecer informações atualizadas sobre como usar o Selenium de forma eficaz, como se envolver e como contribuir para o Selenium.\nAs contribuições para o site e documentação seguem o processo descrito na seção abaixo sobre contribuições. Você deveria passar algum tempo familiarizando-se com a documentação lendo mais sobre isso.\n O projeto Selenium recebe contribuições de todos. Há um várias maneiras de ajudar:\nReportar um problema Ao relatar um novo problema ou comentar sobre problemas existentes, por favor certifique-se de que as discussões estão relacionadas a questões técnicas concretas sobre o software Selenium, seu site e/ou documentação.\nTodos os componentes do Selenium mudam bastante rápido ao longo do tempo, então este pode fazer com que a documentação fique desatualizada. Se você observar que este é o caso, como mencionado, não hesite em criar um problema para isso. Também pode ser possível que você saiba como atualizar a documentação, então, envie-nos um Pull Request com a alteração.\nSe você não tem certeza se o que encontrou é um problema ou não, pergunte através dos canais de comunicação descritos em https://selenium.dev/support.\nContribuições O projeto Selenium dá as boas-vindas a novos contribuidores. Indivíduos fazendo contribuições significativas e valiosas ao longo do tempo são transformados em Committers e recebem acesso de commit ao projeto.\nEste guia irá guiá-lo através do processo de contribuição.\nPasso 1: Fork Faça um fork do projeto no Github e faça checkout na sua cópia localmente.\n% git clone git@github.com:seleniumhq/seleniumhq.github.io.git % cd seleniumhq.github.io Dependências: Hugo Usamos Hugo para construir e renderizar o site e documentação. Para verificar tudo localmente antes mesmo de fazer qualquer alteração, por favor instale Hugo, familiarize-se com ele e execute o servidor local para renderizar o site localmente (instruções detalhadas podem ser encontradas no próximos passos).\nPasso 2: Branch Crie uma branch e comece a hackear:\n% git checkout -b my-feature-branch Praticamos o desenvolvimento baseado em HEAD, o que significa que todas as mudanças são aplicadas diretamente no topo do trunk.\nPasso 3: Faça mudanças O repositório contém o site e documentação, que são dois projetos Hugo separados. Se você quiser fazer alterações no site, trabalhe no diretório site_source_files. Para ver uma prévia ao vivo de suas alterações, execute hugo server no diretório raiz do site.\n% cd site_source_files % hugo server Para fazer alterações na documentação, vá para o diretório docs_source_files.\n% cd docs_source_files % hugo server A documentação é traduzida para vários idiomas e as traduções são baseadas no conteúdo em inglês. Ao alterar um arquivo, certifique-se de realizar a mudanças em todos os outros arquivos traduzidos também. Isso pode ser diferente dependendo sobre a mudança, por exemplo:\n Se você adicionar um exemplo de código ao arquivo browser_manipulation.en.md, também adicione-o a browser_manipulation.es.md, browser_manipulation.ef.md, browser_manipulation.ja.md, e todos os outros arquivos traduzidos. Se você encontrar uma tradução que possa ser melhorada, altere apenas o arquivo traduzido. Se você estiver adicionando uma nova tradução de idioma, adicione os novos arquivos com o sufixo apropriado. Não há necessidade de traduzir tudo para enviar um PR, pode ser feito iterativamente. Não se esqueça de verificar algumas configurações necessárias de valores no arquivo config.toml. Se você fizer alterações de texto na versão em inglês, substitua a mesma seção em os arquivos traduzidos com sua alteração (sim, em inglês), e adicione o seguinte observe na parte superior do arquivo.  {{% notice info %}} \u0026lt;i class=\u0026#34;fas fa-language\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; Page being translated from English to {LANGUAGE}. Do you speak {LANGUAGE}? Help us to translate it by sending us pull requests! {{% /notice %}} Passo 4: Commit Primeiro, certifique-se de que o git saiba seu nome e endereço de e-mail:\n% git config --global user.name \u0026#39;Santa Claus\u0026#39; % git config --global user.email \u0026#39;santa@example.com\u0026#39; Escrever boas mensagens de commit é importante. Uma mensagem de confirmação deve descrever o que mudou, por que e conter referência de problemas corrigidos (se houver). Siga estas diretrizes ao escrever um:\n A primeira linha deve ter cerca de 50 caracteres ou menos e conter uma breve da descrição da mudança. Mantenha a segunda linha em branco. Quebra todas as outras linhas em 72 colunas. Incluir Fixes # N, onde N é o número do problema que o commit corrige se houver.  Uma boa mensagem de confirmação pode ter a seguinte aparência:\nexplain commit normatively in one line Body of commit message is a few lines of text, explaining things in more detail, possibly giving some background about the issue being fixed, etc. The body of the commit message can be several paragraphs, and please do proper word-wrap and keep columns shorter than about 72 characters or so. That way `git log` will show things nicely even when it is indented. Fixes #141 A primeira linha deve ser significativa, pois é o que as pessoas veem quando executam git shortlog ou git log --oneline.\nPasso 5: Rebase Use git rebase (não git merge) para sincronizar seu trabalho de tempos em tempos.\n% git fetch upstream % git rebase upstream/trunk Passo 6: Teste Lembre-se sempre de executar o servidor local, com isso, você pode ter certeza de que suas alterações não prejudicaram nada.\nPasso 7: Push % git push origin my-feature-branch Acesse https://github.com/yourusername/seleniumhq.github.io.git e clique em Pull Request e preencha o formulário. Por favor indique que você assinou o CLA (consulte a Etapa 7).\nOs Pull Requests geralmente são revisados em alguns dias. Se houver comentários a abordar, aplique suas alterações em novos commits (de preferência fixups) e envie para a mesma branch.\nPasso 8: Integração Quando a revisão do código for concluída, um committer integrará seu PR no branch de tronco do repositório. Porque gostamos de manter um histórico linear no trunk, nós normalmente iremos dar Squash \u0026amp; Rebase no histórico da sua branch.\nComunicação Todos os detalhes sobre como se comunicar com os colaboradores do projeto e a comunidade em geral podem ser encontrados em https://selenium.dev/support\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/","title":"O Projeto Selenium de Automação de Navegadores","tags":[],"description":"","content":"O Projeto Selenium de Automação de Navegadores Selenium é um projeto que abrange uma variedade de ferramentas e bibliotecas que permitem e suportam a automação de navegadores da web.\nEle fornece extensões para emular a interação do usuário com os navegadores, um servidor de distribuição para escalonar a alocação do navegador, e a infraestrutura para implementações da Especificação W3C WebDriver que permite escrever código intercambiável para todos os principais navegadores da web.\nEste projeto é possível graças a colaboradores voluntários que dedicam milhares de horas de seu próprio tempo, e disponibilizaram o código-fonte disponível gratuitamente para qualquer um usar, aproveitar e melhorar.\nSelenium reúne criadores de navegadores, engenheiros e entusiastas para promover uma discussão aberta sobre a automação da plataforma da web. O projeto organiza uma conferência anual para ensinar e nutrir a comunidade.\nNo núcleo do Selenium está WebDriver, uma interface para escrever conjuntos de instruções que podem ser executados alternadamente em muitos navegadores. Aqui está uma das instruções mais simples que você pode fazer:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.Keys; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; import org.openqa.selenium.support.ui.WebDriverWait; import static org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated; import java.time.Duration; public class HelloSelenium { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10)); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); WebElement firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))); System.out.println(firstResult.getAttribute(\u0026#34;textContent\u0026#34;)); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support.expected_conditions import presence_of_element_located #Este exemplo requer o Selenium WebDriver 3.13 ou mais novo with webdriver.Firefox() as driver: wait = WebDriverWait(driver, 10) driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.find_element(By.NAME, \u0026#34;q\u0026#34;).send_keys(\u0026#34;cheese\u0026#34; + Keys.RETURN) first_result = wait.until(presence_of_element_located((By.CSS_SELECTOR, \u0026#34;h3\u0026gt;div\u0026#34;))) print(first_result.get_attribute(\u0026#34;textContent\u0026#34;))   using System; using OpenQA.Selenium; using OpenQA.Selenium.Firefox; using OpenQA.Selenium.Support.UI; class HelloSelenium { static void Main() { using(IWebDriver driver = new FirefoxDriver()) { WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10)); driver.Navigate().GoToUrl(\u0026#34;https://www.google.com/ncr\u0026#34;); driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;cheese\u0026#34; + Keys.Enter); wait.Until(driver =\u0026gt;driver.FindElement(By.CssSelector(\u0026#34;h3\u0026gt;div\u0026#34;)).Displayed); IWebElement firstResult = driver.FindElement(By.CssSelector(\u0026#34;h3\u0026gt;div\u0026#34;)); Console.WriteLine(firstResult.GetAttribute(\u0026#34;textContent\u0026#34;)); } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox wait = Selenium::WebDriver::Wait.new(timeout: 10) begin driver.get \u0026#39;https://google.com/ncr\u0026#39; driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;cheese\u0026#39;, :return first_result = wait.until { driver.find_element(css: \u0026#39;h3\u0026gt;div\u0026#39;) } puts first_result.attribute(\u0026#39;textContent\u0026#39;) ensure driver.quit end   const {Builder, By, Key, until} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Enter text \u0026#34;cheese\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;  await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;cheese\u0026#39;, Key.ENTER); let firstResult = await driver.wait(until.elementLocated(By.css(\u0026#39;h3\u0026gt;div\u0026#39;)), 10000); console.log(await firstResult.getAttribute(\u0026#39;textContent\u0026#39;)); } finally{ driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.Keys import org.openqa.selenium.firefox.FirefoxDriver import org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated import org.openqa.selenium.support.ui.WebDriverWait import java.time.Duration fun main() { val driver = FirefoxDriver() val wait = WebDriverWait(driver, Duration.ofSeconds(10)) try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER) val firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))) println(firstResult.getAttribute(\u0026#34;textContent\u0026#34;)) } finally { driver.quit() } }     Veja o Tour rápido para uma explicação completa do que acontece nos bastidores quando você executa este código. Você deve continuar para a documentação narrativa para entender como você pode instalar e usar o Selenium como uma ferramenta de automação de teste com sucesso, e escalar testes simples como este para executar em ambientes grandes e distribuídos em vários navegadores, em vários sistemas operacionais diferentes.\nIntrodução Se você é um usuário novo de Selenium, temos alguns recursos que podem te ajudar a agilizar o seu aprendizado.\n Tour rápido  WebDriver IDE Grid    "},{"uri":"https://www.selenium.dev/documentation/pt-br/tags/","title":"Tags","tags":[],"description":"","content":""}]