[{"uri":"https://www.selenium.dev/documentation/pt-br/worst_practices/two_factor_authentication/","title":"Autenticação de Dois Fatores (2FA)","tags":[],"description":"","content":"A autenticação de dois fatores, conhecida como 2FA, é um mecanismo de autorização onde a senha de uso único (OTP) é gerada usando aplicativos móveis \u0026ldquo;Autenticadores\u0026rdquo;, como \u0026ldquo;Google Authenticator\u0026rdquo;, \u0026ldquo;Microsoft Authenticator\u0026rdquo; etc., ou por SMS, e-mail para autenticação. Automatizar isso perfeitamente e consistentemente é um grande desafio no Selenium. Existem algumas maneiras para automatizar este processo. Mas essa será outra camada em cima de nossos testes Selenium e não protegidos também. Portanto, você pode evitar a automação do 2FA.\nExistem algumas opções para contornar as verificações 2FA:\n Desative 2FA para determinados usuários no ambiente de teste, para que você possa usar essas credenciais de usuário na automação. Desative 2FA em seu ambiente de teste. Desative 2FA se você fizer o login de determinados IPs. Dessa forma, podemos configurar nosso teste os IPs da máquina para evitar isso.  "},{"uri":"https://www.selenium.dev/documentation/pt-br/worst_practices/captchas/","title":"Captchas","tags":[],"description":"","content":"CAPTCHA, abreviação de Completely Automated Public Turing test to tell Computers and Humans Apart, foi projetado explicitamente para impedir a automação, portanto, não tente! Existem duas estratégias principais para contornar as verificações CAPTCHA:\n Desative CAPTCHAs em seu ambiente de teste Adicione um hook para permitir que os testes ignorem o CAPTCHA  "},{"uri":"https://www.selenium.dev/documentation/pt-br/getting_started/","title":"Começando","tags":[],"description":"","content":"Começando Se você é um usuário novo de Selenium, temos alguns recursos que podem te ajudar a agilizar o seu aprendizado.\n Tour rápido  WebDriver IDE Grid    "},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/grid_3/components_of_a_grid/","title":"Componentes","tags":[],"description":"","content":"Hub  Intermediário e gerente Aceita solicitações para executar testes Recebe instruções do cliente e as executa remotamente nos nós Gerencia tópicos  Um Hub é um ponto central para onde todos os seus testes são enviados. Cada Selenium Grid consiste em exatamente um hub. O hub precisa estar acessível dos respectivos clientes (ou seja, servidor de CI, máquina do desenvolvedor etc.) O hub irá conectar um ou mais nós aos quais os testes serão delegados.\nNós  Onde vivem os navegadores Registra-se no hub e comunica seus recursos Recebe solicitações do hub e as executa  Nodes são diferentes instâncias do Selenium que executarão testes em sistemas de computador individuais. Pode haver muitos nós em uma grade. As máquinas que são nós não precisam ser da mesma plataforma ou ter a mesma seleção de navegador do hub ou de outros nós. Um nó no Windows pode ter a capacidade de oferecer o Internet Explorer como uma opção de navegador, considerando que isso não seria possível no Linux ou Mac.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/grid_4/components_of_a_grid/","title":"Componentes","tags":[],"description":"","content":"  There are certain paragaraphs needs translation from English to Portuguese. Do you speak Portuguese? Help us to translate it by sending us pull requests!\n Roteador O roteador se encarrega de encaminhar a solicitação para o componente correto.\nÉ o ponto de entrada da Grid, todas as solicitações externas serão recebidas por ele. O roteador se comporta de maneira diferente dependendo da solicitação. Se for uma nova sessão, o roteador irá encaminhá-la para o enfileirador de sessão, que irá adicioná-la a nova fila de sessão. O Enfileirador de Sessão irá disparar um evento através do Event Bus. O Distribuidor (onde a criação da nova sessão será tratada) irá receber o evento e pesquisar o Enfileirador de Sessão para obter a nova solicitação de sessão. Se a solicitação pertencer a uma sessão existente, o roteador irá enviar a ID da sessão para o Mapa da Sessão, e o Mapa da Sessão irá retornar o Nó onde a sessão está rodando. Depois disso, o roteador irá encaminhar a solicitação ao Nó.\nO Roteador visa equilibrar a carga na Rede, enviando as solicitações para o componente que é capaz de lidar melhor com eles, sem sobrecarregar nenhum componente que não é necessário no processo.\nDistribuidor O Distribuidor está ciente de todos os nós e suas capacidades. Seu papel principal é receber um novo pedido de sessão e encontrar um Nó adequado onde a sessão pode ser criada. Depois que a sessão é criada, o Distribuidor armazena no Mapa da Sessão a relação entre o ID da sessão e o nó onde a sessão está sendo executada.\nNó Um Nó pode estar presente várias vezes em uma Grid. Cada nó cuida de gerenciar os slots para os navegadores disponíveis da máquina onde está sendo executado.\nO Nó se registra no Distribuidor através do Event Bus, e sua configuração é enviada como parte da mensagem de registro.\nPor padrão, o Nó registra automaticamente todos os drivers de navegador disponíveis no PATH da máquina onde ele roda. Ele também cria um slot por CPU disponível para navegadores baseados em Chromium e Firefox. Para Safari e Internet Explorer, apenas um slot é criado. Por meio de uma configuração específica, ele pode executar sessões em contêineres Docker. Você pode ver mais detalhes de configuração na próxima seção.\nUm Nó apenas executa os comandos recebidos, não avalia, não faz julgamentos, ou controlar qualquer coisa. As máquinas onde o Nó está rodando não precisam ter o mesmo sistema operacional que os outros componentes. Por exemplo, um nó do Windows pode ter a capacidade de oferecer o Internet Explorer como uma opção de navegador, considerando que isso não seria possível no Linux ou Mac.\nSession Map The Session Map is a data store that keeps the information of the session id and the Node where the session is running. It serves as a support for the Router in the process of forwarding a request to the Node. The Router will ask the Session Map for the Node associated to a session id.\nEnfileirador de Sessão, Fila de Sessão O Enfileirador de Sessão é o único componente que pode se comunicar com a nova fila de sessão. Ele lida com todas as operações de fila (como add) para manipular a fila. Possui parâmetros configuráveis ​​para definir o tempo limite da solicitação e o intervalo de repetição da solicitação.\nA Fila de Sessão recebe a nova solicitação de sessão do Roteador e a adiciona à fila. O enfileirador espera até receber a resposta para a solicitação. Se a solicitação expirar, ela será rejeitada imediatamente e não adicionada à fila.\nAo adicionar com sucesso a solicitação à fila, o Event Bus aciona um evento. O Distribuidor seleciona este evento e pesquisa a fila. Agora ele tenta criar uma sessão.\nSe os recursos solicitados não existirem em nenhum dos nós registrados, a solicitação será rejeitada imediatamente e o cliente recebe uma resposta.\nSe os recursos solicitados corresponderem aos recursos de qualquer um dos slots de Nó, o Distribuidor tenta obter o slot disponível. Se todos os slots estiverem ocupados, o Distribuidor pedirá ao enfileirador para adicionar o pedido para o início da fila. O Distribuidor recebe a solicitação novamente após o intervalo de repetição da solicitação. Ele tentará novas tentativas até que a solicitação seja bem-sucedida ou tenha expirado. Se a solicitação atingir o tempo limite ao tentar novamente ou adicionar à frente da fila, ela será rejeitada.\nDepois de obter um slot disponível e a criação de sessão, o Distribuidor passa a nova resposta de sessão para a nova fila de espera de sessão por meio do Event Bus. Enfileirador de Sessão responderá ao cliente quando ele recebe o evento.\nEvent Bus The Event Bus serves as a communication path between the Nodes, Distributor, New Session Queuer, and Session Map. The Grid does most of its internal communication through messages, avoiding expensive HTTP calls. When starting the Grid in its fully distributed mode, the Event Bus is the first component that should be started.\nFunções na Grid Na Grade 3, os componentes eram Hub e Nó, e era possível executá-los juntos iniciando a Grid em modo autônomo. O mesmo conceito está disponível na Grid 4, é possível executar um hub agrupando alguns dos componentes descritos acima, e também é possível executar todos os componentes juntos em um modo autônomo.\nHub Hub é a união dos seguintes componentes:\n Roteador Distribuidor Mapa da Sessão Enfileirador de Sessão Event Bus  Habilita a configuração clássica de hub e nó(s).\nStandalone Como mencionado antes, Standalone é a união de todos os componentes e, aos olhos do usuário, eles são executado como um. Isso inclui todos os componentes que fazem parte do hub, mais um nó. Totalmente Uma Grid totalmente funcional está disponível após iniciá-la no modo Standalone.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/front_matter/copyright_and_attributions/","title":"Direitos autorais e atribuições","tags":[],"description":"","content":"A Documentação do Selenium Copyright \u0026copy; 2013-2021 , Software Freedom Conservancy.\nTodo esforço foi feito para tornar esta documentação a mais completa e precisa possível, mas nenhuma garantia ou adequação está implícita. As informações fornecidas são \u0026ldquo;no estado em que se encontram\u0026rdquo;. Os autores e a editora não terão qualquer responsabilidade para com qualquer pessoa ou entidade com relação a quaisquer perdas ou danos decorrentes das informações contidas neste livro. Nenhuma responsabilidade de patente é assumida com relação ao uso das informações aqui contidas.\nAtribuições Agradecimentos: Selenium Main Repository .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors  div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors  div label { padding-left: 4px; } .ghContributors  div span { font-size: x-small; padding-left: 4px; }  @shs96c4996 commits  @barancev3351 commits  @jimevans2380 commits  @jleyba1464 commits  @jarib1298 commits  @dfabulich1175 commits  @illicitonion1162 commits  @AutomatedTester1076 commits  @lukeis599 commits  @eranmes473 commits  @titusfortner416 commits  @p0deje400 commits  @mdub326 commits  @andreastt289 commits  @diemol278 commits  @krosenvold225 commits  @hugs205 commits  @davehunt200 commits  @hbchai191 commits  @lmtierney179 commits  @ph7147 commits  @freynaud138 commits  @samitbadle137 commits  @nirvdrum133 commits  @sevaseva115 commits  @gigix109 commits  @juangj108 commits  @aslakhellesoy94 commits  @alex-savchuk90 commits  @pujagani87 commits  @harsha50975 commits  @andrashatvani66 commits  @ajayk63 commits  @twalpole49 commits  @asashour48 commits  @mikemelia46 commits  @jherault44 commits  @tebeka44 commits  @raju24942 commits  @santiycr41 commits  @luke-hill39 commits  @mach636 commits  @ddavison32 commits  @joshbruning30 commits  @mikebroberts28 commits  @JohnChen027 commits  @valfirst25 commits  @alb-i98622 commits  @bret20 commits  @cgoldberg20 commits  @corevo20 commits  @by-example19 commits  @rbri16 commits  @krmahadevan14 commits  @bayandin12 commits  @carlosgcampos12 commits  @jayakumarc12 commits  @machinexa211 commits  @43081j11 commits  @detro10 commits  @josephg10 commits  @redsquirrel9 commits  @isaulv9 commits  @RustyNail9 commits  @InstyleVII8 commits  @tourdedave8 commits  @bwalderman7 commits  @glib-briia7 commits  @llaskin7 commits  @DrMarcII7 commits  @mmerrell7 commits  @User2534897 commits  @dratler7 commits  @dima-groupon6 commits  @nikolas6 commits  @shucon6 commits  @Herst5 commits  @jimvm5 commits  @JohanLorenzo5 commits  @nschonni5 commits  @seanpoulter5 commits  @oddui5 commits  @adiohana5 commits  @Zitrax4 commits  @dbo4 commits  @xaircore4 commits  @bongosway4 commits  @sangaline4 commits  @lauromoura4 commits  @Ardesco4 commits  @klepikov4 commits  @tobli4 commits  @ulfjack4 commits  @yizeng4 commits  @abotalov4 commits  @burg4 commits  @dylanlive4 commits  @JasnoWa4 commits  @mcharsley4 commits  @GQAssurance4 commits   Selenium IDE .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors  div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors  div label { padding-left: 4px; } .ghContributors  div span { font-size: x-small; padding-left: 4px; }  @corevo2445 commits  @tourdedave610 commits  @baimao843788 commits  @Jongkeun51 commits  @petermouse36 commits  @LinYunWen36 commits  @zavelevsky34 commits  @xdennisx15 commits  @AutomatedTester15 commits  @raju24912 commits  @dependabot[bot]10 commits  @dvd9006 commits  @manoj97883 commits  @shs96c3 commits  @zewa6663 commits  @diemol2 commits  @lukeis2 commits  @Meir0172 commits  @toshiya2 commits  @marknoble2 commits  @amitzur1 commits  @aplorenzen1 commits  @p26351 commits  @avoid3d1 commits  @sotayamashita1 commits  @samitbadle1 commits  @swes11171 commits  @vivrichards6001 commits  @bolasblack1 commits  @peter-kehl1 commits   Docker Selenium .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors  div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors  div label { padding-left: 4px; } .ghContributors  div span { font-size: x-small; padding-left: 4px; }  @diemol352 commits  @ddavison133 commits  @mtscout653 commits  @kayabendroth50 commits  @selenium-ci35 commits  @elgalu24 commits  @WillAbides8 commits  @marten-cz5 commits  @MacCracken5 commits  @jsa345 commits  @garagepoort4 commits  @METAJIJI4 commits  @manoj97884 commits  @ZainabSalameh4 commits  @vasikarla4 commits  @chenrui3334 commits  @niQo4 commits  @testphreak4 commits  @Remi-p3 commits  @tnguyen143 commits  @alexgibson3 commits  @jeff-jk3 commits  @pabloFuente3 commits  @chuckg2 commits  @davehunt2 commits  @ehbello2 commits  @glib-briia2 commits  @joaoluizjoaquim2 commits  @mathieu-pousse2 commits  @phensley2 commits  @ryneeverett2 commits  @wheleph2 commits  @evertones2 commits  @kmala2 commits  @schmunk422 commits  @a-k-g1 commits  @alexkogon1 commits  @v1-wizard1 commits  @sahajamit1 commits  @deviantintegral1 commits  @anto-ac1 commits  @Grisu1181 commits  @gensc0041 commits  @budtmo1 commits  @charford1 commits  @cyrille-leclerc1 commits  @deiwin1 commits  @enolan1 commits  @glogiotatidis1 commits  @hbouhadji1 commits  @hnryjms1 commits  @doublemarket1 commits  @hazmeister1 commits  @McGriddle1 commits  @jamesottaway1 commits  @jarspi1 commits  @BeyondEvil1 commits  @ja8zyjits1 commits  @jwhitlock1 commits  @jonaseicher1 commits  @CaffeinatedCM1 commits  @karel19801 commits  @lcnja1 commits  @lmtierney1 commits  @luisfcorreia1 commits  @lukeis1 commits  @manusa1 commits  @m15o1 commits  @matzegebbe1 commits  @michallepicki1 commits  @mikewrighton1 commits  @meeroslaph1 commits  @nipafx1 commits  @double161 commits  @reinholdfuereder1 commits  @remcorakers1 commits  @rjatkins1 commits  @tuxiqae1 commits  @scottturley1 commits  @sethuster1 commits  @smccarthy1 commits  @smccarthy-godaddy1 commits  @srguglielmo1 commits  @stigkj1 commits  @tadashi07131 commits  @gitter-badger1 commits  @graingert1 commits  @ThomasMeschke1 commits  @cvakiitho1 commits  @torstenwalter1 commits  @victor-catalyst1 commits  @VinodAnandan1 commits  @vv-p1 commits  @wesmcouch1 commits  @zoltanmeze1 commits  @reegnz1 commits  @amuthansakthivel1 commits  @Deycoesr1 commits  @eitany1 commits  @miyajan1 commits   Selenium Website e Docs .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors  div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors  div label { padding-left: 4px; } .ghContributors  div span { font-size: x-small; padding-left: 4px; }  @harsha509344 commits  @selenium-ci323 commits  @diemol237 commits  @alaahong61 commits  @boris77932 commits  @alenros28 commits  @kzhirata27 commits  @AlexAndradeSan25 commits  @manoj978820 commits  @jmartinezpoq18 commits  @ivanrodjr17 commits  @AutomatedTester13 commits  @pujagani12 commits  @sindhudiddi12 commits  @hiroksarker10 commits  @nwintop8 commits  @Greavox6 commits  @liushilive6 commits  @nainappa5 commits  @hyanx5 commits  @lvninety5 commits  @barancev4 commits  @kjayachandra20004 commits  @ant91124 commits  @TritzA3 commits  @Arc-Jung3 commits  @ArCiGo3 commits  @gnatcatcher-bg3 commits  @gustavoefeiche3 commits  @Madh933 commits  @rajeevbarde3 commits  @raju2493 commits  @shs96c3 commits  @takeya0x863 commits  @TestOpsCloudchen3 commits  @cambiph3 commits  @twinstae3 commits  @Tolerblanc3 commits  @Bredda2 commits  @bongosway2 commits  @kapilyadav12042 commits  @mookkiah2 commits  @palotas2 commits  @miekof2 commits  @natanportilho2 commits  @rahuljhakant2 commits  @titusfortner2 commits  @urig2 commits  @ilhanoztozlu2 commits  @coodjokergl2 commits  @imba-tjd2 commits  @0420syj2 commits  @k198107032 commits  @abhi28101 commits  @abhishek-malani1 commits  @adithyab941 commits  @alexako1 commits  @vinogradoff1 commits  @amirmojiry1 commits  @sahajamit1 commits  @beatfactor1 commits  @fiveych1 commits  @Archibaald-dev1 commits  @cjayswal1 commits  @SalmonMode1 commits  @dbudim1 commits  @dylanlive1 commits  @fastrde1 commits  @f97gujo1 commits  @HollowMan61 commits  @joft-ware1 commits  @itconsultant1 commits  @jsoref1 commits  @Juan-Arano1 commits  @idkaryan1 commits  @madarche1 commits  @skyhirider1 commits  @marknoble1 commits  @bisforum1 commits  @Michael4d451 commits  @mherrmann1 commits  @misiekofski1 commits  @muditlambda1 commits  @nikhil-lambda1 commits  @TheTestLynx1 commits  @OndraM1 commits  @palbr1 commits  @Peyton881 commits  @MindScriptAct1 commits  @RustyNail1 commits  @Saketspradhan1 commits  @shucon1 commits  @momoto1 commits  @sergey-oplavin1 commits  @harsha15021 commits  @masakazutakewaka1 commits  @thiagola921 commits  @ThbtSprt1 commits  @tmfink101 commits  @TS0001 commits   Website Selenium Anterior .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors  div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors  div label { padding-left: 4px; } .ghContributors  div span { font-size: x-small; padding-left: 4px; }  @lukeis417 commits  @shs96c91 commits  @tourdedave89 commits  @pgrandje79 commits  @barancev63 commits  @lightbody59 commits  @ajayk40 commits  @tarun3kumar40 commits  @ddavison36 commits  @davehunt26 commits  @manoj978824 commits  @peter-kehl22 commits  @lmtierney21 commits  @samitbadle21 commits  @santiycr19 commits  @illicitonion17 commits  @pnewhook14 commits  @AutomatedTester12 commits  @rasmusbergpalm11 commits  @juangj11 commits  @lukeis-sfdc10 commits  @andreastt7 commits  @hugs6 commits  @jarib5 commits  @jimevans5 commits  @llaskin5 commits  @PaulKC5 commits  @titusfortner5 commits  @corevo5 commits  @diemol3 commits  @asashour2 commits  @oleksandr-lobunets2 commits  @alex-savchuk2 commits  @javabrett2 commits  @darrincherry2 commits  @eranmes2 commits  @hazmeister2 commits  @julianharty2 commits  @mikemelia2 commits  @paul-hammant2 commits  @labkey-tchad2 commits  @abhijain26182 commits  @agabrys1 commits  @azawawi1 commits  @alb-i9861 commits  @hollingsworthd1 commits  @dylans1 commits  @EmidioStani1 commits  @FagnerMartinsBrack1 commits  @Xaeroxe1 commits  @JamesZoft1 commits  @jleyba1 commits  @JasnoWa1 commits  @JustAGuyTryingToCodeSomething1 commits  @kdamball1 commits  @laurin11 commits  @klamping1 commits  @krmahadevan1 commits  @krosenvold1 commits  @mmerrell1 commits  @grawk1 commits  @mcavigelli1 commits  @michaelwowro1 commits  @muralidharand1 commits  @meeroslaph1 commits  @NickAb1 commits  @ohadschn1 commits  @oifland1 commits  @rbri1 commits  @roydekleijn1 commits  @QuinnWilton1 commits  @smatei1 commits  @harrissAvalon1 commits  @stevedesmond-ca1 commits  @Vimal-N1 commits  @yasinguzel1 commits  @tobecrazy1 commits  @Zearin1 commits  @beckendorff1 commits  @daveOrleans1 commits  @androiddriver1 commits  @mauk811 commits  @pharry221 commits  @prab21121 commits  @refactoror1 commits  @rogerdc1 commits  @tibord1 commits  @ygmarchi1 commits   Projeto de Re-escrita da Documentação Anterior .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors  div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors  div label { padding-left: 4px; } .ghContributors  div span { font-size: x-small; padding-left: 4px; }  @andreastt197 commits  @selenium-ci105 commits  @diemol54 commits  @hazmeister30 commits  @santiycr27 commits  @AlexAndradeSan25 commits  @lukeis21 commits  @harsha50917 commits  @ddavison16 commits  @davehunt12 commits  @manoj978812 commits  @orieken12 commits  @djangofan12 commits  @liushilive8 commits  @User2534897 commits  @jimholmes6 commits  @imba-tjd6 commits  @mmerrell6 commits  @shs96c6 commits  @picimako5 commits  @vijay445 commits  @cambiph5 commits  @nvonop4 commits  @rivlinp4 commits  @sheg4 commits  @bizob28284 commits  @detro3 commits  @Ardesco3 commits  @TheTestLynx3 commits  @boris7792 commits  @Bredda2 commits  @juperala2 commits  @lmtierney2 commits  @systemboogie2 commits  @palotas2 commits  @miekof2 commits  @sri852 commits  @hoanluu2 commits  @ilhanoztozlu2 commits  @paul-barton2 commits  @adithyab941 commits  @alenros1 commits  @p0deje1 commits  @AJ-721 commits  @abotalov1 commits  @bhardin1 commits  @chamiz1 commits  @dennybiasiolli1 commits  @donhuvy1 commits  @bongosway1 commits  @nicegraham1 commits  @f97gujo1 commits  @austenjt1 commits  @kmcgon1 commits  @MartinDelille1 commits  @michael-coleman1 commits  @misiekofski1 commits  @MilanMasek1 commits  @rakib-amin1 commits  @NRezek1 commits  @nikai3d1 commits  @OndraM1 commits  @sourabhkt1 commits  @whhone1 commits  @yarix1 commits  @ZbigniewZabost1 commits  @agmen1 commits  @hking-shutterfly1 commits  @jimevans1 commits  @9484624481 commits  @marilyn1 commits  @riccione1 commits  @tungla1 commits  @zeljkofilipin1 commits   Projetos de terceiros usados pela documentação do Selenium:    Software Versão Licença     Hugo v0.66.0 Apache 2.0   Hugo Learn Theme v2.5.0 MIT   Code Tabs Style \u0026mdash; MIT    Licença Todo o código e documentação proveniente do projeto Selenium está licenciado sob a licença Apache 2.0, com a Software Freedom Conservancy como detentor dos direitos autorais.\nA licença está incluída aqui por conveniência, mas você também pode encontrá-la no Site da Apache Foundation:\nApache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \u0026#34;License\u0026#34; shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \u0026#34;Licensor\u0026#34; shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \u0026#34;Legal Entity\u0026#34; shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u0026#34;control\u0026#34; means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \u0026#34;You\u0026#34; (or \u0026#34;Your\u0026#34;) shall mean an individual or Legal Entity exercising permissions granted by this License. \u0026#34;Source\u0026#34; form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \u0026#34;Object\u0026#34; form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \u0026#34;Work\u0026#34; shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \u0026#34;Derivative Works\u0026#34; shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \u0026#34;Contribution\u0026#34; shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u0026#34;submitted\u0026#34; means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u0026#34;Not a Contribution.\u0026#34; \u0026#34;Contributor\u0026#34; shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \u0026#34;NOTICE\u0026#34; text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \u0026#34;[]\u0026#34; replaced with your own identifying information. (Don\u0026#39;t include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \u0026#34;printed page\u0026#34; as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. "},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/understanding_the_components/","title":"Entendendo os componentes","tags":[],"description":"","content":"Construir um conjunto de testes usando WebDriver exigirá que você entenda e use efetivamente uma série de componentes diferentes. Como com tudo em software, pessoas diferentes usam termos diferentes para a mesma ideia. Abaixo está uma análise de como os termos são usados nesta descrição.\nTerminologia  API: interface de programação de aplicativo. Este é o conjunto de \u0026ldquo;comandos\u0026rdquo; que você usa para manipular o WebDriver. Biblioteca: um módulo de código que contém as APIs e o código necessário para implementá-los. As bibliotecas são específicas para cada linguagem, por exemplo arquivos .jar para Java, arquivos .dll para .NET, etc. Driver: responsável por controlar o navegador atual. A maioria dos drivers são criados pelos próprios fornecedores de navegadores. Os drivers são geralmente módulos executáveis ​​que são executados no sistema com o próprio navegador, não no sistema que está executando o conjunto de testes. (Embora esses possam ser mesmo sistema.) NOTA: Algumas pessoas se referem aos drivers como proxies. Framework: uma biblioteca adicional usada como suporte para suítes do WebDriver. Essas estruturas podem ser estruturas de teste, como JUnit ou NUnit. Eles também podem ser estruturas que suportam recursos de linguagem natural, como como Cucumber ou Robotium. Frameworks também podem ser escritos e usados ​​para coisas como manipulação ou configuração do sistema em teste, criação de dados, oráculos de teste, etc.  As partes e peças No mínimo, o WebDriver se comunica com um navegador por meio de um driver. Comunicação é bidirecional: o WebDriver passa comandos para o navegador por meio do driver e recebe informações de volta pela mesma rota.\nO driver é específico para o navegador, como ChromeDriver para Google Chrome / Chromium, GeckoDriver para Mozilla Firefox, etc. O driver é executado no mesmo sistema do navegador. Este pode, ou não ser, o mesmo sistema onde os próprios testes estão sendo executados.\nEste exemplo simples acima é comunicação direta. Comunicação para o navegador também pode ser comunicação remota através do servidor Selenium ou RemoteWebDriver. RemoteWebDriver roda no mesmo sistema que o driver e o navegador.\nA comunicação remota também pode ocorrer usando Selenium Server ou Selenium Grid, que, por sua vez, fala com o driver no sistema host\nOnde frameworks se encaixam O WebDriver tem um trabalho e apenas um trabalho: comunicar-se com o navegador por meio de qualquer um dos métodos acima. O WebDriver não sabe nada sobre testes: ele não sabe como comparar coisas, afirmar passa ou falha, e certamente não sabe uma coisa sobre relatórios ou gramática Dado / Quando / Então.\nÉ aqui que vários frameworks entram em cena. No mínimo, você precisará de um framework de teste que corresponde às linguagens, por exemplo, NUnit para .NET, JUnit para Java, RSpec para Ruby, etc.\nO framework de teste é responsável por rodar e executar seu WebDriver e etapas relacionadas em seus testes. Como tal, você pode pensar nele parecendo a imagem seguinte.\nFrameworks/ferramentas de linguagem natural, como Cucumber, podem existir como parte desse framework de teste na figura acima, ou eles podem envolver o framework de teste inteiramente em sua própria implementação.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/selenium_installation/installing_selenium_libraries/","title":"Instalando bibliotecas do Selenium","tags":[],"description":"","content":"Primeiro você precisa instalar as ligações Selenium para seu projeto de automação. O processo de instalação de bibliotecas depende da linguagem que você escolher usar.\nJava A instalação de bibliotecas Selenium para Java pode ser feita usando Maven. Adicione a dependência selenium-java em seu pom.xml:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; A dependência selenium-java suporta a execução de sua automação com todos os navegadores com suporte Selenium. Se você quiser fazer testes apenas em um navegador específico, você pode adicionar a dependência para esse navegador em seu arquivo pom.xml. Por exemplo, você deve adicionar a seguinte dependência em seu pom.xml arquivo para executar seus testes apenas no Firefox:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-firefox-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; De maneira semelhante, se você deseja executar testes apenas no Chrome, você deve adicionar a seguinte dependência:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-chrome-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Python A instalação de bibliotecas Selenium para Python pode ser feita usando pip:\npip install selenium Como alternativa, você pode baixar o arquivo de origem do PyPI (selenium-x.x.x.tar.gz) e instale-o usando setup.py:\npython setup.py install C# A instalação de bibliotecas Selenium para C# pode ser feita usando NuGet:\n# Using package manager Install-Package Selenium.WebDriver # or using .Net CLI dotnet add package Selenium.WebDriver Ruby A instalação de bibliotecas Selenium para Ruby pode ser feita usando gem:\ngem install selenium-webdriver JavaScript A instalação de bibliotecas Selenium para JavaScript pode ser feita usando npm:\nnpm install selenium-webdriver Kotlin Devido à ausência de vínculos de linguagem nativo para Kotlin, você deve usar vínculos Java, por exemplo, com Maven Java\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/page_object_models/","title":"Modelos de objetos de página","tags":[],"description":"","content":"Objeto de página é um padrão de design que se tornou popular na automação de teste para melhorar a manutenção de teste e reduzir a duplicação de código. Um objeto de página é uma classe orientada a objetos que serve como uma interface para uma página de seu AUT. Os testes então usam os métodos desta classe de objeto de página sempre que precisam interagir com a interface do usuário dessa página. O benefício é que, se a IU mudar para a página, os próprios testes não precisam ser alterados, apenas o código dentro do o objeto da página precisa ser alterado. Posteriormente, todas as alterações para oferecer suporte a essa nova IU estão localizados em um só lugar.\nO padrão de design do objeto de página oferece as seguintes vantagens:\n Há uma separação clara entre o código de teste e o código específico da página, como localizadores (ou seu uso se você estiver usando um mapa de interface do usuário) e layout. Existe um único repositório para os serviços ou operações oferecidos pela página em vez de ter esses serviços espalhados pelos testes.  Em ambos os casos, isso permite qualquer modificação necessária devido a mudanças na IU ser feito em um só lugar. Informações úteis sobre esta técnica podem ser encontradas em vários blogs, já que esse ‘padrão de design de teste’ está se tornando amplamente usado. Nós incentivamos o leitor que deseja saber mais a pesquisar blogs na internet nesse assunto. Muitos escreveram sobre este padrão de design e podem fornecer dicas úteis que vão além do escopo deste guia do usuário. Para começar, no entanto, vamos ilustrar objetos de página com um exemplo simples.\nPrimeiro, considere um exemplo, típico de automação de teste, que não usa um objeto de página:\n/*** * Tests login feature */ public class Login { public void testLogin() { // preenche dados de login na página de entrada  driver.findElement(By.name(\u0026#34;user_name\u0026#34;)).sendKeys(\u0026#34;testUser\u0026#34;); driver.findElement(By.name(\u0026#34;password\u0026#34;)).sendKeys(\u0026#34;my supersecret password\u0026#34;); driver.findElement(By.name(\u0026#34;sign-in\u0026#34;)).click(); // verifica que a tag h1 é \u0026#34;Hello userName\u0026#34; após o login  driver.findElement(By.tagName(\u0026#34;h1\u0026#34;)).isDisplayed(); assertThat(driver.findElement(By.tagName(\u0026#34;h1\u0026#34;)).getText(), is(\u0026#34;Hello userName\u0026#34;)); } } Há dois problemas com esta abordagem.\n Não há separação entre o método de teste e os localizadores AUT (IDs neste exemplo); ambos estão interligados em um único método. Se a IU da aplicação muda seus identificadores, layout ou como um login é inserido e processado, o próprio teste deve mudar. Os localizadores do ID estariam espalhados em vários testes, em todos os testes que precisassem usar esta página de login.  Aplicando as técnicas de objeto de página, este exemplo poderia ser reescrito assim no exemplo a seguir de um objeto de página para uma página de Sign-in.\nimport org.openqa.selenium.By; import org.openqa.selenium.WebDriver; /** * Page Object encapsula a página de login. */ public class SignInPage { protected WebDriver driver; // \u0026lt;input name=\u0026#34;user_name\u0026#34; type=\u0026#34;text\u0026#34; value=\u0026#34;\u0026#34;\u0026gt;  private By usernameBy = By.name(\u0026#34;user_name\u0026#34;); // \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; value=\u0026#34;\u0026#34;\u0026gt;  private By passwordBy = By.name(\u0026#34;password\u0026#34;); // \u0026lt;input name=\u0026#34;sign_in\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;SignIn\u0026#34;\u0026gt;  private By signinBy = By.name(\u0026#34;sign_in\u0026#34;); public SignInPage(WebDriver driver){ this.driver = driver; } /** * Login como um usuário válido * * @param userName * @param password * @return HomePage object */ public HomePage loginValidUser(String userName, String password) { driver.findElement(usernameBy).sendKeys(userName); driver.findElement(passwordBy).sendKeys(password); driver.findElement(signinBy).click(); return new HomePage(driver); } } e o objeto de página de uma página inicial pode ter a seguinte aparência.\nimport org.openqa.selenium.By; import org.openqa.selenium.WebDriver; /** * Page Object encapsula a Home Page */ public class HomePage { protected WebDriver driver; // \u0026lt;h1\u0026gt;Hello userName\u0026lt;/h1\u0026gt;  private By messageBy = By.tagName(\u0026#34;h1\u0026#34;); public HomePage(WebDriver driver){ this.driver = driver; if (!driver.getTitle().equals(\u0026#34;Home Page of logged in user\u0026#34;)) { throw new IllegalStateException(\u0026#34;This is not Home Page of logged in user,\u0026#34; + \u0026#34; current page is: \u0026#34; + driver.getCurrentUrl()); } } /** * Get message (h1 tag) * * @return String message text */ public String getMessageText() { return driver.findElement(messageBy).getText(); } public HomePage manageProfile() { // Encapsulamento da página para gerenciar a funcionalidade do perfil  return new HomePage(driver); } /* Mais métodos fornecendo o serviços representados pela Home Page do usuário logado. Esses métodos por sua vez podem retornar mais Page Objects por exemplo clicar no botão Compor Email poderia retornar um objeto ComposeMail */ } Portanto, agora, o teste de login usaria esses dois objetos de página da seguinte maneira.\n/*** * Tests login feature */ public class TestLogin { @Test public void testLogin() { SignInPage signInPage = new SignInPage(driver); HomePage homePage = signInPage.loginValidUser(\u0026#34;userName\u0026#34;, \u0026#34;password\u0026#34;); assertThat(homePage.getMessageText(), is(\u0026#34;Hello userName\u0026#34;)); } } Há muita flexibilidade em como os objetos de página podem ser projetados, mas existem algumas regras básicas para obter a manutenção desejada de seu código de teste.\nOs próprios objetos de página nunca devem fazer verificações ou afirmações. Isto é parte do seu teste e deve estar sempre dentro do código do teste, nunca em um objeto de página. O objeto da página conterá a representação da página, e o serviços que a página fornece por meio de métodos, mas nenhum código relacionado ao que está sendo testado deve estar dentro do objeto de página.\nHá uma única verificação que pode e deve estar dentro do objeto de página e que é para verificar se a página e, possivelmente, elementos críticos em a página, foram carregados corretamente. Esta verificação deve ser feita enquanto instanciar o objeto de página. Nos exemplos acima, ambos SignInPage e os construtores da HomePage verificam se a página esperada está disponível e pronta para solicitações do teste.\nUm objeto de página não precisa necessariamente representar todas as partes da página em si. Os mesmos princípios usados para objetos de página podem ser usados para criar \u0026ldquo;Objetos de Componente de Página\u0026rdquo; que representam pedaços discretos da página e podem ser incluídos em objetos de página. Esses objetos de componentes podem fornecer referências aos elementos dentro desses blocos discretos, e métodos para utilizar a funcionalidade fornecida por eles. Você também pode aninhar objetos de componentes dentro de outros objetos de componentes para páginas mais complexas. Se uma página na aplicação tem vários componentes, ou componentes usados em todo o site (por exemplo, uma barra de navegação), então pode melhorar a manutenção e reduzir a duplicação de código.\nExistem outros padrões de design que também podem ser usados em testes. Alguns usam um Page Factory para instanciar seus objetos de página. Discutir tudo isso é além do escopo deste guia do usuário. Aqui, queremos apenas apresentar o conceitos para tornar o leitor ciente de algumas coisas que podem ser feitas. Como foi mencionado anteriormente, muitos escreveram sobre este tópico e nós encorajamos o leitor para pesquisar blogs sobre esses tópicos.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/getting_started_with_webdriver/browsers/","title":"Navegadores","tags":[],"description":"","content":"Navegadores comerciais O framework Selenium oferece suporte oficial aos seguintes navegadores:\n   Navegador Mantenedor Versões Suportadas     Chrome Chromium Todas as versões   Firefox Mozilla 54 ou mais nova   Edge Microsoft 84 ou mais nova   Internet Explorer Selenium 6 ou mais nova   Opera Opera Chromium / Presto 10.5 ou mais nova   Safari Apple 10 ou mais nova    Navegadores especializados Também existe um conjunto de navegadores especializados por aí normalmente usados em ambientes de desenvolvimento. Podemos usar alguns desses navegadores para fins de automação também, e o Selenium suporta os seguintes drivers especializados:\n   Nome do driver Objetivo Mantenedor     HtmlUnitDriver Emulador de navegador sem cabeçalho apoiado pelo Rhino Projeto Selenium    "},{"uri":"https://www.selenium.dev/documentation/pt-br/introduction/the_selenium_project_and_tools/","title":"O projeto Selenium e ferramentas","tags":[],"description":"","content":"Selenium controla navegadores Selenium é muitas coisas mas, em sua essência, é um conjunto de ferramentas para automação de navegador da web que usa as melhores técnicas disponíveis para controlar remotamente as instâncias do navegador e emular a interação do usuário com o navegador.\nEle permite que os usuários simulem atividades comuns realizadas por usuários finais; inserir texto em campos, selecionando valores suspensos e caixas de seleção, e clicar em links em documentos. Ele também fornece muitos outros controles, como o movimento do mouse, execução arbitrária de JavaScript e muito mais.\nEmbora seja usado principalmente para testes de front-end de sites, Selenium é basicamente uma biblioteca de agente de usuário de navegador. As interfaces são onipresentes em seus aplicativos, o que incentiva a composição com outras bibliotecas para atender a sua finalidade.\nUma interface para tudo Um dos princípios norteadores do projeto é oferecer suporte a uma interface comum para todas as tecnologias de navegador (principais). Os navegadores da web são aplicativos incrivelmente complexos e altamente projetados, realizando suas operações de maneiras completamente diferentes mas que frequentemente têm a mesma aparência ao fazê-lo. Mesmo que o texto seja renderizado com as mesmas fontes, as imagens sejam exibidas no mesmo lugar e os links levem você ao mesmo destino. O que está acontecendo por baixo é tão diferente quanto noite e dia. Selenium \u0026ldquo;abstrai\u0026rdquo; essas diferenças, esconde seus detalhes e complexidades da pessoa que está escrevendo o código. Isso permite que você escreva várias linhas de código para realizar um fluxo de trabalho complicado, mas essas mesmas linhas serão executadas no Firefox, Internet Explorer, Chrome e todos os outros navegadores compatíveis.\nFerramentas e suporte A abordagem de design minimalista do Selenium lhe dá a versatilidade para ser incluído como um componente em aplicações maiores. A infraestrutura circundante fornecida sob o Selenium dá a você as ferramentas para montar sua Grid de navegadores para que os testes possam ser executados em diferentes navegadores e sistemas operacionais em uma variedade de máquinas.\nImagine um banco de computadores em sua sala de servidores ou data center todos abrindo navegadores ao mesmo tempo acessando links, formulários, e tabelas — testando seu aplicativo 24 horas por dia. Por meio da interface de programação simples fornecido para os idiomas mais comuns, esses testes serão executados incansavelmente em paralelo, reportando de volta para você quando ocorrerem erros.\nÉ o objetivo de ajudar a tornar isso uma realidade para você, fornecendo aos usuários ferramentas e documentação não apenas para controlar os navegadores mas para tornar mais fácil dimensionar e implantar essas grades.\nQuem usa Selenium Muitas das empresas mais importantes do mundo adotaram o Selenium para seus testes baseados em navegador, frequentemente substituindo esforços de anos envolvendo outras ferramentas proprietárias. À medida que sua popularidade cresceu, seus requisitos e desafios se multiplicaram.\nConforme a web se torna mais complicada e novas tecnologias são adicionadas aos sites, é a missão deste projeto acompanhá-los sempre que possível. Sendo um projeto de código aberto, este apoio é fornecido por meio da generosa doação de tempo de muitos voluntários, cada um deles tem um “trabalho diurno”.\nOutra missão do projeto é incentivar mais voluntários para participar deste esforço, e construir uma comunidade forte para que o projeto possa continuar a acompanhar as tecnologias emergentes e permanecer uma plataforma dominante para automação de teste funcional.\nHistória Quando Selenium 1 foi lançado em 2004, foi devido à necessidade de reduzir o tempo gasto verificando manualmente o comportamento consistente no front-end de um aplicativo da web. Ele fez uso de quais ferramentas estavam disponíveis na época e dependia muito da injeção de JavaScript na página da web em teste para emular a interação de um usuário.\nEmbora o JavaScript seja uma boa ferramenta para permitir que você faça uma introspecção nas propriedades do DOM e fazer certas observações do lado do cliente que, de outra forma, você não seria capaz de fazer, fica aquém da capacidade de replicar naturalmente as interações de um usuário como se o mouse e o teclado estivessem sendo usados.\nDesde então, Selenium cresceu e amadureceu muito, em uma ferramenta amplamente usada por muitos — se não pela maioria — das maiores organizações em todo o mundo. Selenium deixou de ser um kit de ferramentas de automação de teste caseiro desenvolvido na Thoughtworks para um público de nicho e um caso de uso específico, à biblioteca de automação de navegador de facto do mundo.\nAssim como o Selenium RC fazia uso das ferramentas do comércio disponíveis na época, Selenium WebDriver impulsiona essa tradição ao seguir a parte de interação do navegador com a área residencial do fornecedor do navegador e pedindo a eles que assumam a responsabilidade pelas implementações de back-end voltadas para o navegador. Recentemente, este trabalho evoluiu para um processo de padronização W3C onde o objetivo é transformar o componente WebDriver no Selenium na biblioteca de controle remoto du jour para agentes do usuário.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/purposes_and_main_functionalities/","title":"Objetivos e funcionalidades principais","tags":[],"description":"","content":" Ponto de entrada central para todos os testes Gerenciamento e controle dos nós / ambiente onde os navegadores rodam Escalonamento Executar testes em paralelo Teste de plataforma cruzada Balanceamento de carga  "},{"uri":"https://www.selenium.dev/documentation/pt-br/driver_idiosyncrasies/shared_capabilities/","title":"Recursos compartilhados","tags":[],"description":"","content":"Para criar uma nova sessão por Selenium WebDriver, a extremidade local deve fornecer os recursos básicos para a extremidade remota. A extremidade remota usa o mesmo conjunto de recursos para cria uma sessão e descreve os recursos da sessão atual.\nWebDriver fornece recursos que cada controle extremidade remota irá/deverá apoiar a implementação. A seguir estão os recursos que o WebDriver suporta:\nbrowserName: Este recurso é usado para definir o browserName para uma determinada sessão. Se o navegador especificado não estiver instalado na extremidade remota, a criação da sessão irá falhar\nbrowserVersion: Este recurso é opcional, usado para definir a versão do navegador disponível na extremidade remota. Por exemplo, se pedir o Chrome versão 75 em um sistema que tem apenas a versão 80 instalada, a criação da sessão irá falhar\npageLoadStrategy: Ao navegar para uma nova página via URL, por padrão o Selenium irá esperar até que a página esteja totalmente carregada antes de responder. Isso funciona bem para iniciantes, mas pode causar longos tempos de espera em páginas que carregam um grande número de recursos de terceiros. Usar uma estratégia não padrão pode tornar a execução de testes mais rápida em casos como este, mas também pode apresentar instabilidade onde os elementos na página mudam de posição conforme os elementos são carregados e mudam de tamanho.\nA estratégia de carregamento da página consulta o document.readyState conforme descrito na tabela abaixo:\n   Estrtégia Ready State Notas     normal complete Usado por padrão, aguarda o download de todos os recursos   eager interactive O acesso ao DOM está pronto, mas outros recursos, como imagens, ainda podem estar carregando   none Any Não bloqueia o WebDriver de nenhuma forma    platformName Isso identifica o sistema operacional na extremidade remota e buscar o platformName retorna o nome do sistema operacional.\nEm provedores baseados em nuvem, definir platformName define o sistema operacional na extremidade remota.\nacceptInsecureCerts Este recurso verifica se um Certificado TLS expirado (ou) inválido é usado durante a navegação durante uma sessão.\nSe o recurso for definido como false, um erro de certificado inseguro será retornado quando a navegação encontrar qualquer problema de certificado de domínio. Se definido como verdadeiro, o certificado inválido será confiável para o navegador.\nTodos os certificados autoassinados serão considerados confiáveis por esse recurso por padrão. Uma vez definido, o recurso acceptInsecureCerts terá um efeito para toda a sessão.\nTimeout de Sessão Uma session do WebDriver é imposta com um certo intervalo session timeout durante o qual o usuário pode controlar o comportamento de executar scripts ou recuperar informações do navegador.\nCada tempo limite de sessão é configurado com combinação de diferentes timeouts, conforme descrito abaixo:\nTimeout de Script: Especifica quando interromper um script em execução em um contexto de navegação atual. O tempo limite padrão 30.000 é imposto quando uma nova sessão é criada pelo WebDriver.\nTimeout de Carregamento de Página: Especifica o intervalo de tempo em que a página da web precisa ser carregado em um contexto de navegação atual. O tempo limite padrão 300.000 é imposto quando uma nova sessão é criada pelo WebDriver. Se os carregamento da página delimitar um determinado período de tempo, o script será interrompido por TimeoutException.\nTimeout de Espera Implícita: Isso especifica o tempo de espera pela estratégia de implicit element location quando localizando de elementos. O tempo limite padrão 0 é imposto quando uma nova sessão é criada pelo WebDriver.\nunhandledPromptBehavior Especifica o estado do user prompt handler da sessão atual. O padrão é dismiss and notify state (dispensar e notificar estado, em português)\nUser Prompt Handler Isso define qual ação deve ser tomada quando um o prompt do usuário se encontra na extremidade remota. Isso é definido pelo recurso unhandledPromptBehavior e tem os seguintes estados:\n dismiss accept dismiss and notify accept and notify ignore  setWindowRect Este comando altera o tamanho e a posição da atual janela de contexto de navegação. Este comando atua como setter para o comando getWindowRect que aceita largura, altura, x, y como argumentos opcionais.\nDurante a automação, o contexto de navegação atual será associado com estados de janela, que descrevem a visibilidade da janela do navegador. Os estados da janela são\n maximized minimized normal fullscreen  Definir Width ou Height não garante que o resultado o tamanho da janela corresponderá exatamente ao que foi inserido. Isto é porque alguns drivers podem não ser redimensionados em incrementos de pixel único. Devido a isso, buscar o estado / detalhes da janela por getWindowRect pode não corresponder igualmente aos valores definidos para o navegador.\nstrictFileInteractability O novo recurso indica se as verificações estritas de interatividade devem ser aplicadas aos elementos input type = file. Como as verificações de interatividade estrita estão desativadas por padrão, há uma mudança no comportamento ao usar Element Send Keys com controles de upload de arquivos ocultos.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/legacy_docs/selenium_rc/","title":"Selenium 1 (Selenium RC)","tags":[],"description":"","content":"Introdução Selenium RC foi o principal projeto da Selenium por muito tempo, antes da fusão WebDriver / Selenium trazer o Selenium 2, uma ferramenta mais poderosa. Vale ressaltar que não há mais suporte para Selenium 1.\nComo o Selenium RC funciona Primeiro, vamos descrever como os componentes do Selenium RC operam e o papel que cada um desempenha na execução de seus scripts de teste.\nComponentes do RC Os componentes do Selenium RC são:\n O servidor Selenium que inicia e mata navegadores, interpreta e executa os comandos em Selenese passados do programa de teste e atua como um proxy HTTP, interceptando e verificando mensagens HTTP passadas entre o navegador e a aplicação sendo testada. Bibliotecas de cliente que fornecem a interface entre cada linguagem de programação e o Selenium RC Server.  Aqui está um diagrama de arquitetura simplificado:\nO diagrama mostra que as bibliotecas cliente se comunicam com o servidor passando cada comando Selenium para execução. Então o servidor passa o comando Selenium para o navegador usando comandos Selenium-Core JavaScript. O navegador, usando seu interpretador JavaScript, executa o comando Selenium. Este executa a ação em Selenese ou verificação que você especificou em seu script de teste.\nServidor Selenium O servidor Selenium recebe comandos Selenium do seu programa de teste, os interpreta e reporta ao seu programa os resultados da execução desses testes.\nO servidor RC agrupa o Selenium Core e o injeta automaticamente no navegador. Isso ocorre quando seu programa de teste abre o navegador (usando uma função API de biblioteca cliente). Selenium-Core é um programa JavaScript, na verdade um conjunto de funções JavaScript que interpretam e executam comandos em Selenese usando o interpretador de JavaScript embutido do navegador.\nO servidor recebe os comandos em Selenese do seu programa de teste usando solicitações HTTP GET/POST simples. Isso significa que você pode usar qualquer linguagem de programação que pode enviar solicitações HTTP para automatizar os testes Selenium no navegador.\nBibliotecas Cliente As bibliotecas cliente fornecem suporte de programação que permite que você execute comandos Selenium a partir de um programa de seu próprio projeto. Existe um biblioteca cliente diferente para cada linguagem compatível. Um cliente Selenium biblioteca fornece uma interface de programação (API), ou seja, um conjunto de funções, que executam comandos Selenium de seu próprio programa. Dentro de cada interface, existe uma função de programação que suporta cada comando em Selenese.\nA biblioteca cliente pega um comando em Selenese e o passa para o servidor Selenium para processar uma ação específica ou teste no aplicativo em teste (AUT). A biblioteca cliente também recebe o resultado desse comando e o devolve ao seu programa. Seu programa pode receber o resultado e armazená-lo em uma variável de programa e relatá-lo como um sucesso ou fracasso, ou possivelmente executar uma ação corretiva se for um erro inesperado.\nEntão, para criar um programa de teste, você simplesmente escreve um programa que executa um conjunto de comandos Selenium usando uma API de biblioteca cliente. E, opcionalmente, se você já tem um script de teste em Selenese criado na Selenium-IDE, você pode gerar o código Selenium RC. A Selenium-IDE pode traduzir (usando seu item de menu Exportar) seus comandos Selenium em chamadas de função de uma API de driver de cliente. Consulte o capítulo Selenium-IDE para obter detalhes sobre a exportação de código RC a partir da Selenium-IDE.\nInstalação A instalação é um nome impróprio para Selenium. Selenium tem um conjunto de bibliotecas disponíveis na linguagem de programação de sua escolha. Você pode baixá-los na página de downloads.\nDepois de escolher uma linguagem para trabalhar, você só precisa:\n Instalar o Selenium RC Server. Configurar um projeto de programação usando um driver cliente específico de linguagem.  Instalando o servidor Selenium O servidor Selenium RC é simplesmente um arquivo Java jar (selenium-server-standalone-\u0026lt;número da versão\u0026gt;.jar), que não requer qualquer instalação especial. Basta baixar o arquivo zip e extrair o servidor no diretório desejado.\nExecutando o servidor Selenium Antes de iniciar qualquer teste, você deve iniciar o servidor. Vá para o diretório onde o servidor Selenium RC está localizado e execute o seguinte a partir da linha de comando.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar Isso pode ser simplificado criando um arquivo executável em lote ou shell (.bat no Windows e .sh no Linux) contendo o comando acima. Em seguida, faça um atalho para esse executável em seu desktop e simplesmente clique duas vezes no ícone para iniciar o servidor.\nPara o servidor funcionar, você precisa do Java instalado e a variável de ambiente PATH configurada corretamente para executá-lo a partir do console. Você pode verificar se o Java está instalado corretamente executando o seguinte em um console.\njava -version Se você obtiver um número de versão (que precisa ser 1.5 ou posterior), você está pronto para começar a usar o Selenium RC.\nUsando o driver cliente para Java  Baixe o zip do driver do cliente Selenium Java na página de downloads do SeleniumHQ. Extraia o arquivo selenium-java-.jar Abra a IDE Java desejada (Eclipse, NetBeans, IntelliJ, Netweaver, etc.) Crie um projeto Java. Adicione os arquivos selenium-java-.jar ao seu projeto como referências. Adicione ao classpath do projeto o arquivo selenium-java-.jar. Na Selenium-IDE, exporte um script para um arquivo Java e inclua-o em seu projeto Java ou escreva seu teste Selenium em Java usando a API selenium-java-client. A API é apresentada posteriormente neste capítulo. Você pode usar JUnit ou TestNg para executar seu teste, ou você pode escrever seu próprio programa main() simples. Esses conceitos são explicados mais para frente nesta seção. Execute o servidor Selenium a partir do console. Execute seu teste na Java IDE ou na linha de comando.  Para obter detalhes sobre a configuração do projeto de teste Java, consulte as seções do Apêndice Configurando Selenium RC com Eclipse e Configurando Selenium RC com Intellij.\nUsando o driver cliente para Python  Instale o Selenium via pip, instruções no link da página de downloads do SeleniumHQ Escreva seu teste Selenium em Python ou exporte um script da Selenium-IDE para um arquivo python. Execute o servidor Selenium a partir do console Execute seu teste em um console ou IDE Python  Para obter detalhes sobre a configuração do driver cliente Python, consulte o apêndice Configuração do driver cliente Python.\nUsando o driver cliente para .NET  Baixe o Selenium RC na página de downloads do SeleniumHQ Extraia a pasta Baixe e instale o NUnit ( Nota: você pode usar o NUnit como seu mecanismo de teste. Se você ainda não está familiarizado com NUnit, você também pode escrever uma função main() simples para executar seus testes; no entanto, o NUnit é muito útil como um mecanismo de teste.) Abra a IDE .Net desejado (Visual Studio, SharpDevelop, MonoDevelop) Crie uma biblioteca de classes (.dll) Adicione referências às seguintes DLLs: nmock.dll, nunit.core.dll, nunit.framework.dll, ThoughtWorks.Selenium.Core.dll, ThoughtWorks.Selenium.IntegrationTests.dll e ThoughtWorks.Selenium.UnitTests.dll Escreva seu teste Selenium em uma linguagem .Net (C#, VB.Net) ou exporte um script da Selenium-IDE para um arquivo C# e copie este código para o arquivo de classe você acabou de criar. Escreva seu próprio programa main() simples ou você pode incluir NUnit em seu projeto para executar seu teste. Esses conceitos são explicados posteriormente neste capítulo. Execute o servidor Selenium a partir do console Execute seu teste a partir da IDE, da GUI do NUnit ou da linha de comando  Para obter detalhes específicos sobre a configuração do driver cliente .NET com Visual Studio, consulte o apêndice Configuração do driver cliente .NET.\nUsando o driver cliente para Ruby  Se você ainda não tem RubyGems, instale-o do RubyForge. Execute gem install selenium-client No topo do seu script de teste, adicione require \u0026quot;selenium / client\u0026quot; Escreva seu script de teste usando qualquer função de teste Ruby (por exemplo, Test::Unit, Mini::Test ou RSpec). Execute o servidor Selenium RC a partir do console. Execute seu teste da mesma forma que você executaria qualquer outro script Ruby.  Para obter detalhes sobre a configuração do driver do cliente Ruby, consulte a documentação do Selenium-Client\nDo Selenese ao Programa A principal tarefa para usar o Selenium RC é converter seu Selenese em uma linguagem de programação. Nesta seção, fornecemos vários exemplos específicos de linguagens diferentes.\nExemplo de script de teste Vamos começar com um exemplo de script de teste em Selenese. Imagine gravar o seguinte teste com Selenium-IDE.\n          open /    type q selenium rc   clickAndWait btnG    assertTextPresent Results * for selenium rc     Observação: este exemplo funcionaria com a página de pesquisa do Google http://www.google.com\nSelenese como código Aqui está o script de teste exportado (via Selenium-IDE) para cada uma das linguagens de programação. Se você tem pelo menos conhecimento básico de linguagem de programação orientada a objetos (OOP), você vai entender como o Selenium executa comandos em Selenese lendo um destes exemplos. Para ver um exemplo em uma linguagem específica, selecione um desses botões.\nCSharp using System; using System.Text; using System.Text.RegularExpressions; using System.Threading; using NUnit.Framework; using Selenium; namespace SeleniumTests { [TestFixture] public class NewTest { private ISelenium selenium; private StringBuilder verificationErrors; [SetUp] public void SetupTest() { selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); verificationErrors = new StringBuilder(); } [TearDown] public void TeardownTest() { try { selenium.Stop(); } catch (Exception) { // Ignore errors if unable to close the browser  } Assert.AreEqual(\u0026#34;\u0026#34;, verificationErrors.ToString()); } [Test] public void TheNewTest() { selenium.Open(\u0026#34;/\u0026#34;); selenium.Type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.Click(\u0026#34;btnG\u0026#34;); selenium.WaitForPageToLoad(\u0026#34;30000\u0026#34;); Assert.AreEqual(\u0026#34;selenium rc - Google Search\u0026#34;, selenium.GetTitle()); } } } Java /** Add JUnit framework to your classpath if not already there * for this example to work */ package com.example.tests; import com.thoughtworks.selenium.*; import java.util.regex.Pattern; public class NewTest extends SeleneseTestCase { public void setUp() throws Exception { setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); } public void testNew() throws Exception { selenium.open(\u0026#34;/\u0026#34;); selenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.click(\u0026#34;btnG\u0026#34;); selenium.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(selenium.isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); } } Php \u0026lt;?php require_once \u0026#39;PHPUnit/Extensions/SeleniumTestCase.php\u0026#39;; class Example extends PHPUnit_Extensions_SeleniumTestCase { function setUp() { $this-\u0026gt;setBrowser(\u0026#34;*firefox\u0026#34;); $this-\u0026gt;setBrowserUrl(\u0026#34;http://www.google.com/\u0026#34;); } function testMyTestCase() { $this-\u0026gt;open(\u0026#34;/\u0026#34;); $this-\u0026gt;type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); $this-\u0026gt;click(\u0026#34;btnG\u0026#34;); $this-\u0026gt;waitForPageToLoad(\u0026#34;30000\u0026#34;); $this-\u0026gt;assertTrue($this-\u0026gt;isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); } } ?\u0026gt; Python from selenium import selenium import unittest, time, re class NewTest(unittest.TestCase): def setUp(self): self.verificationErrors = [] self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() def test_new(self): sel = self.selenium sel.open(\u0026#34;/\u0026#34;) sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;) sel.click(\u0026#34;btnG\u0026#34;) sel.wait_for_page_to_load(\u0026#34;30000\u0026#34;) self.failUnless(sel.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;)) def tearDown(self): self.selenium.stop() self.assertEqual([], self.verificationErrors) Ruby require \u0026#34;selenium/client\u0026#34; require \u0026#34;test/unit\u0026#34; class NewTest \u0026lt; Test::Unit::TestCase def setup @verification_errors = [] if $selenium @selenium = $selenium else @selenium = Selenium::Client::Driver.new(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;, 60); @selenium.start end @selenium.set_context(\u0026#34;test_new\u0026#34;) end def teardown @selenium.stop unless $selenium assert_equal [], @verification_errors end def test_new @selenium.open \u0026#34;/\u0026#34; @selenium.type \u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34; @selenium.click \u0026#34;btnG\u0026#34; @selenium.wait_for_page_to_load \u0026#34;30000\u0026#34; assert @selenium.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;) end end Na próxima seção, explicaremos como construir um programa de teste usando o código gerado.\nProgramando seu teste Agora vamos ilustrar como programar seus próprios testes usando exemplos em cada uma das linguagens de programação suportadas. Existem essencialmente duas tarefas:\n*Gerar seu script em uma linguagem de programação a partir da Selenium-IDE, opcionalmente modificando o resultado. *Escrever um programa principal muito simples que execute o código gerado.\nOpcionalmente, você pode adotar uma plataforma de mecanismo de teste como JUnit ou TestNG para Java, ou NUnit para .NET se você estiver usando uma dessas linguagens.\nAqui, mostramos exemplos específicos de cada linguagem. As APIs específicas do idioma tendem a diferir de um para o outro, então você encontrará uma explicação separada para cada um.\n Java C# Python Ruby Perl, PHP  Java Para Java, as pessoas usam JUnit ou TestNG como mecanismo de teste. Alguns ambientes de desenvolvimento como o Eclipse têm suporte direto para eles via plug-ins. Isso torna tudo ainda mais fácil. Ensinar JUnit ou TestNG está além do escopo de este documento, no entanto, os materiais podem ser encontrados online e há publicações acessíveis. Se você já é uma \u0026ldquo;loja de Java\u0026rdquo;, é provável que seus desenvolvedores já tem alguma experiência com uma dessas estruturas de teste.\nVocê provavelmente vai querer renomear a classe de teste de \u0026ldquo;NewTest\u0026rdquo; para algo de sua própria escolha. Além disso, você precisará alterar os parâmetros abertos pelo navegador na declaração:\nselenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); O código gerado pela Selenium-IDE terá a seguinte aparência. Este exemplo tem comentários adicionados manualmente para maior clareza.\npackage com.example.tests; // We specify the package of our tests  import com.thoughtworks.selenium.*; // This is the driver\u0026#39;s import. You\u0026#39;ll use this for instantiating a  // browser and making it do what you need.  import java.util.regex.Pattern; // Selenium-IDE add the Pattern module because it\u0026#39;s sometimes used for  // regex validations. You can remove the module if it\u0026#39;s not used in your  // script.  public class NewTest extends SeleneseTestCase { // We create our Selenium test case  public void setUp() throws Exception { setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); // We instantiate and start the browser  } public void testNew() throws Exception { selenium.open(\u0026#34;/\u0026#34;); selenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.click(\u0026#34;btnG\u0026#34;); selenium.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(selenium.isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); // These are the real test steps  } } C# O driver do cliente .NET funciona com o Microsoft.NET. Pode ser usado com qualquer framework de teste .NET como o NUnit ou o Visual Studio 2005 Team System.\nSelenium-IDE assume que você usará NUnit como sua estrutura de teste. Você pode ver isso no código gerado abaixo. Inclui a declaração using para NUnit junto com os atributos NUnit correspondentes que identificam o papel de cada função-membro da classe de teste.\nVocê provavelmente terá que renomear a classe de teste de \u0026ldquo;NewTest\u0026rdquo; para algo de sua própria escolha. Além disso, você precisará alterar os parâmetros abertos pelo navegador na declaração\nselenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); O código gerado será semelhante a este.\nusing System; using System.Text; using System.Text.RegularExpressions; using System.Threading; using NUnit.Framework; using Selenium; namespace SeleniumTests { [TestFixture] public class NewTest { private ISelenium selenium; private StringBuilder verificationErrors; [SetUp] public void SetupTest() { selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); verificationErrors = new StringBuilder(); } [TearDown] public void TeardownTest() { try { selenium.Stop(); } catch (Exception) { // Ignore errors if unable to close the browser  } Assert.AreEqual(\u0026#34;\u0026#34;, verificationErrors.ToString()); } [Test] public void TheNewTest() { // Open Google search engine.  selenium.Open(\u0026#34;http://www.google.com/\u0026#34;); // Assert Title of page.  Assert.AreEqual(\u0026#34;Google\u0026#34;, selenium.GetTitle()); // Provide search term as \u0026#34;Selenium OpenQA\u0026#34;  selenium.Type(\u0026#34;q\u0026#34;, \u0026#34;Selenium OpenQA\u0026#34;); // Read the keyed search term and assert it.  Assert.AreEqual(\u0026#34;Selenium OpenQA\u0026#34;, selenium.GetValue(\u0026#34;q\u0026#34;)); // Click on Search button.  selenium.Click(\u0026#34;btnG\u0026#34;); // Wait for page to load.  selenium.WaitForPageToLoad(\u0026#34;5000\u0026#34;); // Assert that \u0026#34;www.openqa.org\u0026#34; is available in search results.  Assert.IsTrue(selenium.IsTextPresent(\u0026#34;www.openqa.org\u0026#34;)); // Assert that page title is - \u0026#34;Selenium OpenQA - Google Search\u0026#34;  Assert.AreEqual(\u0026#34;Selenium OpenQA - Google Search\u0026#34;, selenium.GetTitle()); } } } Você pode permitir que o NUnit gerencie a execução de seus testes. Ou, alternativamente, você pode escrever um programa main() simples que instancia o objeto de teste e executa cada um dos três métodos, SetupTest(), TheNewTest() e TeardownTest() por sua vez.\nPython Pyunit é a estrutura de teste a ser usada para Python.\nA estrutura básica do teste é:\nfrom selenium import selenium # This is the driver\u0026#39;s import. You\u0026#39;ll use this class for instantiating a # browser and making it do what you need. import unittest, time, re # This are the basic imports added by Selenium-IDE by default. # You can remove the modules if they are not used in your script. class NewTest(unittest.TestCase): # We create our unittest test case def setUp(self): self.verificationErrors = [] # This is an empty array where we will store any verification errors # we find in our tests self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() # We instantiate and start the browser def test_new(self): # This is the test code. Here you should put the actions you need # the browser to do during your test. sel = self.selenium # We assign the browser to the variable \u0026#34;sel\u0026#34; (just to save us from  # typing \u0026#34;self.selenium\u0026#34; each time we want to call the browser). sel.open(\u0026#34;/\u0026#34;) sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;) sel.click(\u0026#34;btnG\u0026#34;) sel.wait_for_page_to_load(\u0026#34;30000\u0026#34;) self.failUnless(sel.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;)) # These are the real test steps def tearDown(self): self.selenium.stop() # we close the browser (I\u0026#39;d recommend you to comment this line while # you are creating and debugging your tests) self.assertEqual([], self.verificationErrors) # And make the test fail if we found that any verification errors # were found Ruby Versões antigas (pré 2.0) da Selenium-IDE geram código Ruby que requer o gem antigo do Selenium. Portanto, é aconselhável atualizar todos os scripts Ruby gerados pela IDE da seguinte forma:\n  Na linha 1, altere require \u0026quot;selenium\u0026quot; para require \u0026quot;selenium/client\u0026quot;\n  Na linha 11, altere Selenium::SeleniumDriver.new para Selenium::Client::Driver.new\n  Você provavelmente também deseja alterar o nome da classe para algo mais informativo do que \u0026ldquo;Untitled\u0026rdquo; e alterar o nome do método de teste para algo diferente de \u0026ldquo;test_untitled.\u0026rdquo;\nAqui está um exemplo simples criado pela modificação do código Ruby gerado pela Selenium IDE, conforme descrito acima.\n# load the Selenium-Client gem require \u0026#34;selenium/client\u0026#34; # Load Test::Unit, Ruby\u0026#39;s default test framework. # If you prefer RSpec, see the examples in the Selenium-Client # documentation. require \u0026#34;test/unit\u0026#34; class Untitled \u0026lt; Test::Unit::TestCase # The setup method is called before each test. def setup # This array is used to capture errors and display them at the # end of the test run. @verification_errors = [] # Create a new instance of the Selenium-Client driver. @selenium = Selenium::Client::Driver.new \\ :host =\u0026gt; \u0026#34;localhost\u0026#34;, :port =\u0026gt; 4444, :browser =\u0026gt; \u0026#34;*chrome\u0026#34;, :url =\u0026gt; \u0026#34;http://www.google.com/\u0026#34;, :timeout_in_second =\u0026gt; 60 # Start the browser session @selenium.start # Print a message in the browser-side log and status bar # (optional). @selenium.set_context(\u0026#34;test_untitled\u0026#34;) end # The teardown method is called after each test. def teardown # Stop the browser session. @selenium.stop # Print the array of error messages, if any. assert_equal [], @verification_errors end # This is the main body of your test. def test_untitled # Open the root of the site we specified when we created the # new driver instance, above. @selenium.open \u0026#34;/\u0026#34; # Type \u0026#39;selenium rc\u0026#39; into the field named \u0026#39;q\u0026#39; @selenium.type \u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34; # Click the button named \u0026#34;btnG\u0026#34; @selenium.click \u0026#34;btnG\u0026#34; # Wait for the search results page to load. # Note that we don\u0026#39;t need to set a timeout here, because that # was specified when we created the new driver instance, above. @selenium.wait_for_page_to_load begin # Test whether the search results contain the expected text. # Notice that the star (*) is a wildcard that matches any # number of characters. assert @selenium.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;) rescue Test::Unit::AssertionFailedError # If the assertion fails, push it onto the array of errors. @verification_errors \u0026lt;\u0026lt; $! end end end Perl, PHP Os membros da equipe de documentação não usaram Selenium RC com Perl ou PHP. Se você estiver usando Selenium RC com qualquer um desses dois idiomas, entre em contato com a Equipe de Documentação (consulte o capítulo sobre Contribuições). Gostaríamos muito de incluir alguns exemplos seus e de suas experiências, para oferecer suporte a usuários Perl e PHP.\nAprendendo a API A API Selenium RC usa convenções de nomenclatura que, supondo que você entenda Selenese, será em grande parte autoexplicativo. Aqui, no entanto, explicamos os aspectos mais críticos e possivelmente menos óbvios.\nIniciando o navegador CSharp selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); Java setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); Perl my $sel = Test::WWW::Selenium-\u0026gt;new( host =\u0026gt; \u0026#34;localhost\u0026#34;, port =\u0026gt; 4444, browser =\u0026gt; \u0026#34;*firefox\u0026#34;, browser_url =\u0026gt; \u0026#34;http://www.google.com/\u0026#34; ); Php $this-\u0026gt;setBrowser(\u0026#34;*firefox\u0026#34;); $this-\u0026gt;setBrowserUrl(\u0026#34;http://www.google.com/\u0026#34;); Python self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() Ruby @selenium = Selenium::ClientDriver.new(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;, 10000); @selenium.start Cada um desses exemplos abre o navegador e representa esse navegador atribuindo uma \u0026ldquo;instância do navegador\u0026rdquo; a uma variável de programa. Esta variável de programa é então usada para chamar métodos do navegador. Esses métodos executam os comandos Selenium, ou seja, como open ou type ou verify.\nOs parâmetros necessários ao criar a instância do navegador são:\n  host Especifica o endereço IP do computador onde o servidor está localizado. Normalmente, esta é a mesma máquina em que o cliente está sendo executado, portanto, neste caso, localhost é passado. Em alguns clientes, este é um parâmetro opcional.\n  port Especifica o socket TCP/IP onde o servidor está escutando, esperando para o cliente estabelecer uma conexão. Isso também é opcional em alguns drivers do cliente.\n  browser O navegador no qual você deseja executar os testes. Este é um parâmetro obrigatório.\n  url A url base do aplicativo em teste. Isso é exigido por todas as libs de cliente e é uma informação integral para iniciar a comunicação entre navegador-proxy-aplicação.\n  Observe que algumas das bibliotecas cliente exigem que o navegador seja iniciado explicitamente chamando seu método start ().\nExecutando comandos Depois de ter o navegador inicializado e atribuído a uma variável (geralmente chamada \u0026ldquo;selenium\u0026rdquo;), você pode fazê-lo executar comandos Selenese chamando os respectivos métodos a partir da variável do navegador. Por exemplo, para chamar o método type do objeto selenium:\nselenium.type(\u0026#34;field-id\u0026#34;, \u0026#34;string to type\u0026#34;) Em segundo plano, o navegador realmente realizará uma operação type, essencialmente idêntico a um usuário digitando uma entrada no navegador, usando o localizador e a string que você especificou durante a chamada do método.\nReportando resultados O Selenium RC não tem seu próprio mecanismo para relatar os resultados. Em vez disso, você pode construir seus relatórios personalizados de acordo com suas necessidades, usando recursos de sua linguagem de programação escolhida. Isso é ótimo, mas e se você simplesmente quiser algo rápido que já foi feito para você? Muitas vezes, uma biblioteca existente ou estrutura de teste pode atender às suas necessidades mais rapidamente do que desenvolver seu próprio código de relatório de teste.\nFerramentas de reporte dos frameworks de teste Frameworks de teste estão disponíveis para muitas linguagens de programação. Estes, junto com sua função principal de fornecer um mecanismo de teste flexível para executar seus testes, incluem o código da biblioteca para relatar os resultados. Por exemplo, Java tem dois frameworks de teste comumente usados, JUnit e TestNG. .NET também tem seu próprio, NUnit.\nNão ensinaremos os frameworks aqui; e que está além do escopo deste guia de usuário. Vamos simplesmente apresentar os recursos do framework relacionados ao Selenium junto com algumas técnicas que você pode aplicar. Existem bons livros disponíveis sobre estas estruturas de teste, juntamente com informações na Internet.\nBibliotecas de relatórios de teste Também estão disponíveis bibliotecas de terceiros criadas especificamente para reportar os resultados dos testes na linguagem de programação escolhida. Estes geralmente suportam uma variedade de formatos, como HTML ou PDF.\nQual a melhor técnica? A maioria das pessoas novas no uso dos frameworks de teste começarão com os recursos de relatórios integrados no framework. A partir daí, a maioria examinará todas as bibliotecas disponíveis pois isso consome menos tempo do que desenvolver a sua própria. Quando você começa a usar o Selenium, sem dúvida, você vai começar a colocar seus próprios \u0026ldquo;prints\u0026rdquo; para relatar o progresso. Isso pode levá-lo gradualmente a desenvolver seus próprios relatórios, possivelmente em paralelo ao uso de uma biblioteca ou estrutura de teste. Independentemente, após a curta curva de aprendizado inicial você desenvolverá naturalmente o que funciona melhor para sua própria situação.\nExemplos de relatórios de teste Para ilustrar, iremos direcioná-lo para algumas ferramentas específicas em algumas das outras linguagens apoiadas pelo Selenium. As listadas aqui são comumente usadas e têm sido usadas extensivamente (e portanto recomendadas) pelos autores deste guia.\nRelatórios de teste em Java   Se os casos de teste Selenium forem desenvolvidos usando JUnit, então o relatório JUnit pode ser usado para gerar relatórios de teste.\n  Se os casos de teste Selenium forem desenvolvidos usando TestNG, então nenhuma tarefa externa é necessária para gerar relatórios de teste. A estrutura TestNG gera um Relatório HTML que lista os detalhes dos testes.\n  ReportNG é um plug-in de relatório HTML para a estrutura TestNG. Destina-se a substituir o relatório HTML padrão do TestNG. O ReportNG fornece uma visualização simples e codificada por cores dos resultados do teste.\n  Registrando os comandos Selenese  O Logging Selenium pode ser usado para gerar um relatório de todos os comandos Selenese em seu teste junto com o sucesso ou fracasso de cada um. Logging Selenium estende o driver do cliente Java para adicionar esta capacidade de registro do Selenese.  Relatórios de teste em Python  Ao usar o driver de cliente para Python, HTMLTestRunner pode ser usado para gerar um relatório de teste.  Relatórios de teste em Ruby  Se o framework RSpec for usado para escrever Casos de Teste Selenium em Ruby então seu relatório HTML pode ser usado para gerar um relatório de teste.  Adicionando algum tempero aos seus testes Agora veremos toda a razão de usar Selenium RC, adicionando lógica de programação aos seus testes. É o mesmo que para qualquer programa. O fluxo do programa é controlado por meio de declarações de condição e iteração. Além disso, você pode relatar informações de progresso usando I/O. Nesta secção vamos mostrar alguns exemplos de como construções de linguagem de programação podem ser combinadas com Selenium para resolver problemas de teste comuns.\nVocê vai descobrir ao fazer a transição dos testes simples da existência de elementos de página para testes de funcionalidade dinâmica envolvendo várias páginas da web e dados variáveis que você exigirá lógica de programação para verificar resultados. Basicamente, a Selenium-IDE não suporta iteração e declarações de condição padrão. Você pode fazer algumas condições incorporando JavaScript em parâmetros Selenese, no entanto iteração é impossível, e a maioria das condições será muito mais fácil em uma linguagem de programação. Além disso, você pode precisar de tratamento de exceção para recuperação de erros. Por essas e outras razões, escrevemos esta seção para ilustrar o uso de técnicas de programação comuns para dar a você maior \u0026lsquo;poder de verificação\u0026rsquo; em seus testes automatizados.\nOs exemplos nesta seção são escritos em C# e Java, embora o código seja simples e possa ser facilmente adaptado às demais linguagens. Se você tem algum conhecimento básico de uma linguagem de programação orientada a objetos, você não deve ter dificuldade em entender esta seção.\nIteração A iteração é uma das coisas mais comuns que as pessoas precisam fazer em seus testes. Por exemplo, você pode querer executar uma pesquisa várias vezes. Ou, talvez para verificar os resultados do teste, você precisa processar um \u0026ldquo;conjunto de resultados\u0026rdquo; retornado de um banco de dados.\nUsando o mesmo exemplo de pesquisa do Google que usamos anteriormente, vamos verificar os resultados da pesquisa Selenium. Este teste pode usar o Selenese:\n          open /    type q selenium rc   clickAndWait btnG    assertTextPresent Results * for selenium rc    type q selenium ide   clickAndWait btnG    assertTextPresent Results * for selenium ide    type q selenium grid   clickAndWait btnG    assertTextPresent Results * for selenium grid     O código foi repetido para executar as mesmas etapas 3 vezes. Mas ter múltiplas cópias do mesmo código não é uma boa prática de programação porque é mais trabalhoso para manter. Usando uma linguagem de programação, podemos iterar sobre os resultados da pesquisa para uma solução mais flexível e sustentável.\nIn C# // Collection of String values.  String[] arr = {\u0026#34;ide\u0026#34;, \u0026#34;rc\u0026#34;, \u0026#34;grid\u0026#34;}; // Execute loop for each String in array \u0026#39;arr\u0026#39;.  foreach (String s in arr) { sel.open(\u0026#34;/\u0026#34;); sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium \u0026#34; +s); sel.click(\u0026#34;btnG\u0026#34;); sel.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(\u0026#34;Expected text: \u0026#34; +s+ \u0026#34; is missing on page.\u0026#34; , sel.isTextPresent(\u0026#34;Results * for selenium \u0026#34; + s)); } Declarações de condição Para ilustrar o uso de condições em testes, começaremos com um exemplo. Um problema comum encontrado durante a execução de testes Selenium ocorre quando o elemento esperado não está disponível na página. Por exemplo, ao executar a seguinte linha:\nselenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium \u0026#34; +s); Se o elemento \u0026lsquo;q\u0026rsquo; não estiver na página, então uma exceção é lançada:\ncom.thoughtworks.selenium.SeleniumException: ERROR: Element q not found Isso pode fazer com que seu teste seja interrompido. Para alguns testes, é isso que você deseja. Mas frequentemente isso não é desejável, pois seu script de teste tem muitos outros testes subsequentes para realizar.\nUma abordagem melhor é primeiro validar se o elemento está realmente presente e então escolher alternativas quando não estiver. Vejamos isso usando Java.\n// If element is available on page then perform type operation.  if(selenium.isElementPresent(\u0026#34;q\u0026#34;)) { selenium.type(\u0026#34;q\u0026#34;, \u0026#34;Selenium rc\u0026#34;); } else { System.out.printf(\u0026#34;Element: \u0026#34; +q+ \u0026#34; is not available on page.\u0026#34;) } A vantagem desta abordagem é continuar com a execução do teste, mesmo se alguns elementos de IU não estão disponíveis na página.\nExecutando JavaScript a partir do seu teste JavaScript é muito útil para exercitar uma aplicação que não é diretamente suportada por Selenium. O método getEval da API Selenium pode ser usado para executar JavaScript a partir de Selenium RC.\nConsidere um aplicativo com caixas de seleção sem identificadores estáticos. Neste caso, pode-se avaliar o JavaScript do Selenium RC para obter ids de todas caixas de seleção e, em seguida, exercitá-las.\npublic static String[] getAllCheckboxIds () { String script = \u0026#34;var inputId = new Array();\u0026#34;;// Create array in java script. \tscript += \u0026#34;var cnt = 0;\u0026#34;; // Counter for check box ids. \tscript += \u0026#34;var inputFields = new Array();\u0026#34;; // Create array in java script. \tscript += \u0026#34;inputFields = window.document.getElementsByTagName(\u0026#39;input\u0026#39;);\u0026#34;; // Collect input elements. \tscript += \u0026#34;for(var i=0; i\u0026lt;inputFields.length; i++) {\u0026#34;; // Loop through the collected elements. \tscript += \u0026#34;if(inputFields[i].id !=null \u0026#34; + \u0026#34;\u0026amp;\u0026amp; inputFields[i].id !=\u0026#39;undefined\u0026#39; \u0026#34; + \u0026#34;\u0026amp;\u0026amp; inputFields[i].getAttribute(\u0026#39;type\u0026#39;) == \u0026#39;checkbox\u0026#39;) {\u0026#34;; // If input field is of type check box and input id is not null. \tscript += \u0026#34;inputId[cnt]=inputFields[i].id ;\u0026#34; + // Save check box id to inputId array. \t\u0026#34;cnt++;\u0026#34; + // increment the counter. \t\u0026#34;}\u0026#34; + // end of if. \t\u0026#34;}\u0026#34;; // end of for. \tscript += \u0026#34;inputId.toString();\u0026#34; ;// Convert array in to string.\t\tString[] checkboxIds = selenium.getEval(script).split(\u0026#34;,\u0026#34;); // Split the string. \treturn checkboxIds; } Para contar as imagens em uma página\nselenium.getEval(\u0026#34;window.document.images.length;\u0026#34;); Lembre-se de usar o objeto window no caso de expressões DOM já que por padrão a janela Selenium é referida, não a janela de teste.\nOpções do servidor Quando o servidor é iniciado, as opções de linha de comando podem ser usadas para alterar o comportamento padrão do servidor.\nLembre-se de que o servidor é iniciado executando o seguinte.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar Para ver a lista de opções, execute o servidor com a opção -h.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -h Você verá uma lista de todas as opções que pode usar com o servidor e uma breve descrição de cada. As descrições fornecidas nem sempre serão suficientes, então fornecemos explicações para algumas das opções mais importantes.\nConfiguração do Proxy Se o seu aplicação estiver atrás de um proxy HTTP que requer autenticação, você deve configurar http.proxyHost, http.proxyPort, http.proxyUser e http.proxyPassword usando o seguinte comando.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -Dhttp.proxyHost=proxy.com -Dhttp.proxyPort=8080 -Dhttp.proxyUser=username -Dhttp.proxyPassword=password Modo multi-janela Se você estiver usando Selenium 1.0, você provavelmente pode pular esta seção, uma vez que o modo multijanela é o comportamento padrão. No entanto, antes da versão 1.0, o Selenium executava por padrão o aplicativo em teste em um subquadro, conforme mostrado aqui.\nAlguns aplicativos não funcionavam corretamente em um subquadro e precisavam ser carregados no quadro superior da janela. A opção de modo multi-janela permitida a aplicação testada ser executada em uma janela separada, em vez do quadro padrão onde poderia então ter o quadro superior necessário.\nPara versões mais antigas do Selenium você deve especificar o modo multijanela explicitamente com a seguinte opção:\n-multiwindow A partir do Selenium RC 1.0, se você deseja executar seu teste dentro de um quadro único (ou seja, usando o padrão para versões anteriores do Selenium) você pode declarar isso ao servidor Selenium usando a opção\n-singlewindow Especificando o perfil do Firefox O Firefox não executará duas instâncias simultaneamente, a menos que você especifique um perfil separado para cada instância. Selenium RC 1.0 e posterior é executado em um perfil separado automaticamente, então se você estiver usando Selenium 1.0, você pode provavelmente pular esta seção. No entanto, se você estiver usando uma versão mais antiga do Selenium ou se você precisar usar um perfil específico para seus testes (como adicionar um certificado https ou ter alguns complementos instalados), você precisa especificar explicitamente o perfil.\nPrimeiro, para criar um perfil separado do Firefox, siga este procedimento. Abra o menu Iniciar do Windows, selecione \u0026ldquo;Executar\u0026rdquo;, digite e entre um dos seguintes:\nfirefox.exe -profilemanager firefox.exe -P Crie o novo perfil usando a caixa de diálogo. Então, quando você executar o Selenium Server, diga a ele para usar este novo perfil do Firefox com a opção de linha de comando do servidor -firefoxProfileTemplate e especifique o caminho para o perfil usando seu nome de arquivo e o caminho do diretório.\n-firefoxProfileTemplate \u0026#34;path to the profile\u0026#34; Aviso: certifique-se de colocar seu perfil em uma nova pasta separada da padrão!!! A ferramenta gerenciadora de perfil do Firefox irá deletar todos os arquivos em uma pasta se você excluir um perfil, independentemente de serem arquivos de perfil ou não.\nMais informações sobre os perfis do Firefox podem ser encontradas em Mozilla\u0026rsquo;s Knowledge Base\nExecute Selenese diretamente dentro do servidor usando -htmlSuite Você pode executar arquivos Selenese html diretamente no servidor Selenium passando o arquivo html para a linha de comando do servidor. Por exemplo:\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -htmlSuite \u0026#34;*firefox\u0026#34; \u0026#34;http://www.google.com\u0026#34; \u0026#34;c:\\absolute\\path\\to\\my\\HTMLSuite.html\u0026#34; \u0026#34;c:\\absolute\\path\\to\\my\\results.html\u0026#34; Isso iniciará automaticamente seu pacote HTML, executará todos os testes e salvará um bom relatório HTML com os resultados.\nNota: ao usar esta opção, o servidor irá iniciar os testes e aguardar um número especificado de segundos para o teste ser concluído; se o teste não completar dentro desse período de tempo, o comando sairá com um código de saída diferente de zero e nenhum arquivo de resultados será gerado.\nEsta linha de comando é muito longa, então tome cuidado com o que você digita. Observe que isso requer que você passe uma suíte de arquivos HTML Selenese, não um único teste. Também esteja ciente de que a opção -htmlSuite é incompatível com -interactive. Você não pode executar os dois ao mesmo tempo.\nLogging do servidor Selenium logs do lado do servidor Ao iniciar o servidor Selenium, a opção -log pode ser usada para gravar informações valiosas de depuração relatadas pelo servidor Selenium em um arquivo de texto.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -log selenium.log Este arquivo de log é mais detalhado do que os logs do console padrão (inclui mensagens de registro de nível DEBUG ). O arquivo de log também inclui o nome do registrador e o número do thread que registrou a mensagem. Por exemplo:\n20:44:25 DEBUG [12] org.openqa.selenium.server.SeleniumDriverResourceHandler - Browser 465828/:top frame1 posted START NEW O formato da mensagem é\nTIMESTAMP(HH:mm:ss) LEVEL [THREAD] LOGGER - MESSAGE Esta mensagens pode ter múltiplas linhas.\nLogs do lado do navegador O JavaScript no lado do navegador (Selenium Core) também registra mensagens importantes; em muitos casos, eles podem ser mais úteis para o usuário final do que os Logs normais do servidor. Para acessar os registros do lado do navegador, passe o argumento -browserSideLog para o servidor Selenium.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -browserSideLog -browserSideLog deve ser combinado com o argumento -log, para registrar browserSideLogs (bem como todas as outras mensagens de log de nível DEBUG) em um arquivo.\nEspecificando o caminho para um navegador específico Você pode especificar para o Selenium RC o caminho para um navegador. Isto é útil se você possui diferentes versões do mesmo navegador e você deseja usar uma em específico. Isto também pode ser usado para executar seus testes em um navegador que não é suportado diretamente pelo Selenium RC. Quando especificar o modo de execução, use o especificador *custom seguido do caminho completo para o executável do navegador.\n*custom \u0026lt;path to browser\u0026gt; Arquitetura do Selenium RC Nota: este tópico tenta explicar a implementação técnica por trás do Selenium RC. Não é fundamental para um usuário Selenium saber disso, mas pode ser útil para entender alguns dos problemas que você pode encontrar no futuro.\nPara entender em detalhes como o Selenium RC Server funciona e porque ele usa injeção de proxy e modos de privilégio elevado você deve primeiro entender the same origin policy.\nA política de mesma origem (Same Origin Policy) A principal restrição que o Selenium enfrenta é a política de mesma origem. Esta restrição de segurança é aplicada por todos os navegadores no mercado e seu objetivo é garantir que o conteúdo de um site nunca esteja acessível por um script de outro site. A política da mesma origem determina que qualquer código carregado no navegador só pode operar dentro do domínio desse site. Ele não pode executar funções em outro site. Por exemplo, se o navegador carrega o código JavaScript quando carrega www.mysite.com, ele não pode executar esse código carregado em www.mysite2.com - mesmo que seja outro de seus sites. Se isso fosse possível, um script colocado em qualquer site que você abrir seria capaz de ler informações sobre sua conta bancária se você tivesse a página da conta aberto em outra guia. Isso é chamado de XSS (Cross-site Scripting).\nPara trabalhar dentro desta política, Selenium-Core (e seus comandos JavaScript que fazem toda a mágica acontecer) deve ser colocado na mesma origem do aplicativo testado (mesmo URL).\nHistoricamente, Selenium-Core era limitado por este problema, uma vez que foi implementado em JavaScript. O Selenium RC não é, entretanto, restringido pela Política da Mesma Origem. Seu uso do Selenium Server como proxy evita esse problema. Essencialmente, diz ao navegador que o navegador está funcionando em um único site \u0026ldquo;falsificado\u0026rdquo; que o servidor fornece.\nNota: você pode encontrar informações adicionais sobre este tópico nas páginas da Wikipedia sobre a política da mesma origem e XSS.\nInjeção de Proxy O primeiro método que o Selenium usou para evitar a Política de Mesma Origem foi a injeção de proxy. No modo de injeção de proxy, o servidor Selenium atua como um HTTP configurado pelo cliente proxy 1, que fica entre o navegador e o aplicativo em teste 2. Em seguida, ele mascara a aplicação testada sob uma URL fictícia (incorporação Selenium-Core e o conjunto de testes e entregando-os como se estivessem chegando da mesma origem).\nAqui está um diagrama da arquitetura.\nQuando um conjunto de testes começa em sua linguagem favorita, acontece o seguinte:\n O cliente/driver estabelece uma conexão com o servidor selenium-RC. O servidor Selenium RC inicia um navegador (ou reutiliza um antigo) com uma URL que injeta o JavaScript do Selenium-Core na página da web carregada pelo navegador. O driver do cliente passa um comando Selenese para o servidor. O servidor interpreta o comando e então aciona a execução correspondente de JavaScript para executar esse comando no navegador. Selenium-Core instrui o navegador a agir sobre a primeira instrução, normalmente abrindo uma página da aplicação testada. O navegador recebe a solicitação de abertura e pede o conteúdo do site do servidor Selenium RC (definido como o proxy HTTP para o navegador usar). O servidor Selenium RC se comunica com o servidor Web solicitando a página e uma vez que recebe, envia a página para o navegador mascarando a origem para parecer que a página vem do mesmo servidor que Selenium-Core (isso permite Selenium-Core para cumprir a Política da Mesma Origem). O navegador recebe a página da web e a renderiza no quadro/janela reservado para isso.  Navegadores com privilégio elevado Este fluxo de trabalho neste método é muito semelhante à injeção de proxy, mas a principal diferença é que os navegadores são iniciados em um modo especial chamado de Privilégios Aumentados, que permite que os sites façam coisas que normalmente não são permitidas (como fazer XSS, ou preencher entradas de upload de arquivos e coisas muito úteis para o Selenium). Ao usar esses modos de navegador, o Selenium Core é capaz de abrir diretamente a aplicação testada e ler/interagir com seu conteúdo sem ter que passar a aplicação inteira através do servidor Selenium RC.\nAqui está um diagrama da arquitetura.\nQuando um conjunto de testes começa em sua linguagem favorita, acontece o seguinte:\n O cliente/driver estabelece uma conexão com o servidor selenium-RC. O servidor Selenium RC inicia um navegador (ou reutiliza um antigo) com uma URL que irá carregar o Selenium-Core na página da web. Selenium-Core obtém a primeira instrução do cliente/driver (através de outra solicitação HTTP feita ao servidor Selenium RC). Selenium-Core atua na primeira instrução, normalmente abrindo uma página da aplicação. O navegador recebe a solicitação de abertura e solicita a página ao servidor da Web. Assim que o navegador recebe a página da web, a renderiza no quadro / janela reservado para isso.  Lidando com HTTPS e Popups de segurança Muitos aplicativos mudam de HTTP para HTTPS quando precisam enviar informações criptografadas, como senhas ou informações de cartão de crédito. Isto é comum com muitos dos aplicativos da web de hoje. Selenium RC apoia isso.\nPara garantir que o site HTTPS seja genuíno, o navegador precisará de um certificado de segurança. Caso contrário, quando o navegador acessar a aplicação testada usando HTTPS, ele irá presumir que o aplicativo não é \u0026lsquo;confiável\u0026rsquo;. Quando isso ocorre, o navegador exibe pop-ups de segurança e esses pop-ups não podem ser fechados usando o Selenium RC.\nAo lidar com HTTPS em um teste Selenium RC, você deve usar um modo de execução que suporte isso e controle o certificado de segurança para você. Você especifica o modo de execução quando seu programa de teste inicializa o Selenium.\nNo Selenium RC 1.0 beta 2 e posterior, use *firefox ou *iexplore para o modo de execução. Em versões anteriores, incluindo Selenium RC 1.0 beta 1, use *chrome ou *iehta, para o modo de execução. Usando esses modos de execução, você não precisará instalar quaisquer certificados de segurança especiais; Selenium RC cuidará disso para você.\nNa versão 1.0, os modos de execução *firefox ou *iexplore são recomendados. No entanto, existem modos de execução adicionais de *iexploreproxy e *firefoxproxy. Eles são fornecidos apenas para compatibilidade com versões anteriores, e não devem ser usados, a menos que exigido por programas de teste legados. Seu uso vai apresentar limitações com o manuseio do certificado de segurança e com o funcionamento de várias janelas se seu aplicativo abrir janelas adicionais do navegador.\nEm versões anteriores do Selenium RC, *chrome ou *iehta eram os modos de execução que suportavam HTTPS suportado e o tratamento de popups de segurança. Estes foram considerados \u0026lsquo;modos experimentais\u0026rsquo;, embora tenham se tornado bastante estáveis e muitas pessoas os usaram. Se você estiver usando Selenium 1.0 você não precisa, e não deve usar, esses modos de execução mais antigos.\nCertificados de Segurança explicados Normalmente, seu navegador confiará no aplicativo que você está testando instalando um certificado de segurança que você já possui. Você pode verificar isso nas opções do seu navegador ou propriedades da Internet (se você não conheça o certificado de segurança da sua aplicação, pergunte ao administrador do sistema). Quando o Selenium carrega seu navegador, ele injeta um código para interceptar mensagens entre o navegador e o servidor. O navegador agora pensa que algum software não confiável está tentando se parecer com o seu aplicativo. Ele responde alertando você com mensagens pop-up.\nPara contornar isso, Selenium RC, (novamente ao usar um modo de execução que suporta isso) instalará seu próprio certificado de segurança, temporariamente, em sua máquina cliente em um local onde o navegador possa acessá-lo. Isso engana o navegador a pensar que está acessando um site diferente da sua aplicação e suprime efetivamente os pop-ups.\nOutro método usado com versões anteriores do Selenium era instalar o certificado de segurança Cybervillians fornecido com sua instalação do Selenium. A maioria dos usuários não deve mais precisar fazer isso; se você está executando o Selenium RC no modo de injeção de proxy, você pode precisar instalar explicitamente este certificado de segurança.\nSuportando navegadores e configurações adicionais A API Selenium suporta a execução em vários navegadores, além de Internet Explorer e Mozilla Firefox. Veja o site https://selenium.dev para navegadores compatíveis. Além disso, quando um navegador não é diretamente compatível, você ainda pode executar seus testes Selenium em um navegador de sua escolha usando o modo de execução \u0026ldquo;*custom\u0026rdquo; (ou seja, no lugar de *firefox ou *iexplore) quando seu aplicativo de teste inicia o navegador. Com isso, você passa no caminho para os navegadores executáveis na chamada de API. Isso também pode ser feito a partir do servidor em modo interativo.\ncmd=getNewBrowserSession\u0026amp;1=*custom c:\\Program Files\\Mozilla Firefox\\MyBrowser.exe\u0026amp;2=http://www.google.com Executando testes com diferentes configurações de navegador Normalmente o Selenium RC configura automaticamente o navegador, mas se você iniciar o navegador usando o modo de execução \u0026ldquo;*custom\u0026rdquo;, você pode forçar o Selenium RC a iniciar o navegador como está, sem usar uma configuração automática.\nPor exemplo, você pode iniciar o Firefox com uma configuração personalizada como esta:\ncmd=getNewBrowserSession\u0026amp;1=*custom c:\\Program Files\\Mozilla Firefox\\firefox.exe\u0026amp;2=http://www.google.com Observe que ao iniciar o navegador desta forma, você deve manualmente configurar o navegador para usar o servidor Selenium como proxy. Normalmente, isso apenas significa abrir as preferências do navegador e especificar \u0026ldquo;localhost: 4444\u0026rdquo; como um proxy HTTP, mas as instruções para isso podem diferir radicalmente de navegador para navegador. Consulte a documentação do seu navegador para obter detalhes.\nEsteja ciente de que os navegadores Mozilla podem variar em como eles iniciam e param. Pode ser necessário definir a variável de ambiente MOZ_NO_REMOTE para fazer com que os navegadores Mozilla se comportem de maneira mais previsível. Os usuários Unix devem evitar iniciar o navegador usando um script de shell; geralmente é melhor usar o executável binário (por exemplo, firefox-bin) diretamente.\nResolução de problemas comuns Ao começar a usar o Selenium RC, há alguns problemas potenciais que são comumente encontrados. Nós os apresentamos junto com suas soluções aqui.\nIncapaz de conectar ao servidor Quando seu programa de teste não pode se conectar ao servidor Selenium, o Selenium lança uma exceção em seu programa de teste. Ele deve exibir esta mensagem ou outra semelhante:\n\u0026#34;Unable to connect to remote server (Inner Exception Message: No connection could be made because the target machine actively refused it )\u0026#34; (using .NET and XP Service Pack 2) Se você vir uma mensagem como esta, certifique-se de iniciar o servidor Selenium. E se então, há um problema com a conectividade entre a biblioteca cliente Selenium e o servidor Selenium.\nAo começar com Selenium RC, a maioria das pessoas começa executando seu programa de teste (com uma biblioteca de cliente Selenium) e o servidor Selenium na mesma máquina. Para fazer isso use \u0026ldquo;localhost\u0026rdquo; como parâmetro de conexão. Recomendamos começar dessa forma, pois reduz a influência de possíveis problemas de rede que você está começando. Supondo que seu sistema operacional tenha uma rede típica e configurações TCP/IP, você deve ter pouca dificuldade. Na verdade, muitas pessoas optam por executar os testes desta forma.\nSe, no entanto, você deseja executar o Selenium Server em uma máquina remota, a conectividade deve ser boa, supondo que você tenha uma conexão TCP/IP válida entre as duas máquinas.\nSe tiver dificuldade para se conectar, você pode usar ferramentas de rede comuns como ping, telnet, ifconfig (Unix) / ipconfig (Windows), etc para garantir que você tenha uma conexão de rede. Se não estiver familiarizado com eles, o administrador do sistema pode ajudá-lo.\nIncapaz de carregar o navegador Ok, não é uma mensagem de erro amigável, desculpe, mas se o servidor Selenium não pode carregar o navegador você provavelmente verá este erro.\n(500) Internal Server Error Isso pode ser causado por\n O Firefox (anterior ao Selenium 1.0) não pode iniciar porque o navegador já está aberto e você o fez não especificar um perfil separado. Consulte a seção sobre perfis do Firefox em Opções do servidor. O modo de execução que você está usando não corresponde a nenhum navegador em sua máquina. Verifique os parâmetros que você passou para o Selenium quando seu programa abre o navegador. Você especificou o caminho para o navegador explicitamente (usando \u0026ldquo;*custom\u0026rdquo; - veja acima), mas o caminho é incorreto. Verifique se o caminho está correto. Verifique também o grupo de usuários para ter certeza de que há nenhum problema conhecido com seu navegador e os parâmetros \u0026ldquo;*custom\u0026rdquo;.  Selenium não consegue achar a aplicação testada Se o seu programa de teste iniciar o navegador com sucesso, mas o navegador não exibir o site que você está testando, a causa mais provável é que o seu programa de teste não está usando a URL correta.\nIsso pode acontecer facilmente. Quando você usa Selenium-IDE para exportar seu script, ela insere uma URL fictícia. Você deve alterar manualmente a URL para a correta para que seu aplicativo seja testado.\nO Firefox recusou o desligamento ao preparar um perfil Isso ocorre com mais frequência quando você executa o programa de teste Selenium RC no Firefox, mas você já tem uma sessão do navegador Firefox em execução e não especificou um perfil separado quando você iniciou o servidor Selenium. O erro do programa de teste tem a seguinte aparência:\nError: java.lang.RuntimeException: Firefox refused shutdown while preparing a profile Esta é a mensagem de erro completa do servidor:\n16:20:03.919 INFO - Preparing Firefox profile... 16:20:27.822 WARN - GET /selenium-server/driver/?cmd=getNewBrowserSession\u0026amp;1=*fir efox\u0026amp;2=http%3a%2f%2fsage-webapp1.qa.idc.com HTTP/1.1 java.lang.RuntimeException: Firefox refused shutdown while preparing a profile at org.openqa.selenium.server.browserlaunchers.FirefoxCustomProfileLaunc her.waitForFullProfileToBeCreated(FirefoxCustomProfileLauncher.java:277) ... Caused by: org.openqa.selenium.server.browserlaunchers.FirefoxCustomProfileLaunc her$FileLockRemainedException: Lock file still present! C:\\DOCUME~1\\jsvec\\LOCALS ~1\\Temp\\customProfileDir203138\\parent.lock Para resolver isso, consulte a seção Especificando um perfil separado do Firefox\nProblemas de versionamento Certifique-se de que sua versão do Selenium é compatível com a versão do seu navegador. Por exemplo, Selenium RC 0.92 não suporta Firefox 3. Às vezes você pode ter sorte (eu tive). Mas não se esqueça de verificar quais versões do navegador são compatíveis com a versão do Selenium que você está usando. Quando em dúvida, use a versão mais recente do Selenium com a versão mais usada do seu navegador.\nMensagem de erro: \u0026ldquo;(Unsupported major.minor version 49.0)\u0026rdquo; ao inicializar o servidor Este erro diz que você não está usando uma versão correta do Java. O Selenium Server requer Java 1.5 ou superior.\nPara verificar novamente sua versão java, execute na linha de comando:\njava -version Você deve ver uma mensagem mostrando a versão do Java.\njava version \u0026#34;1.5.0_07\u0026#34; Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_07-b03) Java HotSpot(TM) Client VM (build 1.5.0_07-b03, mixed mode) Se você vir um número de versão inferior, pode ser necessário atualizar o JRE, ou você pode simplesmente precisar adicioná-lo à sua variável de ambiente PATH.\nErro 404 ao executar o comando getNewBrowserSession Se você receber um erro 404 ao tentar abrir uma página em \u0026ldquo;http://www.google.com/selenium-server/\u0026quot;, então deve ser porque o servidor Selenium não foi configurado corretamente como proxy. O diretório \u0026ldquo;selenium-server\u0026rdquo; não existe no google.com; só parece existir quando o proxy é configurado corretamente. A configuração do proxy depende muito de como o navegador é lançado com firefox, iexplore, opera ou custom.\n  iexplore: se o navegador for iniciado usando *iexplore, você pode estar tendo um problema com as configurações de proxy do Internet Explorer. O servidor Selenium tenta definir as configurações globais de proxy no painel de controle Opções da Internet. Você deve se certificar de que elas estão corretamente configuradas quando o servidor Selenium inicia o navegador. Tente olhar para seu painel de controle Opções da Internet. Clique na guia \u0026ldquo;Conexões\u0026rdquo; e clique em \u0026ldquo;Configurações da LAN\u0026rdquo;.\n Se você precisar usar um proxy para acessar o aplicativo que deseja testar, você precisará iniciar o Selenium Server com \u0026ldquo;-Dhttp.proxyHost\u0026rdquo;; veja Configuração de Proxy para mais detalhes. Você também pode tentar configurar seu proxy manualmente e, em seguida, iniciar o navegador com *custom ou com o iniciador de navegador *iehta.    custom: ao usar *custom, você deve configurar o proxy corretamente (manualmente), caso contrário, você obterá um erro 404. Verifique novamente se você configurou seu proxy corretamente. Verificar se você configurou o proxy corretamente é configurar intencionalmente o navegador de forma incorreta. Tente configurar o navegador para usar o nome de host do servidor proxy errado ou a porta errada. Se você tinha configurado com sucesso as configurações de proxy do navegador incorretamente, então o navegador não conseguirá se conectar à Internet, o que é uma maneira de certificar-se de que está ajustando as configurações relevantes.\n  Para outros navegadores (*firefox, *opera), codificamos automaticamente o proxy para você e, portanto, não há problemas conhecidos com essa funcionalidade. Se você estiver encontrando erros 404 e tiver seguido este guia do usuário cuidadosamente publique seus resultados no grupo de usuários para obter ajuda da comunidade de usuários.\n  Erro de permissão negada O motivo mais comum para esse erro é que sua sessão está tentando violar a política de mesma origem cruzando os limites do domínio (por exemplo, acessa uma página de http://domínio1 e, em seguida, acessa uma página de http://domínio2) ou troca de protocolos (passando de http://domainX para https://domainX).\nEste erro também pode ocorrer quando o JavaScript tenta encontrar objetos de IU que ainda não estão disponíveis (antes que a página seja completamente carregada), ou não estão mais disponíveis (após a página começar a ser descarregada). Isso é mais comumente encontrado com páginas AJAX que estão trabalhando com seções de uma página ou subframes que carregam e / ou recarregam independentemente da página maior.\nEste erro pode ser intermitente. Muitas vezes é impossível reproduzir o problema com um depurador porque o problema decorre de condições de corrida que não são reproduzíveis quando a sobrecarga do depurador é adicionada ao sistema. As questões de permissão são abordadas com alguns detalhes no tutorial. Leia a seção sobre a Política da Mesma Origem, Injeção de Proxy com cuidado.\nGerenciando janelas pop-up do navegador Existem vários tipos de \u0026ldquo;Popups\u0026rdquo; que você pode obter durante um teste Selenium. Você pode não conseguir fechar esses pop-ups executando comandos do Selenium se eles são iniciados pelo navegador e não pela aplicação testada. Você pode precisar saber como gerenciá-los. Cada tipo de pop-up precisa ser tratado de maneira diferente.\n  Diálogos de autenticação básica de HTTP: esses diálogos solicitam um nome de usuário / senha para fazer o login no site. Para fazer login em um site que requer autenticação básica HTTP, use um nome de usuário e senha no URL, como descrito em RFC 1738, assim: open(\u0026ldquo;http://myusername:myuserpassword@myexample.com/blah/blah/blah\u0026quot;).\n  Avisos de certificado SSL: Selenium RC tenta automaticamente falsificar certificados SSL quando está habilitado como proxy; veja mais sobre isso na seção HTTPS. Se o seu navegador estiver configurado corretamente, você nunca deve ver avisos de certificado SSL, mas pode ser necessário configurar seu navegador para confiar em nossa perigosa CA SSL \u0026ldquo;CyberVillains\u0026rdquo;. Novamente, consulte a seção HTTPS para saber como fazer isso.\n  caixas de diálogo de alerta / confirmação / prompt de JavaScript modais: Selenium tenta ocultar essas caixas de diálogo de você (substituindo window.alert, window.confirm e window.prompt) para que não parem a execução da sua página. Se você está vendo um pop-up de alerta, provavelmente é porque ele disparou durante o processo de carregamento da página, o que geralmente é muito cedo para protegermos a página. Selenese contém comandos para afirmar ou verificar pop-ups de alerta e confirmação. Veja as seções sobre estes tópicos no Capítulo 4.\n  No Linux, por que minha sessão do navegador Firefox não está fechando? No Unix / Linux, você deve invocar \u0026ldquo;firefox-bin\u0026rdquo; diretamente, então certifique-se de que este executável está no path. Se estiver executando o Firefox por meio de um script de shell, quando chegar a hora de encerrar o navegador, o Selenium RC irá encerrar o script de shell, deixando o navegador em execução. Você pode especificar o caminho para o firefox-bin diretamente, assim:\ncmd=getNewBrowserSession\u0026amp;1=*firefox /usr/local/firefox/firefox-bin\u0026amp;2=http://www.google.com Firefox *chrome não funciona com perfil personalizado Verifique a pasta de perfil do Firefox -\u0026gt; prefs.js -\u0026gt; user_pref (\u0026ldquo;browser.startup.page\u0026rdquo;, 0); Comente esta linha assim: \u0026ldquo;//user_pref(\u0026ldquo;browser.startup.page\u0026rdquo;, 0); \u0026quot; e tente novamente.\nPosso carregar um pop-up personalizado enquanto a página pai está carregando (ou seja, antes que a função javascript window.onload() da página principal seja executada)? Não. O Selenium depende de interceptadores para determinar os nomes das janelas à medida que são carregadas. Esses interceptores funcionam melhor na captura de novas janelas se as janelas forem carregadas DEPOIS a função onload(). O Selenium pode não reconhecer as janelas carregadas antes da função onload.\nFirefox no Linux No Unix / Linux, versões do Selenium anteriores a 1.0 precisavam invocar \u0026ldquo;firefox-bin\u0026rdquo; diretamente, então, se você estiver usando uma versão anterior, certifique-se de que o real executável está no caminho.\nNa maioria das distribuições Linux, o verdadeiro firefox-bin está localizado em:\n/usr/lib/firefox-x.x.x/ Onde x.x.x é o número da versão que você possui atualmente. Então, para adicionar esse caminho no path do usuário. você terá que adicionar o seguinte ao seu arquivo .bashrc:\nexport PATH=\u0026#34;$PATH:/usr/lib/firefox-x.x.x/\u0026#34; Se necessário, você pode especificar o caminho para o firefox-bin diretamente em seu teste, assim:\n\u0026#34;*firefox /usr/lib/firefox-x.x.x/firefox-bin\u0026#34; IE e atributos de estilo Se você estiver executando seus testes no Internet Explorer e não conseguir localizar elementos usando seu atributo style. Por exemplo:\n//td[@style=\u0026#34;background-color:yellow\u0026#34;] Isso funcionaria perfeitamente no Firefox, Opera ou Safari, mas não com o IE. O IE interpreta as chaves em @style como maiúsculas. Então, mesmo que o o código-fonte está em letras minúsculas, você deve usar:\n//td[@style=\u0026#34;BACKGROUND-COLOR:yellow\u0026#34;] Isso é um problema se o seu teste se destina a funcionar em vários navegadores, mas você pode facilmente codificar seu teste para detectar a situação e tentar o localizador alternativo que só funciona no IE.\nErro encontrado - \u0026ldquo;Cannot convert object to primitive value\u0026rdquo; no delsigamento do navegador *googlechrome Para evitar esse erro, você deve iniciar o navegador com uma opção que desativa as verificações da política de mesma origem:\nselenium.start(\u0026#34;commandLineFlags=--disable-web-security\u0026#34;); Erro encontrado no IE - \u0026ldquo;Couldn\u0026rsquo;t open app window; is the pop-up blocker enabled?\u0026rdquo; Para evitar esse erro, você deve configurar o navegador: desative o bloqueador de pop-ups e desmarque a opção \u0026lsquo;Ativar modo protegido\u0026rsquo; em Ferramentas \u0026raquo; Opções \u0026raquo; Segurança.\n  O proxy é uma terceira pessoa no meio que passa a bola entre as duas partes. Ele atua como um \u0026ldquo;servidor da web\u0026rdquo; que entrega a aplicação ao navegador. Ser um proxy dá ao Selenium Server a capacidade de \u0026ldquo;mentir\u0026rdquo; sobre a URL real da aplicação. \u0026#x21a9;\u0026#xfe0e;\n O navegador é iniciado com um perfil de configuração que definiu localhost:4444 como o proxy HTTP, é por isso que qualquer solicitação HTTP que o navegador fizer passará pelo servidor Selenium e a resposta passará por ele e não pelo servidor real. \u0026#x21a9;\u0026#xfe0e;\n   "},{"uri":"https://www.selenium.dev/documentation/pt-br/getting_started/quick/","title":"Tour rápido","tags":[],"description":"","content":"Selenium não é só uma ferramenta ou API, mas sim uma composição de várias ferramentas.\nWebDriver Se você está começando com automação de testes de um site de desktop ou site para celular, então vai usar as APIs WebDriver. O WebDriver usa APIs de automação de navegador disponibilizadas por fornecedores de navegador para o controlar e executar testes. É como se um usuário real o estivesse operando. Como o WebDriver não exige que sua API seja compilada com o código do aplicativo, não é intrusivo. Portanto, você está testando o mesmo aplicativo que você envia aos ambientes de produção.\nIDE IDE (Ambiente de Desenvolvimento Integrado, em português) é a ferramenta que você usa para desenvolver seus casos de teste Selenium. É uma extensão para Chrome e Firefox fácil de usar e geralmente é a maneira mais eficiente de desenvolver casos de teste. Ela registra as ações dos usuários no navegador para você, usando comandos Selenium existentes, com parâmetros definidos pelo contexto daquele elemento. Isso não é apenas uma economia de tempo, mas também uma maneira excelente de aprender a sintaxe de script do Selenium.\nGrid Selenium Grid permite que você execute casos de teste em diferentes máquinas em diferentes plataformas. O controle para acionar os casos de teste está na extremidade local, e quando os casos de teste são acionados, eles são automaticamente executados pela extremidade remota.\nApós o desenvolvimento dos testes WebDriver, você pode enfrentar a necessidade de executar seus testes em vários navegadores e combinações de sistemas operacionais. É aqui que o Grid entra em cena.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/remote_webdriver/remote_webdriver_client/","title":"Cliente do WebDriver remoto","tags":[],"description":"","content":"  Page being translated from English to Portuguese. Do you speak Portuguese? Help us to translate it by sending us pull requests!\n Para executar um cliente WebDriver remoto, primeiro precisamos nos conectar ao RemoteWebDriver. Fazemos isso apontando a URL para o endereço do servidor que está executando nossos testes. Para personalizar nossa configuração, definimos os recursos desejados. Abaixo está um exemplo de como instanciar um objeto WebDriver remoto apontando para nosso servidor remoto da web, www.example.com, executando nossos testes no Firefox.\nJava Python C# Ruby JavaScript Kotlin FirefoxOptions firefoxOptions = new FirefoxOptions(); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();   from selenium import webdriver firefox_options = webdriver.FirefoxOptions() driver = webdriver.Remote( command_executor=\u0026#39;http://www.example.com\u0026#39;, options=firefox_options ) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   FirefoxOptions firefoxOptions = new FirefoxOptions(); IWebDriver driver = new RemoteWebDriver(new Uri(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions); driver.Navigate().GoToUrl(\u0026#34;http://www.google.com\u0026#34;); driver.Quit();   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :remote, url: \u0026#34;http://www.example.com\u0026#34;, desired_capabilities: :firefox driver.get \u0026#34;http://www.google.com\u0026#34; driver.close   const { Builder, Capabilities } = require(\u0026#34;selenium-webdriver\u0026#34;); var capabilities = Capabilities.firefox(); (async function helloSelenium() { let driver = new Builder() .usingServer(\u0026#34;http://example.com\u0026#34;) .withCapabilities(capabilities) .build(); try { await driver.get(\u0026#39;http://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   firefoxOptions = FirefoxOptions() driver: WebDriver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()     Para personalizar ainda mais nossa configuração de teste, podemos adicionar outros recursos desejados.\nOpções do browser Por exemplo, suponha que você queira executar o Chrome no Windows XP, usando o Chrome versão 67:\nJava Python C# Ruby JavaScript Kotlin ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setCapability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); chromeOptions.setCapability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), chromeOptions); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();   from selenium import webdriver chrome_options = webdriver.ChromeOptions() chrome_options.set_capability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;) chrome_options.set_capability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;) driver = webdriver.Remote( command_executor=\u0026#39;http://www.example.com\u0026#39;, options=chrome_options ) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var chromeOptions = new ChromeOptions(); chromeOptions.BrowserVersion = \u0026#34;67\u0026#34;; chromeOptions.PlatformName = \u0026#34;Windows XP\u0026#34;; IWebDriver driver = new RemoteWebDriver(new Uri(\u0026#34;http://www.example.com\u0026#34;), chromeOptions); driver.Navigate().GoToUrl(\u0026#34;http://www.google.com\u0026#34;); driver.Quit();   caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.platform = Windows XP caps.version = 67 driver = Selenium::WebDriver.for :remote, :url =\u0026gt; \u0026#34;http://www.example.com\u0026#34;, :desired_capabilities =\u0026gt; caps   const { Builder } = require(\u0026#34;selenium-webdriver\u0026#34;); const chrome = require(\u0026#34;selenium-webdriver/chrome\u0026#34;); let opts = new chrome.Options(); opts.setAcceptInsecureCerts(true); opts.setBrowserVersion(\u0026#39;67\u0026#39;); opts.setPlatform(\u0026#39;Windows XP\u0026#39;); (async function helloSelenium() { let driver = new Builder() .usingServer(\u0026#34;http://example.com\u0026#34;) .forBrowser(\u0026#39;chrome\u0026#39;) .setChromeOptions(opts) .build(); try { await driver.get(\u0026#39;http://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   val chromeOptions = ChromeOptions() chromeOptions.setCapability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;) chromeOptions.setCapability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;) val driver: WebDriver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), chromeOptions) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()     Detector de arquivo local O Detector de Arquivo Local permite a transferência de arquivos da máquina do cliente para o servidor remoto. Por exemplo, se um teste precisa carregar um arquivo para um aplicativo da web, um WebDriver remoto pode transferir automaticamente o arquivo da máquina local para o servidor web remoto durante o tempo de execução. Isso permite que o arquivo seja carregado da máquina remota executando o teste. Não é habilitado por padrão e pode ser habilitado em da seguinte forma:\nJava Python C# Ruby JavaScript Kotlin driver.setFileDetector(new LocalFileDetector());   from selenium.webdriver.remote.file_detector import LocalFileDetector driver.file_detector = LocalFileDetector()   var allowsDetection = this.driver as IAllowsFileDetection; if (allowsDetection != null) { allowsDetection.FileDetector = new LocalFileDetector(); }   @driver.file_detector = lambda do |args| # args =\u0026gt; [\u0026#34;/path/to/file\u0026#34;] str = args.first.to_s str if File.exist?(str) end   var remote = require(\u0026#39;selenium-webdriver/remote\u0026#39;); driver.setFileDetector(new remote.FileDetector);   driver.fileDetector = LocalFileDetector()     Assim que o código acima for definido, você pode fazer upload de um arquivo em seu teste da seguinte maneira:\nJava Python C# Ruby JavaScript Kotlin driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); WebElement upload = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)); upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;) driver.find_element(By.ID, \u0026#34;myfile\u0026#34;).send_keys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;)   driver.Navigate().GoToUrl(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); IWebElement upload = driver.FindElement(By.Id(\u0026#34;myfile\u0026#34;)); upload.SendKeys(@\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   @driver.navigate.to \u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34; element = @driver.find_element(:id, \u0026#39;myfile\u0026#39;) element.send_keys \u0026#34;/Users/sso/SauceLabs/sauce/hostess/maitred/maitred/public/images/darkbulb.jpg\u0026#34;   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); var upload = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)); upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;) val upload: WebElement = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)) upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;)     Tracing client requests This feature is only available for Java client binding (Beta onwards). The Remote WebDriver client sends requests to the Selenium Grid server, which passes them to the WebDriver. Tracing should be enabled at the server and client-side to trace the HTTP requests end-to-end. Both ends should have a trace exporter setup pointing to the visualization framework. By default, tracing is enabled for both client and server. To set up the visualization framework Jaeger UI and Selenium Grid 4, please refer to Tracing Setup for the desired version.\nFor client-side setup, follow the steps below.\nBeta 1 Add the required dependencies Installation of external libraries for tracing exporter can be done using Maven. Add the opentelemetry-exporter-jaeger and grpc-netty dependency in your project pom.xml:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.opentelemetry\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;opentelemetry-exporter-jaeger\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.14.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.grpc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;grpc-netty\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.34.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Add/pass the required system properties while running the client Java Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;JAEGER_SERVICE_NAME\u0026#34;, \u0026#34;selenium-java-client\u0026#34;); System.setProperty(\u0026#34;JAEGER_AGENT_HOST\u0026#34;,\u0026#34;localhost\u0026#34;); System.setProperty(\u0026#34;JAEGER_AGENT_PORT\u0026#34;,\u0026#34;14250\u0026#34;); ImmutableCapabilities capabilities = new ImmutableCapabilities(\u0026#34;browserName\u0026#34;, \u0026#34;chrome\u0026#34;); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), capabilities); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();     Beta 2 onwards Add the required dependencies Installation of external libraries for tracing exporter can be done using Maven. Add the opentelemetry-exporter-jaeger and grpc-netty dependency in your project pom.xml:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.opentelemetry\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;opentelemetry-exporter-jaeger\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.grpc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;grpc-netty\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.35.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Add/pass the required system properties while running the client Java Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;otel.traces.exporter\u0026#34;, \u0026#34;jaeger\u0026#34;); System.setProperty(\u0026#34;otel.exporter.jaeger.endpoint\u0026#34;, \u0026#34;http://localhost:14250\u0026#34;); System.setProperty(\u0026#34;otel.resource.attributes\u0026#34;, \u0026#34;service.name=selenium-java-client\u0026#34;); ImmutableCapabilities capabilities = new ImmutableCapabilities(\u0026#34;browserName\u0026#34;, \u0026#34;chrome\u0026#34;); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), capabilities); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();     Please refer to Tracing Setup for more information on external dependencies versions required for the desired Selenium version.\nMore information can be found at:\n OpenTelemetry: https://opentelemetry.io Configuring OpenTelemetry: https://github.com/open-telemetry/opentelemetry-java/tree/main/sdk-extensions/autoconfigure Jaeger: https://www.jaegertracing.io Selenium Grid Observability  "},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/grid_3/setting_up_your_own_grid/","title":"Configurando a sua","tags":[],"description":"","content":"Para usar Selenium Grid, você precisa manter sua própria infraestrutura para os nós. Como isso pode ser um esforço pesado e intenso, muitas organizações usam provedores IaaS como Amazon EC2 e Google Compute para fornecer essa infraestrutura.\nOutras opções incluem o uso de provedores como Sauce Labs ou Testing Bot que fornecem uma Selenium Grid como um serviço na nuvem. Certamente também é possível executar nós em seu próprio hardware. Este capítulo entrará em detalhes sobre a opção de executar sua própria Grid, completo com sua própria infraestrutura de nós.\nInício Este exemplo mostrará como iniciar o Selenium 2 Grid Hub, e registrar um nó WebDriver e um nó legado Selenium 1 RC. Também mostraremos como chamar a Grid a partir do Java. O hub e os nós são mostrados aqui em execução na mesma máquina, mas é claro que você pode copiar o selenium-server-standalone para várias máquinas.\nO pacote selenium-server-standalone inclui o hub, WebDriver e RC legado necessários para executar o Grid, ant não é mais necessário. Você pode baixar o selenium-server-standalone.jar de https://selenium.dev/downloads/.\nPasso 1: Inicialize o Hub O Hub é o ponto central que receberá solicitações de teste e os distribuirá para os nós certos. A distribuição é feita com base em recursos, significando que um teste que requer um conjunto de recursos só será distribuído para nós que oferecem esse conjunto ou subconjunto de recursos.\nPorque os recursos desejados de um teste são apenas o que o nome indica, desired, o hub não pode garantir que localizará um nó corresponder totalmente ao conjunto de recursos desejados solicitados.\nAbra um prompt de comando e navegue até o diretório onde você copiou o arquivo selenium-server-standalone.jar. Você inicia o hub passando a sinalização -role hub para o servidor autônomo:\njava -jar selenium-server-standalone.jar -role hub The Hub will listen to port 4444 by default. You can view the status of the hub by opening a browser window and navigating to http://localhost:4444/grid/console.\nPara alterar a porta padrão, você pode adicionar a flag opcional -port com um número inteiro representando a porta a ser ouvida quando você executa o comando. Além disso, todas as outras opções que você vê no arquivo de configuração JSON (veja abaixo) são possíveis flags de linha de comando.\nVocê certamente pode sobreviver apenas com o comando simples mostrado acima, mas se você precisar de uma configuração mais avançada, você também pode especificar um arquivo de configuração de formato JSON, por conveniência, para configurar o hub ao iniciá-lo. Você pode fazer assim:\njava -jar selenium-server-standalone.jar -role hub -hubConfig hubConfig.json -debug Abaixo você verá um exemplo de um arquivo hubConfig.json. Entraremos em mais detalhes sobre como fornecer arquivos de configuração de nó no Passo 2.\n{ \u0026#34;_comment\u0026#34; : \u0026#34;Configuration for Hub - hubConfig.json\u0026#34;, \u0026#34;host\u0026#34;: ip, \u0026#34;maxSession\u0026#34;: 5, \u0026#34;port\u0026#34;: 4444, \u0026#34;cleanupCycle\u0026#34;: 5000, \u0026#34;timeout\u0026#34;: 300000, \u0026#34;newSessionWaitTimeout\u0026#34;: -1, \u0026#34;servlets\u0026#34;: [], \u0026#34;prioritizer\u0026#34;: null, \u0026#34;capabilityMatcher\u0026#34;: \u0026#34;org.openqa.grid.internal.utils.DefaultCapabilityMatcher\u0026#34;, \u0026#34;throwOnCapabilityNotPresent\u0026#34;: true, \u0026#34;nodePolling\u0026#34;: 180000, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;} Pasos 2: Inicialize os Nós Independentemente de você querer executar uma Grid com a nova funcionalidade WebDriver, ou uma Grid com funcionalidade Selenium 1 RC, ou os dois ao mesmo tempo, você usa o mesmo arquivo selenium-server-standalone.jar para iniciar os nós:\njava -jar selenium-server-standalone.jar -role node -hub http://localhost:4444 Se uma porta não for especificada por meio do sinalizador -port, uma porta livre será escolhida. Você pode executar vários nós em uma máquina mas se você fizer isso, você precisa estar ciente dos recursos de memória de seus sistemas e problemas com capturas de tela se seus testes as fizerem.\nConfiguração de um nó com opções Como mencionado, para compatibilidade com versões anteriores as funções “wd” e “rc” ainda são um subconjunto válido da função “node”. Mas essas funções limitam os tipos de conexões remotas para sua API correspondente, enquanto “node” permite conexões remotas RC e WebDriver.\nAo passar propriedades JVM (usando o sinalizador -D antes do argumento -jar) na linha de comando também, estas serão coletadas e propagadas para os nós:\n-Dwebdriver.chrome.driver=chromedriver.exe\nConfiguração de um nó com JSON Você também pode iniciar nós da Grid que estão configurados com um arquivo de configuração JSON\njava -Dwebdriver.chrome.driver=chromedriver.exe -jar selenium-server-standalone.jar -role node -nodeConfig node1Config.json E aqui está um exemplo do arquivo nodeConfig.json:\n{ \u0026#34;capabilities\u0026#34;: [ { \u0026#34;browserName\u0026#34;: \u0026#34;firefox\u0026#34;, \u0026#34;acceptSslCerts\u0026#34;: true, \u0026#34;javascriptEnabled\u0026#34;: true, \u0026#34;takesScreenshot\u0026#34;: false, \u0026#34;firefox_profile\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;browser-version\u0026#34;: \u0026#34;27\u0026#34;, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;maxInstances\u0026#34;: 5, \u0026#34;firefox_binary\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;cleanSession\u0026#34;: true }, { \u0026#34;browserName\u0026#34;: \u0026#34;chrome\u0026#34;, \u0026#34;maxInstances\u0026#34;: 5, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;webdriver.chrome.driver\u0026#34;: \u0026#34;C:/Program Files (x86)/Google/Chrome/Application/chrome.exe\u0026#34; }, { \u0026#34;browserName\u0026#34;: \u0026#34;internet explorer\u0026#34;, \u0026#34;maxInstances\u0026#34;: 1, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;webdriver.ie.driver\u0026#34;: \u0026#34;C:/Program Files (x86)/Internet Explorer/iexplore.exe\u0026#34; } ], \u0026#34;configuration\u0026#34;: { \u0026#34;_comment\u0026#34; : \u0026#34;Configuration for Node\u0026#34;, \u0026#34;cleanUpCycle\u0026#34;: 2000, \u0026#34;timeout\u0026#34;: 30000, \u0026#34;proxy\u0026#34;: \u0026#34;org.openqa.grid.selenium.proxy.WebDriverRemoteProxy\u0026#34;, \u0026#34;port\u0026#34;: 5555, \u0026#34;host\u0026#34;: ip, \u0026#34;register\u0026#34;: true, \u0026#34;hubPort\u0026#34;: 4444, \u0026#34;maxSession\u0026#34;: 5 } } Uma observação sobre a flag -host\nPara hub e nó, se a flag -host não for especificada, 0.0.0.0 será usado por padrão. Isso se ligará a todos as interfaces IPv4 públicas (sem loopback) da máquina. Se você tem uma configuração especial de rede ou qualquer componente que crie interfaces de rede extras, é aconselhável definir a flag -host com um valor que permite o hub / nó acessível a partir de uma máquina diferente.\nEspecificando a porta A porta TCP / IP padrão usada pelo hub é 4444. Se você precisar alterar a porta use as configurações mencionadas acima.\nSolução de problemas Usando um arquivo de log Para solução de problemas avançada, você pode especificar um arquivo de log para registrar mensagens do sistema. Inicie o hub ou nó Selenium Grid com o argumento -log. Por favor, veja o exemplo abaixo:\njava -jar selenium-server-standalone.jar -role hub -log log.txt Use o seu editor de texto favorito para abrir o arquivo de log (log.txt no exemplo acima) para encontrar registros de \u0026ldquo;ERROR\u0026rdquo; se você tiver problemas.\nUsando o argumento -debug Você também pode usar o argumento -debug para imprimir logs de depuração no console. Inicie o Selenium Grid Hub ou Node com o argumento -debug. Por favor, veja o exemplo abaixo:\njava -jar selenium-server-standalone.jar -role hub -debug Aviso A Selenium Grid deve ser protegida do acesso externo usando permissões de firewall.\nA falha em proteger sua rede pode resultar em um ou mais dos seguintes eventos:\n Você fornece acesso aberto à sua infraestrutura de rede Você permite que terceiros acessem aplicativos e arquivos internos da web Você permite que terceiros executem binários personalizados  Veja esta postagem do blog em Detectify, que dá uma boa visão geral de como uma rede exposta publicamente pode ser mal utilizada: Não deixe sua grade totalmente aberta.\nDocker Selenium Docker fornece uma maneira conveniente de provisionar e escalar a infraestrutura da Selenium Grid em uma unidade conhecida como contêiner. Os contêineres são unidades padronizadas de software que contêm tudo o que é necessário para executar o aplicativo desejado, incluindo todas as dependências, de forma confiável e repetível em máquinas diferentes.\nO projeto Selenium mantém um conjunto de imagens Docker que você pode baixar e executar para colocar uma Grid em funcionamento rapidamente. Os nós estão disponíveis para Firefox e Chrome. Detalhes completos de como provisionar uma grade podem ser encontrados no repositório Docker Selenium.\nPré-requisitos O único requisito para executar um Grid é ter o Docker instalado e funcionando. [Instale o Docker] (// www.docker.com/products/docker-desktop).\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/grid_4/setting_up_your_own_grid/","title":"Configurando a sua","tags":[],"description":"","content":"Diferentes modos de configuração de Grid no Selenium 4:  Standalone Hub and Node Distributed Docker  Modo Standalone: O novo Selenium Server Jar contém tudo que você precisa para executar uma Grid. É também o modo mais fácil de ligar uma Selenium Grid. Por padrão, o servidor estará escutando em http://localhost:4444, e essa é a URL para a qual você deve apontar seus testes RemoteWebDriver. O servidor detectará os drivers disponíveis que podem ser usados no PATH do sistema\njava -jar selenium-server-4.0.0-alpha-6.jar standalone Modo Hub e Nó: Inicialize o Hub: java -jar selenium-server-4.0.0-alpha-6.jar hub Registre o Nó: java -jar selenium-server-4.0.0-alpha-6.jar node --detect-drivers true Faça a busca na Selenium Grid: No Selenium 4, também adicionamos GraphQL, uma nova maneira de consultar os dados necessários facilmente e obter exatamente a mesma coisa.\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{ \u0026#34;query\u0026#34;: \u0026#34;{grid{uri}}\u0026#34; }\u0026#39; -s http://localhost:4444/graphql | jq . \nModo Distribuído:   Passo 1: Em primeiro lugar, inicie o Event Bus, ele serve como um caminho de comunicação para outros componentes da rede nas etapas subsequentes.\njava -jar selenium-server-4.0.0-alpha-6.jar event-bus   Passo 2: Inicie o mapa da sessão, que é responsável por mapear os IDs da sessão para o nó em que a sessão está sendo executada:\njava -jar selenium-server-4.0.0-alpha-6.jar sessions   Passo 3: Inicie o novo enfileirador de sessão, ele adiciona a nova solicitação de sessão a uma fila local. O distribuidor atende o pedido da fila.\njava -jar selenium-server-4.0.0-alpha-6.jar sessionqueuer   Passo 4: Inicie o Distribuidor. Todos os Nós são anexados como parte do processo do Distribuidor. É responsável por atribuir um nó, quando um pedido de criação de sessão é invocado.\njava -jar selenium-server-4.0.0-alpha-6.jar distributor --sessions http://localhost:5556 --sessionqueuer http://localhost:5559 --bind-bus false   Passo 5: A próxima etapa é iniciar o Roteador, um endereço que você exporia à web\njava -jar selenium-server-4.0.0-alpha-6.jar router --sessions http://localhost:5556 --distributor http://localhost:5553 --sessionqueuer http://localhost:5559   Step 6: Finalmente, adicione um Nó\njava -jar selenium-server-4.0.0-alpha-6.jar node --detect-drivers true   Inicie a Standalone Grid via imagens Docker Você pode simplesmente iniciar um Nó com o seguinte comando:\njava -jar selenium-server-4.0.0-alpha-1.jar node -D selenium/standalone-firefox:latest \u0026#39;{\u0026#34;browserName\u0026#34;: \u0026#34;firefox\u0026#34;}\u0026#39; Você pode iniciar o servidor Selenium e delegá-lo ao docker para a criação de novas instâncias:\njava -jar selenium-server-4.0.0-alpha-6.jar standalone -D selenium/standalone-firefox:latest \u0026#39;{\u0026#34;browserName\u0026#34;: \u0026#34;firefox\u0026#34;}\u0026#39; --detect-drivers false "},{"uri":"https://www.selenium.dev/documentation/pt-br/front_matter/typographical_conventions/","title":"Convenções tipográficas","tags":[],"description":"","content":"Capitalização de títulos Deve-se evitar a capitalização do título, como Um Título Muito Estiloso, e em vez disso, use Um título muito estiloso. Letras maiúsculas gratuitas, ou caixa do título, muitas vezes mostram um mal-entendido - ou um desprezo por - convenções ortográficas. Preferimos o que é conhecido como sentence case, com uma única inicial maiúscula para iniciar cabeçalhos.\nComprimento da linha Ao editar o código fonte da documentação, que é escrito em HTML puro, limite o comprimento das linhas a cerca de 72 caracteres.\nAlguns de nós dão um passo adiante e usam o que é chamado de linefeeds semânticos, que é uma técnica pela qual as linhas de origem HTML, que não são lidos pelo público, são divididas em \u0026ldquo;intervalos naturais\u0026rdquo; na prosa. Em outras palavras, as frases são divididas em quebras naturais entre as orações. Em vez de se preocupar com as linhas de cada parágrafo de modo que todos terminem perto da margem direita, os feeds de linha podem ser adicionados em qualquer lugar que existe uma ruptura entre as ideias.\nIsso pode tornar as diffs muito fáceis de ler ao colaborar por meio do git, mas não é algo que obrigamos os colaboradores a usar.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/worst_practices/file_downloads/","title":"Downloads de arquivo","tags":[],"description":"","content":"Embora seja possível iniciar um download clicando em um link com um navegador sob o controle do Selenium, a API não expõe o progresso do download, tornando-o menos do que ideal para testar arquivos baixados. Isso ocorre porque o download de arquivos não é considerado um aspecto importante de emular a interação do usuário com a plataforma da web. Em vez disso, encontre o link usando Selenium (e todos os cookies necessários) e passe este cookie para uma biblioteca de solicitação HTTP como libcurl.\nO driver HtmlUnit pode baixar anexos acessando-os como fluxos de entrada, implementando o AttachmentHandler. O AttachmentHandler pode ser adicionado ao WebClient HtmlUnit.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/getting_started_with_webdriver/third_party_drivers_and_plugins/","title":"Drivers e plugins de terceiros","tags":[],"description":"","content":"Selenium pode ser estendido com o uso de plug-ins. Aqui estão alguns plugins criados e mantidos por terceiros. Para obter mais informações sobre como para criar seu próprio plugin ou listá-lo, consulte a documentação.\nObserve que esses plug-ins não são suportados, mantidos, hospedados ou endossados pelo projeto Selenium. Além disso, esteja ciente de que os plug-ins listados abaixo não são necessariamente licenciados sob a Licença Apache v.2.0. Alguns dos plug-ins estão disponíveis em outro software de código aberto e gratuito licença; outros estão disponíveis apenas sob licença proprietária. Alguma pergunta sobre plug-ins e suas licenças de distribuição precisam ser levantadas com seus respectivo(s) desenvolvedor(es).\n   Nevgador Atual Changelog Issues     Mozilla GeckoDriver latest change log issue tracker   Google Chrome Driver latest change log issue tracker   Opera latest - issue tracker   Microsoft Edge Driver latest - issue tracker   SafariDriver Embutido - issue tracker    "},{"uri":"https://www.selenium.dev/documentation/pt-br/selenium_installation/installing_webdriver_binaries/","title":"Instalando binários do WebDriver","tags":[],"description":"","content":"Para executar seu projeto e controlar o navegador, você precisa ter binários WebDriver específicos do navegador instalados.\nBaixe o binário WebDriver suportado pelo seu navegador e coloque-o no System PATH.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/introduction/","title":"Introdução","tags":[],"description":"","content":"Introdução Selenium é um projeto abrangente para uma gama de ferramentas e bibliotecas que permitem e suportam a automação de navegadores da web.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/domain_specific_language/","title":"Linguagem específica de domínio (DSL)","tags":[],"description":"","content":"Uma linguagem específica de domínio (DSL) é um sistema que fornece ao usuário um meio expressivo de resolver um problema. Ele permite a um usuário interagir com o sistema em seus termos - não apenas na linguagem do programador.\nSeus usuários, em geral, não se importam com a aparência do seu site. Eles não preocupam-se com a decoração, animações ou gráficos. Eles deseja usar seu sistema para empurrar seus novos funcionários através do processo com dificuldade mínima; eles querem reservar uma viagem para o Alasca; eles querem configurar e comprar unicórnios com desconto. Seu trabalho como testador deve chegar o mais perto possível de “capturar” essa mentalidade. Com isso em mente, começamos a \u0026ldquo;modelar\u0026rdquo; o aplicativo que você está trabalhando, de modo que os scripts de teste (o único proxy de pré-lançamento do usuário) “fala a linguagem” e representa o usuário.\nCom Selenium, DSL é geralmente representado por métodos, escritos para fazer a API simples e legível - eles permitem um relatório entre o desenvolvedores e as partes interessadas (usuários, proprietários de produtos, negócios especialistas em inteligência, etc.).\nBenefícios  Legível: As partes interessadas da empresa podem entendê-lo. Gravável: Fácil de escrever, evita duplicações desnecessárias. Extensível: Funcionalidade pode (razoavelmente) ser adicionada sem quebrar contratos e funcionalidades existentes. Manutenção: Deixando os detalhes de implementação fora do teste casos, você está bem isolado contra alterações no AUT *.  Java Aqui está um exemplo de um método DSL razoável em Java. Por questão de brevidade, ele assume que o objeto driver é pré-definido e está disponível para o método.\n/** * Recebe um username e password, prrenche os campos, e clica em \u0026#34;login\u0026#34;. * @return Uma instância de AccountPage */ public AccountPage loginAsUser(String username, String password) { WebElement loginField = driver.findElement(By.id(\u0026#34;loginField\u0026#34;)); loginField.clear(); loginField.sendKeys(username); // Preenche o campo password. O localizador que estamos usando é \u0026#34;By.id\u0026#34;, e devemos  // definí-lo em algum outro lugar dentro da Classe.  WebElement passwordField = driver.findElement(By.id(\u0026#34;password\u0026#34;)); passwordField.clear(); passwordField.sendKeys(password); // Clica o botão de login, que possui o id \u0026#34;submit\u0026#34;.  driver.findElement(By.id(\u0026#34;submit\u0026#34;)).click(); // Cria e retorna uma nova instância de AccountPage (via o Selenium  // PageFactory embutido).  return PageFactory.newInstance(AccountPage.class); } Este método abstrai completamente os conceitos de campos de entrada, botões, cliques e até páginas do seu código de teste. Usando este abordagem, tudo o que o testador precisa fazer é chamar esse método. Isto dá uma vantagem de manutenção: se os campos de login mudaram, você teria apenas que alterar esse método - não seus testes.\npublic void loginTest() { loginAsUser(\u0026#34;cbrown\u0026#34;, \u0026#34;cl0wn3\u0026#34;); // Agora que estamos logados, fazemos alguma outra coisa--como usamos uma DSL para suportar  // nossos testadores, é apenas escolher um dos métodos disponíveis.  do.something(); do.somethingElse(); Assert.assertTrue(\u0026#34;Algo deveria ter sido feito!\u0026#34;, something.wasDone()); // Note que ainda não nos referimos a nenhum botão ou web control nesse  // script... } Vale a pena repetir: um de seus principais objetivos deve ser escrever um API que permite que seus testes resolvam o problema em questão, e NÃO o problema da IU. A IU é uma preocupação secundária para o seu usuários - eles não se importam com a interface do usuário, eles apenas querem fazer seu trabalho feito. Seus scripts de teste devem ser lidos como uma lista de itens sujos que o usuário deseja FAZER e as coisas que deseja SABER. Os testes não devem se preocupar com COMO a interface do usuário exige que você vá sobre isso.\n*AUT: Application under test\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/legacy_docs/migrating_from_rc_to_webdriver/","title":"Migrando do RC para WebDriver","tags":[],"description":"","content":"Como migrar para o Selenium WebDriver Uma pergunta comum ao adotar o Selenium 2 é qual é a coisa certa a fazer ao adicionar novos testes a um conjunto existente de testes? Usuários que são novos no framework podem começar usando as novas APIs WebDriver para escrever seus testes. Mas e os usuários que já possuem suítes de testes existentes? Este guia é projetado para demonstrar como migrar seus testes existentes para as novas APIs, permitindo que todos os novos testes sejam escritos usando os novos recursos oferecidos pelo WebDriver.\nO método apresentado aqui descreve uma migração gradativa para as APIs WebDriver sem precisar refazer tudo em um push massivo. Isso significa que você pode permitir mais tempo para migrar seus testes existentes, que pode tornar mais fácil para você decidir onde investir seu esforço.\nEste guia foi escrito em Java, porque tem o melhor suporte para fazer a migração. À medida que fornecemos ferramentas melhores para outras linguagens, este guia deve ser expandido para incluir essas linguagens.\nPorque migrar para o WebDriver Mover um conjunto de testes de uma API para outra requer uma enorme quantidade de esforço. Por que você e sua equipe considerariam fazer essa mudança? Aqui estão alguns motivos pelos quais você deve considerar a migração de seus testes Selenium para usar o WebDriver.\n API menor e compacta. A API do WebDriver é mais orientada a objetos do que o Selenium RC API original. Isso pode facilitar o trabalho. Melhor emulação das interações do usuário. Sempre que possível, o WebDriver faz uso de eventos nativos para interagir com uma página da web. Imita melhor a maneira como seus usuários trabalham com seu site e aplicativos. Além do que, o WebDriver oferece APIs de interações de usuário avançadas que permitem que você modele interações complexas com seu site. Suporte de fornecedores de navegadores. Opera, Mozilla e Google são todos participantes ativos do desenvolvimento do WebDriver, e cada um tem engenheiros trabalhando para melhorar a estrutura. Frequentemente, isso significa que o suporte para WebDriver está embutido no próprio navegador: seus testes são executados tão rápidos e estáveis quanto possível.  Antes de começar A fim de tornar o processo de migração o mais indolor possível, certifique-se de que todos os seus testes sejam executados corretamente com a versão mais recente do Selenium. Isso pode parecer óbvio, mas é melhor que seja dito!\nComeçando A primeira etapa ao iniciar a migração é mudar a forma como você obtém sua instância Selenium. Ao usar Selenium RC, isso é feito assim:\nSelenium selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.yoursite.com\u0026#34;); selenium.start(); Isso deve ser substituído assim:\nWebDriver driver = new FirefoxDriver(); Selenium selenium = new WebDriverBackedSelenium(driver, \u0026#34;http://www.yoursite.com\u0026#34;); Próximos passos Depois que seus testes forem executados sem erros, a próxima etapa é migrar o código de teste real para usar as APIs WebDriver. Dependendo de quão bem você abstrair o seu código, pode ser um processo curto ou longo. Em ambos os casos, a abordagem é a mesma e pode ser resumida simplesmente: modifique o código para usar a nova API quando for editá-lo.\nSe você precisar extrair a implementação WebDriver subjacente da instância Selenium, você pode simplesmente fazer um cast para WrapsDriver:\nWebDriver driver = ((WrapsDriver) selenium).getWrappedDriver(); Isso permite que você continue passando a instância Selenium como normal, mas desembrulhar a instância do WebDriver conforme necessário.\nEm algum ponto, sua base de código usará principalmente as APIs mais recentes. Neste ponto, você pode inverter o relacionamento, usando WebDriver em tudo e instanciar uma instância do Selenium sob demanda:\nSelenium selenium = new WebDriverBackedSelenium(driver, baseUrl); Problemas comuns Felizmente, você não é a primeira pessoa a passar por essa migração, então, aqui estão alguns problemas comuns que outras pessoas viram e como resolvê-los.\nClicar e digitar são mais completos Um padrão comum em um teste de Selenium RC é ver algo como:\nselenium.type(\u0026#34;name\u0026#34;, \u0026#34;exciting tex\u0026#34;); selenium.keyDown(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); selenium.keyPress(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); selenium.keyUp(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); Isso se baseia no fato de que o \u0026ldquo;tipo\u0026rdquo; simplesmente substitui o conteúdo do elemento identificado sem também disparar todos os eventos que normalmente seriam disparados se um usuário interagir com a página. As invocações diretas finais de \u0026ldquo;key*\u0026rdquo; faz com que os manipuladores JS sejam acionados conforme o esperado.\nAo usar o WebDriverBackedSelenium, o resultado do preenchimento do campo do formulário seria \u0026ldquo;exciting texttt\u0026rdquo;: não o que você esperaria! O motivo disso é que o WebDriver emula com mais precisão o comportamento do usuário, e assim terá disparado eventos o tempo todo.\nEsse mesmo fato às vezes pode fazer com que o carregamento da página seja disparado antes do que aconteceria em um teste de Selenium 1. Você pode dizer que isso aconteceu se uma \u0026ldquo;StaleElementException\u0026rdquo; é lançada pelo WebDriver.\nWaitForPageToLoad retorna muito cedo Descobrir quando o carregamento de uma página está completo é uma tarefa complicada. Queremos dizer \u0026ldquo;quando o evento de carregamento dispara\u0026rdquo;, \u0026ldquo;quando todas as solicitações AJAX são concluídas\u0026rdquo;, \u0026ldquo;quando não há tráfego de rede \u0026ldquo;,\u0026rdquo; quando document.readyState mudou\u0026rdquo; ou outra coisa completamente diferente?\nWebDriver tenta simular o comportamento original do Selenium, mas isso não sempre funciona perfeitamente por vários motivos. O motivo mais comum é que é difícil dizer a diferença entre um carregamento de página que ainda não começou e um carregamento da página concluído entre as chamadas de método. Isso às vezes significa que o controle é devolvido ao seu teste antes que a página termine (ou mesmo comece!) o carregamento.\nA solução para isso é esperar por algo específico. Normalmente, isso pode ser o elemento com o qual deseja interagir a seguir, ou para alguma variável Javascript a ser definida com um valor específico. Um exemplo seria:\nWait\u0026lt;WebDriver\u0026gt; wait = new WebDriverWait(driver, Duration.ofSeconds(30)); WebElement element= wait.until(visibilityOfElementLocated(By.id(\u0026#34;some_id\u0026#34;))); Onde \u0026ldquo;visibilityOfElementLocated\u0026rdquo; é implementado como:\npublic ExpectedCondition\u0026lt;WebElement\u0026gt; visibilityOfElementLocated(final By locator) { return new ExpectedCondition\u0026lt;WebElement\u0026gt;() { public WebElement apply(WebDriver driver) { WebElement toReturn = driver.findElement(locator); if (toReturn.isDisplayed()) { return toReturn; } return null; } }; } Isso pode parecer complexo, mas é quase todo um código padrão. O único interessante é que a \u0026ldquo;condição esperada\u0026rdquo; será avaliada repetidamente até que o método \u0026ldquo;apply\u0026rdquo; retorne algo que não seja \u0026ldquo;null\u0026rdquo; nem Boolean.FALSE.\nClaro, adicionar todas essas chamadas de \u0026ldquo;wait\u0026rdquo; pode confundir seu código. E se esse é o caso, e suas necessidades são simples, considere usar as esperas implícitas:\ndriver.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS); Ao fazer isso, toda vez que um elemento é localizado, se o elemento não estiver presente, o local é tentado novamente até que esteja presente ou até 30 segundos passados.\nEncontrar por seletores XPath ou CSS nem sempre funciona, mas funciona no Selenium 1 No Selenium 1, era comum para o xpath usar uma biblioteca agrupada em vez de os recursos do próprio navegador. WebDriver sempre usará os métodos nativos do navegador, a menos que não haja alternativa. Isso significa que expressões xpath complexas podem falhar em alguns navegadores.\nOs seletores CSS no Selenium 1 foram implementados usando a biblioteca Sizzle. Esta biblioteca implementa um superconjunto da CSS Selector Spec, e nem sempre é claro onde você cruzou a linha. Se você estiver usando o WebDriverBackedSelenium e usar um Localizador Sizzle em vez de um Seletor CSS para encontrar elementos, um aviso ser registrado no console. Vale a pena procurar por eles, particularmente se os testes estão falhando por não ser capaz de encontrar os elementos.\nNão há nenhum Browserbot O Selenium RC era baseado no Selenium Core e, portanto, quando você executava Javascript, você podia acessar bits do Selenium Core para tornar as coisas mais fáceis. Como o WebDriver não é baseado no Selenium Core, isso não é mais possível. Como você pode saber se está usando Selenium Core? Simples! Basta olhar para ver se o seu \u0026ldquo;getEval\u0026rdquo; ou chamadas semelhantes usam \u0026ldquo;selenium\u0026rdquo; ou \u0026ldquo;browserbot\u0026rdquo; no Javascript avaliado.\nVocê pode estar usando o browserbot para obter um identificador para a janela atual ou documento do teste. Felizmente, o WebDriver sempre avalia JS no contexto da janela atual, então você pode usar \u0026ldquo;window\u0026rdquo; ou \u0026ldquo;document\u0026rdquo; diretamente.\nComo alternativa, você pode usar o browserbot para localizar elementos. No WebDriver, o idioma para fazer isso é primeiro localizar o elemento, e então passe isso como um argumento para o Javascript. Portanto:\nString name = selenium.getEval( \u0026#34;selenium.browserbot.findElement(\u0026#39;id=foo\u0026#39;, browserbot.getCurrentWindow()).tagName\u0026#34;); se torna:\nWebElement element = driver.findElement(By.id(\u0026#34;foo\u0026#34;)); String name = (String) ((JavascriptExecutor) driver).executeScript( \u0026#34;return arguments[0].tagName\u0026#34;, element); Observe como a variável \u0026ldquo;element\u0026rdquo; passada aparece como o primeiro item na array de \u0026ldquo;arguments\u0026rdquo; padrão do JS.\nA execução de Javascript não retorna nada O JavascriptExecutor do WebDriver envolverá todo o JS e o avaliará como uma expressão anônima. Isso significa que você precisa usar a palavra-chave \u0026ldquo;return\u0026rdquo;:\nString title = selenium.getEval(\u0026#34;browserbot.getCurrentWindow().document.title\u0026#34;); se torna:\n((JavascriptExecutor) driver).executeScript(\u0026#34;return document.title;\u0026#34;); "},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/grid_4/advanced_features/observability/","title":"Observability","tags":[],"description":"","content":"  Page being translated from English to Portuguese (Brazil). Do you speak Portuguese (Brazil)? Help us to translate it by sending us pull requests!\n Table of Contents  Selenium Grid Observability  Distributed tracing Event logging   Grid Observability  Visualizing Traces Leveraging event logs   References  Selenium Grid Grid aids in scaling and distributing tests by executing tests on various browser and operating system combinations.\nObservability Observability has three pillars: traces, metrics and logs. Since Selenium Grid 4 is designed to be fully distributed, observability will make it easier to understand and debug the internals.\nDistributed tracing A single request or transaction spans multiple services and components. Tracing tracks the request lifecycle as each service executes the request. It is useful in debugging in an error scenario. Some key terms used in tracing context are:\nTrace Tracing allows one to trace a request through multiple services, starting from its origin to its final destination. This request\u0026rsquo;s journey helps in debugging, monitoring the end-to-end flow, and identifying failures. A trace depicts the end-to-end request flow. Each trace has a unique id as its identifier.\nSpan Each trace is made up of timed operations called spans. A span has a start and end time and it represents operations done by a service. The granularity of span depends on how it is instrumented. Each span has a unique identifier. All spans within a trace have the same trace id.\nSpan Attributes Span attributes are key-value pairs which provide additional information about each span.\nEvents Events are timed-stamped logs within a span. They provide additional context to the existing spans. Events also contain key-value pairs as event attributes.\nEvent logging Logging is essential to debug an application. Logging is often done in a human-readable format. But for machines to search and analyze the logs, it has to have a well-defined format. Structured logging is a common practice of recording logs consistently in a fixed format. It commonly contains fields like:\n Timestamp Logging level Logger class Log message (This is further broken down into fields relevant to the operation where the log was recorded)  Logs and events are closely related. Events encapsulate all the possible information available to do a single unit of work. Logs are essentially subsets of an event. At the crux, both aid in debugging. Refer following resources for detailed understanding:\n https://www.honeycomb.io/blog/how-are-structured-logs-different-from-events/ https://charity.wtf/2019/02/05/logs-vs-structured-events/  Grid Observability Selenium server is instrumented with tracing using OpenTelemetry. Every request to the server is traced from start to end. Each trace consists of a series of spans as a request is executed within the server. Most spans in the Selenium server consist of two events:\n Normal event - records all information about a unit of work and marks successful completion of the work. Error event - records all information till the error occurs and then records the error information. Marks an exception event.  Running Selenium server\n Standalone Hub and Node Fully Distributed Docker  Visualizing Traces All spans, events and their respective attributes are part of a trace. Tracing works while running the server in all of the above-mentioned modes.\nBy default, tracing is enabled in the Selenium server. Selenium server exports the traces via two exporters:\n Console - Logs all traces and their included spans at FINE level. By default, Selenium server prints logs at INFO level and above. The log-level flag can be used to pass a logging level of choice while running the Selenium Grid jar/s.  java -jar selenium-server-4.0.0-\u0026lt;selenium-version\u0026gt;.jar standalone --log-level FINE Jaeger UI - OpenTelemetry provides the APIs and SDKs to instrument traces in the code. Whereas Jaeger is a tracing backend, that aids in collecting the tracing telemetry data and providing querying, filtering and visualizing features for the data.  Detailed instructions of visualizing traces using Jaeger UI can be obtained by running the command :\njava -jar selenium-server-4.0.0-\u0026lt;selenium-version\u0026gt;.jar info tracing A very good example and scripts to run the server and send traces to Jaeger\nLeveraging event logs Tracing has to be enabled for event logging as well, even if one does not wish to export traces to visualize them.\nBy default, tracing is enabled. No additional parameters need to be passed to see logs on the console. All events within a span are logged at FINE level. Error events are logged at WARN level.\nAll event logs have the following fields : | Field | Field value | Description | |-|-|-| | Event time | eventId | Timestamp of the event record in epoch nanoseconds. | | Trace Id | tracedId | Each trace is uniquely identified by a trace id. | | Span Id | spanId | Each span within a trace is uniquely identified by a span id. | | Span Kind | spanKind | Span kind is a property of span indicating the type of span. It helps in understanding the nature of the unit of work done by the Span. | | Event name | eventName | This maps to the log message. | | Event attributes | eventAttributes | This forms the crux of the event logs, based on the operation executed, it has JSON formatted key-value pairs. This also includes a handler class attribute, to show the logger class. |\nSample log\nFINE [LoggingOptions$1.lambda$export$1] - { \u0026quot;traceId\u0026quot;: \u0026quot;fc8aef1d44b3cc8bc09eb8e581c4a8eb\u0026quot;, \u0026quot;spanId\u0026quot;: \u0026quot;b7d3b9865d3ddd45\u0026quot;, \u0026quot;spanKind\u0026quot;: \u0026quot;INTERNAL\u0026quot;, \u0026quot;eventTime\u0026quot;: 1597819675128886121, \u0026quot;eventName\u0026quot;: \u0026quot;Session request execution complete\u0026quot;, \u0026quot;attributes\u0026quot;: { \u0026quot;http.status_code\u0026quot;: 200, \u0026quot;http.handler_class\u0026quot;: \u0026quot;org.openqa.selenium.grid.router.HandleSession\u0026quot;, \u0026quot;http.url\u0026quot;: \u0026quot;\\u002fsession\\u002fdd35257f104bb43fdfb06242953f4c85\u0026quot;, \u0026quot;http.method\u0026quot;: \u0026quot;DELETE\u0026quot;, \u0026quot;session.id\u0026quot;: \u0026quot;dd35257f104bb43fdfb06242953f4c85\u0026quot; } }  In addition to the above fields, based on OpenTelemetry specification error logs consist of : | Field | Field value | Description | |-|-|-| | Exception type | exception.type | The class name of the exception. | | Exception message | exception.message | Reason for the exception. | | Exception stacktrace | exception.stacktrace | Prints the call stack at the point of time when the exception was thrown. Helps in understanding the origin of the exception. |\nSample error log\nWARN [LoggingOptions$1.lambda$export$1] - { \u0026quot;traceId\u0026quot;: \u0026quot;7efa5ea57e02f89cdf8de586fe09f564\u0026quot;, \u0026quot;spanId\u0026quot;: \u0026quot;914df6bc9a1f6e2b\u0026quot;, \u0026quot;spanKind\u0026quot;: \u0026quot;INTERNAL\u0026quot;, \u0026quot;eventTime\u0026quot;: 1597820253450580272, \u0026quot;eventName\u0026quot;: \u0026quot;exception\u0026quot;, \u0026quot;attributes\u0026quot;: { \u0026quot;exception.type\u0026quot;: \u0026quot;org.openqa.selenium.ScriptTimeoutException\u0026quot;, \u0026quot;exception.message\u0026quot;: \u0026quot;Unable to execute request: java.sql.SQLSyntaxErrorException: Table 'mysql.sessions_mappa' doesn't exist ...\u0026quot; (full message will be printed), \u0026quot;exception.stacktrace\u0026quot;: \u0026quot;org.openqa.selenium.ScriptTimeoutException: java.sql.SQLSyntaxErrorException: Table 'mysql.sessions_mappa' doesn't exist\\nBuild info: version: '4.0.0-alpha-7', revision: 'Unknown'\\nSystem info: host: 'XYZ-MacBook-Pro.local', ip: 'fe80:0:0:0:10d5:b63a:bdc6:1aff%en0', os.name: 'Mac OS X', os.arch: 'x86_64', os.version: '10.13.6', java.version: '11.0.7'\\nDriver info: driver.version: unknown ....\u0026quot; (full stack will be printed), \u0026quot;http.handler_class\u0026quot;: \u0026quot;org.openqa.selenium.grid.distributor.remote.RemoteDistributor\u0026quot;, \u0026quot;http.url\u0026quot;: \u0026quot;\\u002fsession\u0026quot;, \u0026quot;http.method\u0026quot;: \u0026quot;POST\u0026quot; } }  Note: Logs are pretty printed above for readability. Pretty printing for logs is turned off in Selenium server.\nThe steps above should set you up for seeing traces and logs.\nReferences  Understanding Tracing OpenTelemetry Tracing API Specification Selenium Wiki Structured logs vs events Jaeger framework  "},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/when_to_use_grid/","title":"Quando usar a Grid","tags":[],"description":"","content":"De modo geral, há dois motivos pelos quais você pode querer usar a Grid.\n Para executar seus testes em vários navegadores, várias versões de navegador, e navegadores executados em diferentes sistemas operacionais. Para reduzir o tempo que leva para o conjunto de testes concluir uma aprovação no teste.  A Grid é usada para acelerar a execução dos testes usando várias máquinas para executar testes em paralelo. Por exemplo, se você tiver um conjunto de 100 testes, mas você configurou o Grid para suportar 4 máquinas diferentes (VMs ou máquinas físicas separadas) para executar esses testes, seu conjunto de testes será concluído em (aproximadamente) um quarto do tempo, do que se você executasse seus testes sequencialmente em uma única máquina. Para grandes conjuntos de testes e conjuntos de testes de longa duração, como aqueles que realizam grandes quantidades de validação de dados, isso pode ser um economizador de tempo significativo. Alguns conjuntos de testes podem levar horas para serem executados. Outro motivo para impulsionar o tempo gasto na execução do pacote é para encurtar o tempo de resposta para os resultados do teste após o código de check-in dos desenvolvedores para o AUT. Cada vez mais equipes de software praticando o desenvolvimento de software Agile desejam testar o feedback tão imediatamente quanto possível, em oposição a esperar durante a noite para uma aprovação no teste durante a noite.\nA Grid também é usada para suportar testes em execução em vários ambientes de runtime, especificamente, em diferentes navegadores ao mesmo tempo. Por exemplo, uma ‘Grid’ de máquinas virtuais pode ser configurada com cada uma suportando um navegador diferente que o aplicativo a ser testado deve suportar. Então, máquina 1 tem Internet Explorer 8, máquina 2, Internet Explorer 9, máquina 3, o mais recente Chrome e máquina 4 com o Firefox mais recente. Quando o conjunto de testes é executado, o Selenium Grid recebe cada combinação de navegador de teste e atribui cada teste a um navegador necessário.\nAlém disso, pode-se ter uma Grid do mesmo navegador, tipo e versão. Por exemplo, pode-se ter uma Grid de 4 máquinas, cada uma executando 3 instâncias de Firefox 70, permitindo um ‘server-farm’ (em certo sentido) de Firefox. Quando o pacote é executado, cada teste é passado para o Grid que atribui o teste à próxima instância disponível do Firefox. Desta maneira um obtém aprovação em que, concebivelmente, 12 testes estão sendo executados ao mesmo tempo em paralelo, reduzindo significativamente o tempo necessário para concluir os testes.\nA Grid é muito flexível. Esses dois exemplos podem ser combinados para permitir várias instâncias de cada tipo e versão de navegador. Uma configuração como essa forneceria execução paralela para conclusão rápida de testes e suporte para vários tipos e versões de navegador simultaneamente.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/driver_idiosyncrasies/driver_specific_capabilities/","title":"Recursos específicos do Driver","tags":[],"description":"","content":"Firefox Definindo recursos usando FirefoxOptions FirefoxOptions é a nova forma de definir recursos para o Navegador Firefox e geralmente deve ser usado em detrimento de DesiredCapabilities.\nJava Python C# Ruby JavaScript Kotlin FirefoxOptions options = new FirefoxOptions(); options.addPreference(\u0026#34;network.proxy.type\u0026#34;, 0); driver = new RemoteWebDriver(options);   from selenium.webdriver.firefox.options import Options options = Options() options.headless = True driver = webdriver.Firefox(options=options)   var options = new FirefoxOptions(); options.Proxy.Kind = ProxyKind.Direct; var driver = new FirefoxDriver(options);   require \u0026#39;selenium-webdriver\u0026#39; opts = Selenium::WebDriver::Firefox::Options.new(args: [\u0026#39;-headless\u0026#39;]) driver = Selenium::WebDriver.for(:firefox, options: opts)   const { Builder } = require(\u0026#34;selenium-webdriver\u0026#34;); const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); options.headless(); const driver = new Builder() .forBrowser(\u0026#39;firefox\u0026#39;) .setFirefoxOptions(options) .build();   val options = new FirefoxOptions() options.addPreference(\u0026#34;network.proxy.type\u0026#34;, 0) driver = RemoteWebDriver(options)     Definindo um perfil personalizado É possível criar um perfil personalizado para o Firefox, conforme demonstrado abaixo.\nJava Python C# Ruby JavaScript Kotlin FirefoxProfile profile = new FirefoxProfile(); FirefoxOptions options = new FirefoxOptions(); options.setProfile(profile); driver = new RemoteWebDriver(options);   from selenium.webdriver.firefox.options import Options from selenium.webdriver.firefox.firefox_profile import FirefoxProfile options=Options() firefox_profile = FirefoxProfile() firefox_profile.set_preference(\u0026#34;javascript.enabled\u0026#34;, False) options.profile = firefox_profile   var options = new FirefoxOptions(); var profile = new FirefoxProfile(); options.Profile = profile; var driver = new RemoteWebDriver(options);   profile = Selenium::WebDriver::Firefox::Profile.new profile[\u0026#39;browser.download.dir\u0026#39;] = \u0026#34;/tmp/webdriver-downloads\u0026#34; options = Selenium::WebDriver::Firefox::Options.new(profile: profile) driver = Selenium::WebDriver.for :firefox, options: options   const { Builder } = require(\u0026#34;selenium-webdriver\u0026#34;); const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); let profile = \u0026#39;/path to custom profile\u0026#39;; options.setProfile(profile); const driver = new Builder() .forBrowser(\u0026#39;firefox\u0026#39;) .setFirefoxOptions(options) .build();   val options = FirefoxOptions() options.profile = FirefoxProfile() driver = RemoteWebDriver(options)     Internet Explorer fileUploadDialogTimeout Em alguns ambientes, o Internet Explorer pode expirar ao abrir a Caixa de Diálogo de upload de arquivo. O IEDriver tem um tempo limite padrão de 1000 ms, mas você pode aumentar o tempo limite usando o recurso fileUploadDialogTimeout.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.waitForUploadDialogUpTo(Duration.ofSeconds(2)); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.file_upload_dialog_timeout = 2000 driver = webdriver.Ie(options=options) # Navegar para Url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.FileUploadDialogTimeout = TimeSpan.FromMilliseconds(2000); var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.file_upload_dialog_timeout = 2000 driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().fileUploadDialogTimeout(2000); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.waitForUploadDialogUpTo(Duration.ofSeconds(2)) val driver = RemoteWebDriver(options)     ensureCleanSession Quando definido como true, este recurso limpa o Cache, Histórico do navegador e cookies para todas as instâncias em execução do InternetExplorer, incluindo aquelas iniciadas manualmente ou pelo driver. Por padrão, é definido como false.\nUsar este recurso causará queda de desempenho quando iniciar o navegador, pois o driver irá esperar até que o cache seja limpo antes de iniciar o navegador IE.\nEsse recurso aceita um valor booleano como parâmetro.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.destructivelyEnsureCleanSession(); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.ensure_clean_session = True driver = webdriver.Ie(options=options) # Navegar para Url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.EnsureCleanSession = true; var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.ensure_clean_session = true driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().ensureCleanSession(true); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.destructivelyEnsureCleanSession() val driver = RemoteWebDriver(options)     ignoreZoomSetting O driver do InternetExplorer espera que o nível de zoom do navegador seja de 100%, caso contrário, o driver lançará uma exceção. Este comportamento padrão pode ser desativado definindo ignoreZoomSetting como true.\nEsse recurso aceita um valor booleano como parâmetro.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.ignoreZoomSettings(); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.ignore_zoom_level = True driver = webdriver.Ie(options=options) # Navegar para Url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.IgnoreZoomLevel = true; var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.ignore_zoom_level = true driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().ignoreZoomSetting(true); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.ignoreZoomSettings() val driver = RemoteWebDriver(options)     ignoreProtectedModeSettings Se deve ignorar a verificação do Modo protegido durante o lançamento uma nova sessão do IE.\nSe não for definido e as configurações do Modo protegido não forem iguais para todas as zonas, uma exceção será lançada pelo driver.\nSe a capacidade for definida como true, os testes podem tornar-se instáveis, não responderem ou os navegadores podem travar. No entanto, esta ainda é de longe a segunda melhor escolha, e a primeira escolha sempre deve ser definir as configurações do Modo protegido de cada zona manualmente. Se um usuário estiver usando esta propriedade, apenas um \u0026ldquo;melhor esforço\u0026rdquo; no suporte será dado.\nEsse recurso aceita um valor booleano como parâmetro.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.introduceFlakinessByIgnoringSecurityDomains(); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.ignore_protected_mode_settings = True driver = webdriver.Ie(options=options) # Navegar para Url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.IntroduceInstabilityByIgnoringProtectedModeSettings = true; var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.ignore_protected_mode_settings = true driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().introduceFlakinessByIgnoringProtectedModeSettings(true); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.introduceFlakinessByIgnoringSecurityDomains() val driver = RemoteWebDriver(options)     silent Quando definido como true, esse recurso suprime a saída de diagnóstico do IEDriverServer.\nEsse recurso aceita um valor booleano como parâmetro.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.setCapability(\u0026#34;silent\u0026#34;, true); WebDriver driver = new InternetExplorerDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.set_capability(\u0026#34;silent\u0026#34;, True) driver = webdriver.Ie(options=options) # Navegar para Url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   InternetExplorerOptions options = new InternetExplorerOptions(); options.AddAdditionalInternetExplorerOption(\u0026#34;silent\u0026#34;, true); IWebDriver driver = new InternetExplorerDriver(options);   # Por favor inclua um PR para adicionar uma amostra de código   const {Builder,By, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); let caps = Capabilities.ie(); caps.set(\u0026#39;silent\u0026#39;, true); (async function example() { let driver = await new Builder() .forBrowser(\u0026#39;internet explorer\u0026#39;) .withCapabilities(caps) .build(); try { await driver.get(\u0026#39;http://www.google.com/ncr\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.Capabilities import org.openqa.selenium.ie.InternetExplorerDriver import org.openqa.selenium.ie.InternetExplorerOptions fun main() { val options = InternetExplorerOptions() options.setCapability(\u0026#34;silent\u0026#34;, true) val driver = InternetExplorerDriver(options) try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;) val caps = driver.getCapabilities() println(caps) } finally { driver.quit() } }     Opções de linha de comando do IE O Internet Explorer inclui várias opções de linha de comando que permitem solucionar problemas e configurar o navegador.\nOs seguintes pontos descrevem algumas opções de linha de comando com suporte\n  -private: Usado para iniciar o IE no modo de navegação privada. Isso funciona para o IE 8 e versões posteriores.\n  -k: Inicia o Internet Explorer no modo quiosque. O navegador é aberto em uma janela maximizada que não exibe a barra de endereço, os botões de navegação ou a barra de status.\n  -extoff: Inicia o IE no modo sem add-on. Esta opção é usada especificamente para solucionar problemas com complementos do navegador. Funciona no IE 7 e versões posteriores.\n  Nota: forceCreateProcessApi deve ser habilitado para que os argumentos da linha de comando funcionem.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; public class ieTest { public static void main(String[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); options.addCommandSwitches(\u0026#34;-k\u0026#34;); InternetExplorerDriver driver = new InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); Capabilities caps = driver.getCapabilities(); System.out.println(caps); } finally { driver.quit(); } } }   from selenium import webdriver options = webdriver.IeOptions() options.add_argument(\u0026#39;-private\u0026#39;) options.force_create_process_api = True driver = webdriver.Ie(options=options) # Navegar para Url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using System; using OpenQA.Selenium; using OpenQA.Selenium.IE; namespace ieTest { class Program { static void Main(string[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.ForceCreateProcessApi = true; options.BrowserCommandLineArguments = \u0026#34;-k\u0026#34;; IWebDriver driver = new InternetExplorerDriver(options); driver.Url = \u0026#34;https://google.com/ncr\u0026#34;; } } }   require \u0026#39;selenium-webdriver\u0026#39; options = Selenium::WebDriver::IE::Options.new options.force_create_process_api = true options.add_argument(\u0026#39;-k\u0026#39;) driver = Selenium::WebDriver.for(:ie, options: options) begin # Navegar para URL driver.get \u0026#39;https://google.com\u0026#39; puts(driver.capabilities.to_json) ensure driver.quit end   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options(); options.addBrowserCommandSwitches(\u0026#39;-k\u0026#39;); options.addBrowserCommandSwitches(\u0026#39;-private\u0026#39;); options.forceCreateProcessApi(true); driver = await env.builder() .setIeOptions(options) .build();   import org.openqa.selenium.Capabilities import org.openqa.selenium.ie.InternetExplorerDriver import org.openqa.selenium.ie.InternetExplorerOptions fun main() { val options = InternetExplorerOptions() options.useCreateProcessApiToLaunchIe() options.addCommandSwitches(\u0026#34;-k\u0026#34;) val driver = InternetExplorerDriver(options) try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;) val caps = driver.getCapabilities() println(caps) } finally { driver.quit() } }     forceCreateProcessApi Força a inicialização do Internet Explorer usando a API CreateProcess. O valor padrão é falso.\nPara IE 8 e superior, esta opção requer que o valor de registro \u0026ldquo;TabProcGrowth\u0026rdquo; seja definido como 0.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; public class ieTest { public static void main(String[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); InternetExplorerDriver driver = new InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); Capabilities caps = driver.getCapabilities(); System.out.println(caps); } finally { driver.quit(); } } }   from selenium import webdriver options = webdriver.IeOptions() options.force_create_process_api = True driver = webdriver.Ie(options=options) # Navegar para Url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using System; using OpenQA.Selenium; using OpenQA.Selenium.IE; namespace ieTest { class Program { static void Main(string[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.ForceCreateProcessApi = true; IWebDriver driver = new InternetExplorerDriver(options); driver.Url = \u0026#34;https://google.com/ncr\u0026#34;; } } }   require \u0026#39;selenium-webdriver\u0026#39; options = Selenium::WebDriver::IE::Options.new options.force_create_process_api = true driver = Selenium::WebDriver.for(:ie, options: options) begin # Navegar para Url driver.get \u0026#39;https://google.com\u0026#39; puts(driver.capabilities.to_json) ensure driver.quit end   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options(); options.forceCreateProcessApi(true); driver = await env.builder() .setIeOptions(options) .build();   import org.openqa.selenium.Capabilities import org.openqa.selenium.ie.InternetExplorerDriver import org.openqa.selenium.ie.InternetExplorerOptions fun main() { val options = InternetExplorerOptions() options.useCreateProcessApiToLaunchIe() val driver = InternetExplorerDriver(options) try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;) val caps = driver.getCapabilities() println(caps) } finally { driver.quit() } }     "},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/driver_requirements/","title":"Requerimentos do driver","tags":[],"description":"","content":"Por meio do WebDriver, o Selenium oferece suporte a todos os principais navegadores do mercado como Chrom(ium), Firefox, Internet Explorer, Opera e Safari. Sempre que possível, o WebDriver dirige o navegador usando o suporte integrado do navegador para automação, embora nem todos os navegadores tenham suporte oficial para controle remoto.\nO objetivo do WebDriver é emular a interação de um usuário real com o navegador o mais próximo possível. Isso é possível em vários níveis em diferentes navegadores. Para obter mais detalhes sobre as diferentes idiossincrasias do driver, consulte Idiossincrasias do driver.\nMesmo que todos os drivers compartilhem uma única interface voltada para o usuário para controlar o navegador, eles têm maneiras ligeiramente diferentes de configurar sessões do navegador. Uma vez que muitas das implementações de driver são fornecidas por terceiros, elas não estão incluídas na distribuição padrão do Selenium.\nInstanciação do driver, gerenciamento de perfil e várias configurações específicas do navegador são exemplos de parâmetros que têm requisitos diferentes dependendo do navegador. Esta seção explica os requisitos básicos para começar com os diferentes navegadores.\nAdicionando executáveis ao seu path A maioria dos drivers requerem um executável extra para o Selenium se comunicar com o navegador. Você pode especificar manualmente onde o executável reside antes de iniciar o WebDriver, mas isso pode tornar seus testes menos portáveis já que os executáveis precisarão estar no mesmo lugar em todas as máquinas, ou inclua o executável em seu repositório de código de teste.\nAo adicionar uma pasta contendo os binários do WebDriver aos do seu path, o Selenium será capaz de localizar os binários adicionais sem exigir seu código de teste para localizar exatamente o driver.\n Crie um diretório para colocar os executáveis, como C:\\WebDriver\\bin ou /opt/WebDriver/bin Adicione o diretório ao seu PATH:  No Windows - Abra um prompt de comando como administrador e execute o seguinte comando para adicionar permanentemente o diretório ao seu PATH para todos os usuários em sua máquina:    setx /m path \u0026#34;%path%;C:\\WebDriver\\bin\\\u0026#34;  Usuários do Bash no macOS e Linux - Em um terminal:  export PATH=$PATH:/opt/WebDriver/bin \u0026gt;\u0026gt; ~/.profile   Agora você está pronto para testar suas alterações. Feche todos os prompts de comando abertos e abra um novo. Digite o nome de um dos binários na pasta que você criou na etapa anterior, por exemplo:\nchromedriver   Se o seu PATH estiver configurado corretamente, você verá alguma saída relacionada à inicialização do driver:\n  Starting ChromeDriver 2.25.426935 (820a95b0b81d33e42712f9198c215f703412e1a1) on port 9515 Only local connections are allowed. Você pode recuperar o controle do seu prompt de comando pressionando Ctrl+C\nQuick reference    Navegador OS Suportado Mantido por Download Problemas     Chromium/Chrome Windows/macOS/Linux Google Downloads Problemas   Firefox Windows/macOS/Linux Mozilla Downloads Problemas   Edge Windows 10 Microsoft Downloads Problemas   Internet Explorer Windows Selenium Project Downloads Problemas   Safari macOS El Capitan ou mais novo Apple Embutido Problemas   Opera Windows/macOS/Linux Opera Downloads Problemas    Chromium/Chrome Para conduzir o Chrome ou Chromium, você deve fazer o download do chromedriver e colocá-lo em uma pasta que está no PATH do seu sistema.\nNo Linux ou macOS, isso significa modificar a variável de ambiente PATH. Você pode ver quais diretórios, separados por dois pontos, constituem o PATH do seu sistema executando o seguinte comando:\n$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin Para incluir o chromedriver no PATH, se ainda não estiver, certifique-se de incluir o diretório pai do binário chromedriver. A linha a seguir irá definir a variável de ambiente PATH com seu conteúdo atual, mais um caminho adicional adicionado após os dois pontos:\n$ export PATH=\u0026#34;$PATH:/path/to/chromedriver\u0026#34; Quando o chromedriver estiver disponível em seu PATH, você deve ser capaz de executar o executável chromedriver de qualquer diretório.\nPara instanciar uma sessão do Chrome/Chromium, você pode fazer o seguinte:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeDriver; WebDriver driver = new ChromeDriver();   #Simple assignment from selenium.webdriver import Chrome driver = Chrome() #Or use the context manager from selenium.webdriver import Chrome with Chrome() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; IWebDriver driver = new ChromeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :chrome   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.chrome.ChromeDriver val driver: WebDriver = ChromeDriver()     Remember that you have to set the path to the chromedriver executable. This is possible using the following line:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;/path/to/chromedriver\u0026#34;);   Chrome(executable_path=\u0026#39;/path/to/chromedriver\u0026#39;)   new ChromeDriver(\u0026#34;/path/to/chromedriver\u0026#34;);   Selenium::WebDriver::Chrome.driver_path = \u0026#34;/path/to/chromedriver\u0026#34;   chrome.setDefaultService(new chrome.ServiceBuilder(\u0026#39;path/to/chromedriver\u0026#39;).build());   System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;/path/to/chromedriver\u0026#34;)     O chromedriver é implementado como um servidor remoto WebDriver que instrui o navegador sobre o que fazer ao expor o interface de proxy de automação interna.\nFirefox Começando com Selenium 3, a Mozilla assumiu a implementação do Driver do Firefox, com geckodriver. O novo driver para Firefox é chamado geckodriver e funciona com Firefox 48 e mais recentes. Como o Firefox WebDriver está em desenvolvimento, quanto mais nova for a versão do Firefox, melhor será o suporte.\nComo geckodriver é a nova forma padrão de iniciar o Firefox, você pode instanciar o Firefox da mesma forma que o Selenium 2:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.firefox.FirefoxDriver; WebDriver driver = new FirefoxDriver();   #Simple assignment from selenium.webdriver import Firefox driver = Firefox() #Or use the context manager from selenium.webdriver import Firefox with Firefox() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Firefox; IWebDriver driver = new FirefoxDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :firefox   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.Firefox.FirefoxDriver val driver: WebDriver = FirefoxDriver()     Se você preferir não definir a localização do geckodriver usando PATH, defina a localização do binário geckodriver programaticamente:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.gecko.driver\u0026#34;, \u0026#34;/path/to/geckodriver\u0026#34;);   Firefox(executable_path=\u0026#39;/path/to/geckodriver\u0026#39;)   new FirefoxDriver(\u0026#34;/path/to/geckodriver\u0026#34;);   Selenium::WebDriver::Firefox.driver_path = \u0026#34;/path/to/geckodriver\u0026#34;   const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); options.setBinary(\u0026#34;/path/to/geckodriver\u0026#34;);   System.setProperty(\u0026#34;webdriver.gecko.driver\u0026#34;, \u0026#34;/path/to/geckodriver\u0026#34;)     Também é possível definir a propriedade em tempo de execução:\nmvn test -Dwebdriver.gecko.driver=/path/to/geckodriver Atualmente é possível reverter para o driver mais antigo, mais completo do Firefox, instalando o Firefox 47.0.1 ou 45 ESR e especificando o recurso desejado de marionette como false. Versões posteriores do Firefox não são mais compatíveis.\nEdge Edge é o navegador mais recente da Microsoft, incluído no Windows 10 e Server 2016. As atualizações do Edge são agrupadas com as principais atualizações do Windows, então você precisará baixar um binário que corresponda ao número da compilação da sua compilação do Windows atualmente instalada. O site do Edge Developer contém links para todos os binários disponíveis. Bugs na implementação do EdgeDriver podem ser levantados com Microsoft. Se você gostaria de executar testes no Edge, mas não está executando o Windows 10, a Microsoft oferece VMs gratuitas para testadores no site do Edge Developer.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.edge.EdgeDriver; WebDriver driver = new EdgeDriver();   #Simple assignment from selenium.webdriver import Edge driver = Edge() #Or use the context manager from selenium.webdriver import Edge with Edge() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Edge; IWebDriver driver = new EdgeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :edge   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;MicrosoftEdge\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.edge.EdgeDriver val driver: WebDriver = EdgeDriver()     Se o driver Edge não estiver presente em seu PATH, você pode definir o PATH usando a seguinte linha:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.edge.driver\u0026#34;, \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;);   Edge(executable_path=\u0026#39;/path/to/MicrosoftWebDriver.exe\u0026#39;)   new EdgeDriver(\u0026#34;/path/to/MicrosoftWebDriver.exe\u0026#34;);   Selenium::WebDriver::Edge.driver_path = \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const edge = require(\u0026#39;selenium-webdriver/edge\u0026#39;); let service = new edge.ServiceBuilder(\u0026#34;/path/to/msedgedriver.exe\u0026#34;); (async function test() { let driver = await new Builder() .setEdgeService(service) .forBrowser(\u0026#39;MicrosoftEdge\u0026#39;) .build(); })();   System.setProperty(\u0026#34;webdriver.edge.driver\u0026#34;, \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;)     Internet Explorer O Internet Explorer era o navegador padrão da Microsoft até o Windows 10, embora ainda esteja incluído no Windows 10. O driver do Internet Explorer é o único driver que o projeto Selenium visa apoiar os mesmos lançamentos que a Microsoft considera atual. Versões mais antigas podem funcionar, mas não serão suportadas.\nEmbora o projeto Selenium forneça binários tanto para 32 bits quanto para 64 bits, existem algumas limitações com o Internet Explorer 10 e 11 com o driver de 64 bits, mas usando o de 32 bits o driver continua a funcionar bem. Deve-se notar que, como as preferências do Internet Explorer são salvas na conta do usuário conectado, alguma configuração adicional é necessária.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.ie.InternetExplorerDriver; WebDriver driver = new InternetExplorerDriver();   #Simple assignment from selenium.webdriver import Ie driver = Ie() #Or use the context manager from selenium.webdriver import Ie with Ie() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.IE; IWebDriver driver = new InternetExplorerDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;internet explorer\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.ie.InternetExplorerDriver val driver: WebDriver = InternetExplorerDriver()     Se o driver do Internet Explorer não estiver presente em seu PATH, você pode definir o PATH usando a seguinte linha:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.ie.driver\u0026#34;, \u0026#34;C:/path/to/IEDriver.exe\u0026#34;);   Ie(executable_path=\u0026#39;/path/to/IEDriverServer.exe\u0026#39;)   new InternetExplorerDriver(\u0026#34;C:/path/to/IEDriver.exe\u0026#34;);   Selenium::WebDriver::IE.driver_path = \u0026#34;C:/path/to/IEDriver.exe\u0026#34;   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let service = new ie.ServiceBuilder(\u0026#34;/path/to/IEDriverServer.exe\u0026#34;); (async function test() { let driver = await new Builder() .setIeService(service) .forBrowser(\u0026#39;internet explorer\u0026#39;) .build(); })();   System.setProperty(\u0026#34;webdriver.ie.driver\u0026#34;, \u0026#34;C:/path/to/IEDriver.exe\u0026#34;)     A Microsoft também oferece um binário WebDriver para Internet Explorer 11 no Windows 7 e 8.1. Não é atualizado desde 2014 e é baseado em uma versão preliminar da Especificação W3. Jim Evans tem um excelente artigo sobre a implementação da Microsoft.\nOpera As versões atuais do Opera são construídas com base no mecanismo Chromium, e WebDriver agora é compatível com o código fechado Driver Opera Chromium, que pode ser adicionado ao seu PATH ou como um propriedade do sistema.\nInstanciar uma sessão de driver é semelhante a Firefox e Chromium:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.opera.OperaDriver; WebDriver driver = new OperaDriver();   #Simple assignment from selenium.webdriver import Opera driver = Opera() #Or use the context manager from selenium.webdriver import Opera with Opera() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Opera; IWebDriver driver = new OperaDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :opera   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const opera = require(\u0026#39;selenium-webdriver/opera\u0026#39;); (async function test() { let driver = await new Builder() .forBrowser(\u0026#39;opera\u0026#39;) .build(); })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.opera.OperaDriver val driver: WebDriver = OperaDriver()     Safari High Sierra e posterior:\n Execute o seguinte comando do terminal na primeira vez e digite sua senha no prompt para autorizar o WebDriver  safaridriver --enable El Capitan e Sierra:\n Ative o menu Desenvolvedor nas preferências do Safari Marque a opção Permitir automação remota com o menu Desenvolver Execute o seguinte comando do terminal na primeira vez e digite sua senha no prompt para autorizar WebDriver  /usr/bin/safaridriver -p 1337\u0026lt;/ Você pode então iniciar uma sessão de driver usando:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.safari.SafariDriver; WebDriver driver = new SafariDriver();   #Simple assignment from selenium.webdriver import Safari driver = Safari() #Or use the context manager from selenium.webdriver import Safari with Safari() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Safari; IWebDriver driver = new SafariDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :safari   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;safari\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.safari.SafariDriver val driver: WebDriver = SafariDriver()     Aqueles que procuram automatizar o Safari no iOS devem olhar para o Projeto Appium. Enquanto o Safari era anteriormente disponível para Windows, a Apple há muito abandonou o suporte, tornando-o uma má escolha de plataforma de teste.\nNavegadores simulados HtmlUnit HtmlUnit é um \u0026ldquo;navegador sem interface gráfica para programas Java\u0026rdquo;. Ele modela documentos HTML e fornece uma API que permite invocar páginas, preencher formulários, clicar links, etc. Possui suporte a JavaScript e é capaz de trabalhar com bibliotecas AJAX, simulando Chrome, Firefox ou Internet Explorer dependendo da configuração usada. Foi movido para um novo local. A fonte é mantida em svn.\nPhantomJS PhantomJS é um navegador sem cabeçalho baseado em Webkit, embora seja uma versão muito mais antiga do que o usado pelo Google Chrome ou Safari. Embora historicamente seja uma popular escolha, agora seria sábio evitar o PhantomJS. O projeto está sem manutenção desde 5 de agosto de 2017, portanto, embora a web continue a mudar, o PhantomJS não será atualizado. Isso foi depois que o Google anunciou a capacidade de executar o Chrome sem cabeçalho, algo também agora oferecido pelo Firefox da Mozilla.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/introduction/on_test_automation/","title":"Sobre automação de testes","tags":[],"description":"","content":"Primeiro, comece perguntando a si mesmo se você realmente precisa ou não de um navegador. As probabilidades são de que, em algum ponto, se você estiver trabalhando em um aplicativo da web complexo, você precisará abrir um navegador e realmente testá-lo.\nNo entanto, os testes funcionais do usuário final, como os testes Selenium, são caros para executar. Além disso, eles normalmente exigem infraestrutura substancial para ser executado de forma eficaz. É uma boa regra sempre se perguntar se o que você deseja testar pode ser feito usando abordagens de teste mais leves, como testes de unidade ou com uma abordagem de nível inferior.\nDepois de determinar que está no negócio de teste de navegador da web, e você tem seu ambiente Selenium pronto para começar a escrever testes, você geralmente executará alguma combinação de três etapas:\n Configurar os dados Executar um conjunto discreto de ações Avaliar os resultados  Você deve manter essas etapas o mais curtas possível; uma ou duas operações devem ser suficientes na maioria das vezes. A automação do navegador tem a reputação de ser \u0026ldquo;instável\u0026rdquo;, mas, na realidade, é porque os usuários freqüentemente exigem muito dele. Em capítulos posteriores, retornaremos às técnicas que você pode usar para mitigar problemas aparentemente intermitentes nos testes, em particular sobre como superar as condições de corrida entre o navegador e o WebDriver.\nMantendo seus testes curtos e usando o navegador da web apenas quando você não tiver absolutamente nenhuma alternativa, você pode ter muitos testes com instabilidade mínima.\nUma vantagem distinta dos testes do Selenium é sua capacidade inerente de testar todos os componentes do aplicativo, de back-end para front-end, da perspectiva do usuário. Em outras palavras, embora os testes funcionais possam ser caros para executar, eles também abrangem grandes partes críticas para os negócios de uma só vez.\nRequerimentos de teste Como mencionado antes, os testes do Selenium podem ser caros para serem executados. Até que ponto depende do navegador em que você está executando os testes, mas historicamente o comportamento dos navegadores tem variado tanto que muitas vezes foi uma meta declarada testar cruzado contra vários navegadores.\nSelenium permite que você execute as mesmas instruções em vários navegadores em vários sistemas operacionais, mas a enumeração de todos os navegadores possíveis, suas diferentes versões e os muitos sistemas operacionais em que são executados rapidamente se tornará uma tarefa não trivial.\nVamos começar com um exemplo Larry escreveu um site que permite aos usuários solicitarem seus unicórnios personalizados.\nO fluxo de trabalho geral (o que chamaremos de \u0026ldquo;caminho feliz\u0026rdquo;) é algo como isso:\n Criar uma conta Configurar o unicórnio Adicionar ao carrinho de compras Verificar e pagar Dar feedback sobre o unicórnio  Seria tentador escrever um grande roteiro do Selenium para realizar todas essas operações - muitos tentarão. Resista à tentação! Isso resultará em um teste que a) leva muito tempo, b) estará sujeito a alguns problemas comuns em torno de problemas de tempo de renderização de página, e c) se falhar, não lhe dará um método conciso e “superficial” para diagnosticar o que deu errado.\nA estratégia preferida para testar este cenário seria dividi-lo em uma série de testes independentes e rápidos, cada um dos quais tem uma “razão” de existir.\nVamos fingir que você deseja testar a segunda etapa: Configure o unicórnio. Ele executará as seguintes ações:\n Criar uma conta Configurar o unicórnio  Observe que estamos pulando o restante dessas etapas, vamos testar o resto do fluxo de trabalho em outros casos de teste pequenos e discretos depois de terminarmos com este.\nPara começar, você precisa criar uma conta. Aqui você tem algumas escolhas a fazer:\n Deseja usar uma conta existente? Você deseja criar uma nova conta? Existem propriedades especiais de tal usuário que precisam ser levadas em consideração antes do início da configuração?  Independentemente de como você responde a esta pergunta, a solução é torná-la parte da etapa de \u0026ldquo;configurar os dados\u0026rdquo; do teste. Se Larry expôs uma API que permite a você (ou qualquer pessoa) criar e atualizar contas de usuário, certifique-se de usar isso para responder a esta pergunta. Se possível, você deseja iniciar o navegador somente depois de ter um usuário \u0026ldquo;em mãos\u0026rdquo;, cujas credenciais você pode usar para fazer login.\nSe cada teste para cada fluxo de trabalho começar com a criação de uma conta de usuário, muitos segundos serão adicionados à execução de cada teste. Chamar uma API e falar com um banco de dados são operações rápidas, \u0026ldquo;sem cabeçalho\u0026rdquo; que não requerem o processo caro de abrir um navegador, navegar para as páginas certas, clicando e aguardando o envio dos formulários, etc.\nIdealmente, você pode abordar esta fase de configuração em uma linha de código, que será executado antes que qualquer navegador seja iniciado:\nJava Python C# Ruby JavaScript Kotlin // Crie um usuário que tenha permissões somente leitura - eles podem configurar um unicórnio, // mas eles não têm informações de pagamento configuradas, nem têm // privilégios administrativos. No momento em que o usuário é criado, seu endereço // de e-mail e senha são gerados aleatoriamente - você nem precisa // conhecê-los. User user = UserFactory.createCommonUser(); //Este método está definido em algum outro lugar.  // Faça login como este usuário. // O login neste site leva você à sua página pessoal \u0026#34;Minha conta\u0026#34;, e então // o objeto AccountPage é retornado pelo método loginAs, permitindo que você // execute ações da AccountPage. AccountPage accountPage = loginAs(user.getEmail(), user.getPassword());   # Crie um usuário que tenha permissões somente leitura - eles podem configurar um unicórnio, # mas eles não têm informações de pagamento configuradas, nem têm # privilégios administrativos. No momento em que o usuário é criado, seu endereço # de e-mail e senha são gerados aleatoriamente - você nem precisa # conhecê-los. user = user_factory.create_common_user() #This method is defined elsewhere. # Faça login como este usuário. # O login neste site leva você à sua página pessoal \u0026#34;Minha conta\u0026#34;, e então # o objeto AccountPage é retornado pelo método loginAs, permitindo que você # execute ações da AccountPage. account_page = login_as(user.get_email(), user.get_password())   // Crie um usuário que tenha permissões somente leitura - eles podem configurar um unicórnio, // mas eles não têm informações de pagamento configuradas, nem têm // privilégios administrativos. No momento em que o usuário é criado, seu endereço // de e-mail e senha são gerados aleatoriamente - você nem precisa // conhecê-los. User user = UserFactory.CreateCommonUser(); //This method is defined elsewhere.  // Faça login como este usuário. // O login neste site leva você à sua página pessoal \u0026#34;Minha conta\u0026#34;, e então // o objeto AccountPage é retornado pelo método loginAs, permitindo que você // execute ações da AccountPage. AccountPage accountPage = LoginAs(user.Email, user.Password);   # Crie um usuário que tenha permissões somente leitura - eles podem configurar um unicórnio, # mas eles não têm informações de pagamento configuradas, nem têm # privilégios administrativos. No momento em que o usuário é criado, seu endereço # de e-mail e senha são gerados aleatoriamente - você nem precisa # conhecê-los. user = UserFactory.create_common_user #This method is defined elsewhere. # Faça login como este usuário. # O login neste site leva você à sua página pessoal \u0026#34;Minha conta\u0026#34;, e então # o objeto AccountPage é retornado pelo método loginAs, permitindo que você # execute ações da AccountPage. account_page = login_as(user.email, user.password)   // Crie um usuário que tenha permissões somente leitura - eles podem configurar um unicórnio, // mas eles não têm informações de pagamento configuradas, nem têm // privilégios administrativos. No momento em que o usuário é criado, seu endereço // de e-mail e senha são gerados aleatoriamente - você nem precisa // conhecê-los. var user = userFactory.createCommonUser(); //This method is defined elsewhere.  // Faça login como este usuário. // O login neste site leva você à sua página pessoal \u0026#34;Minha conta\u0026#34;, e então // o objeto AccountPage é retornado pelo método loginAs, permitindo que você // execute ações da AccountPage. var accountPage = loginAs(user.email, user.password);   // Crie um usuário que tenha permissões somente leitura - eles podem configurar um unicórnio, // mas eles não têm informações de pagamento configuradas, nem têm // privilégios administrativos. No momento em que o usuário é criado, seu endereço // de e-mail e senha são gerados aleatoriamente - você nem precisa // conhecê-los. val user = UserFactory.createCommonUser() //This method is defined elsewhere.  // Faça login como este usuário. // O login neste site leva você à sua página pessoal \u0026#34;Minha conta\u0026#34;, e então // o objeto AccountPage é retornado pelo método loginAs, permitindo que você // execute ações da AccountPage. val accountPage = loginAs(user.getEmail(), user.getPassword())     Como você pode imaginar, a UserFactory pode ser estendida para fornecer métodos como createAdminUser () e createUserWithPayment (). A questão é que essas duas linhas de código não o distraem do objetivo final deste teste: configurando um unicórnio.\nOs detalhes do modelo de objeto de página será discutido em capítulos posteriores, mas vamos apresentar o conceito aqui:\nSeus testes devem ser compostos de ações, realizadas do ponto de vista do usuário, dentro do contexto das páginas do site. Essas páginas são armazenadas como objetos, que conterão informações específicas sobre como a página da web é composta e como as ações são realizadas - muito pouco disso deve preocupar você como testador.\nQue tipo de unicórnio você quer? Você pode querer rosa, mas não necessariamente. Roxo tem sido bastante popular ultimamente. Ela precisa de óculos escuros? Tatuagens de estrelas? Essas escolhas, embora difíceis, são sua principal preocupação como testador - você precisa garantir que seu centro de atendimento de pedidos envia o unicórnio certo para a pessoa certa, e isso começa com essas escolhas.\nObserve que em nenhum lugar desse parágrafo falamos sobre botões, campos, menus suspensos, botões de opção ou formulários da web. Nem deveriam seus testes! Você deseja escrever seu código como o usuário tentando resolver seu problema. Aqui está uma maneira de fazer isso (continuando do exemplo anterior):\nJava Python C# Ruby JavaScript Kotlin // O Unicórnio é um objeto de nível superior - ele possui atributos, que são definidos aqui. // Isso armazena apenas os valores; não preenche formulários da web nem interage // com o navegador de qualquer forma. Unicorn sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS); // Uma vez que já estamos \u0026#34;na\u0026#34; página da conta, temos que usá-la para chegar ao // lugar real onde você configura os unicórnios. Chamar o método \u0026#34;Add Unicorn\u0026#34; // nos leva lá. AddUnicornPage addUnicornPage = accountPage.addUnicorn(); // Agora que estamos na AddUnicornPage, passaremos o objeto \u0026#34;sparkles\u0026#34; para // o método createUnicorn(). Este método pegará os atributos do Sparkles, // preencher o formulário e clicar em enviar. UnicornConfirmationPage unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles);   # O Unicórnio é um objeto de nível superior - ele possui atributos, que são definidos aqui. # Isso armazena apenas os valores; não preenche formulários da web nem interage # com o navegador de qualquer forma. sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) # Uma vez que já estamos \u0026#34;na\u0026#34; página da conta, temos que usá-la para chegar ao # lugar real onde você configura os unicórnios. Chamar o método \u0026#34;Add Unicorn\u0026#34; # nos leva lá. add_unicorn_page = account_page.add_unicorn() # Agora que estamos na AddUnicornPage, passaremos o objeto \u0026#34;sparkles\u0026#34; para # o método createUnicorn(). Este método pegará os atributos do Sparkles, # preencher o formulário e clicar em enviar. unicorn_confirmation_page = add_unicorn_page.create_unicorn(sparkles)   // O Unicórnio é um objeto de nível superior - ele possui atributos, que são definidos aqui. // Isso armazena apenas os valores; não preenche formulários da web nem interage // com o navegador de qualquer forma. Unicorn sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.Purple, UnicornAccessories.Sunglasses, UnicornAdornments.StarTattoos); // Uma vez que já estamos \u0026#34;na\u0026#34; página da conta, temos que usá-la para chegar ao // lugar real onde você configura os unicórnios. Chamar o método \u0026#34;Add Unicorn\u0026#34; // nos leva lá. AddUnicornPage addUnicornPage = accountPage.AddUnicorn(); // Agora que estamos na AddUnicornPage, passaremos o objeto \u0026#34;sparkles\u0026#34; para // o método createUnicorn(). Este método pegará os atributos do Sparkles, // preencher o formulário e clicar em enviar. UnicornConfirmationPage unicornConfirmationPage = addUnicornPage.CreateUnicorn(sparkles);   # O Unicórnio é um objeto de nível superior - ele possui atributos, que são definidos aqui. # Isso armazena apenas os valores; não preenche formulários da web nem interage # com o navegador de qualquer forma. sparkles = Unicorn.new(\u0026#39;Sparkles\u0026#39;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) # Uma vez que já estamos \u0026#34;na\u0026#34; página da conta, temos que usá-la para chegar ao # lugar real onde você configura os unicórnios. Chamar o método \u0026#34;Add Unicorn\u0026#34; # nos leva lá. add_unicorn_page = account_page.add_unicorn # Agora que estamos na AddUnicornPage, passaremos o objeto \u0026#34;sparkles\u0026#34; para # o método createUnicorn(). Este método pegará os atributos do Sparkles, # preencher o formulário e clicar em enviar. unicorn_confirmation_page = add_unicorn_page.create_unicorn(sparkles)   // O Unicórnio é um objeto de nível superior - ele possui atributos, que são definidos aqui. // Isso armazena apenas os valores; não preenche formulários da web nem interage // com o navegador de qualquer forma. var sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS); // Uma vez que já estamos \u0026#34;na\u0026#34; página da conta, temos que usá-la para chegar ao // lugar real onde você configura os unicórnios. Chamar o método \u0026#34;Add Unicorn\u0026#34; // nos leva lá. var addUnicornPage = accountPage.addUnicorn(); // Agora que estamos na AddUnicornPage, passaremos o objeto \u0026#34;sparkles\u0026#34; para // o método createUnicorn(). Este método pegará os atributos do Sparkles, // preencher o formulário e clicar em enviar. var unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles);   // O Unicórnio é um objeto de nível superior - ele possui atributos, que são definidos aqui. // Isso armazena apenas os valores; não preenche formulários da web nem interage // com o navegador de qualquer forma. val sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) // Uma vez que já estamos \u0026#34;na\u0026#34; página da conta, temos que usá-la para chegar ao // lugar real onde você configura os unicórnios. Chamar o método \u0026#34;Add Unicorn\u0026#34; // nos leva lá. val addUnicornPage = accountPage.addUnicorn() // Agora que estamos na AddUnicornPage, passaremos o objeto \u0026#34;sparkles\u0026#34; para // o método createUnicorn(). Este método pegará os atributos do Sparkles, // preencher o formulário e clicar em enviar. unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles)     Agora que você configurou seu unicórnio, você precisa passar para a etapa 3: certifique-se de que realmente funcionou.\nJava Python C# Ruby JavaScript Kotlin // O método exists() de UnicornConfirmationPage pegará o objeto // Sparkles - uma especificação dos atributos que você deseja ver e compará-los // com os campos na página Assert.assertTrue(\u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;, unicornConfirmationPage.exists(sparkles));   # O método exists() de UnicornConfirmationPage pegará o objeto # Sparkles - uma especificação dos atributos que você deseja ver e compará-los # com os campos na página assert unicorn_confirmation_page.exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;   // O método exists() de UnicornConfirmationPage pegará o objeto // Sparkles - uma especificação dos atributos que você deseja ver e compará-los // com os campos na página Assert.True(unicornConfirmationPage.Exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;);   # O método exists() de UnicornConfirmationPage pegará o objeto # Sparkles - uma especificação dos atributos que você deseja ver e compará-los # com os campos na página expect(unicorn_confirmation_page.exists?(sparkles)).to be, \u0026#39;Sparkles should have been created, with all attributes intact\u0026#39;   // O método exists() de UnicornConfirmationPage pegará o objeto // Sparkles - uma especificação dos atributos que você deseja ver e compará-los // com os campos na página assert(unicornConfirmationPage.exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;);   // O método exists() de UnicornConfirmationPage pegará o objeto // Sparkles - uma especificação dos atributos que você deseja ver e compará-los // com os campos na página assertTrue(\u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;, unicornConfirmationPage.exists(sparkles))     Observe que o testador ainda não fez nada além de falar sobre unicórnios neste código– sem botões, sem localizadores, sem controles do navegador. Este método de modelagem do aplicativo permite que você mantenha esses comandos de nível de teste no lugar e imutáveis, mesmo se Larry decidir na próxima semana que não gosta mais de Ruby-on-Rails e decidir reimplementar todo o site em Haskell com um front-end Fortran.\nSeus objetos de página exigirão alguma pequena manutenção para estar conformidade com o redesenho do site, mas esses testes permanecerão os mesmos. Pegando esse design básico, você desejará continuar seus fluxos de trabalho com o menor número possível de etapas voltadas para o navegador. Seu próximo fluxo de trabalho envolverá adicionar um unicórnio ao carrinho de compras. Provavelmente, você desejará muitas iterações deste teste para ter certeza de que o carrinho está mantendo o estado adequado: Existe mais de um unicórnio no carrinho antes de você começar? Quantos cabem no carrinho de compras? Se você criar mais de um com o mesmo nome e / ou recursos, ele falhará? Manterá apenas o existente ou acrescentará outro?\nCada vez que você passa pelo fluxo de trabalho, você deseja evitar ter que criar uma conta, fazer login como o usuário e configurar o unicórnio. Idealmente, você será capaz de criar uma conta e pré-configurar um unicórnio por meio da API ou banco de dados. Em seguida, tudo que você precisa fazer é fazer login como o usuário, localizar Sparkles, e adicioná-lo ao carrinho.\nAutomatizar ou não automatizar? A automação é sempre vantajosa? Quando se deve decidir automatizar os casos de teste?\nNem sempre é vantajoso automatizar casos de teste. Tem vezes que o teste manual pode ser mais apropriado. Por exemplo, se a interface do aplicativo mudará consideravelmente em um futuro próximo, então qualquer automação pode precisar ser reescrita de qualquer maneira. Além disso, às vezes simplesmente não há tempo suficiente para construir automação de testes. A curto prazo, o teste manual pode ser mais eficaz. Se um aplicativo tem um prazo muito curto, atualmente não há automação de teste disponível, e é imperativo que o teste seja feito dentro nesse período, o teste manual é a melhor solução.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/support_packages/working_with_colours/","title":"Trabalhando com cores","tags":[],"description":"","content":"Ocasionalmente, você desejará validar a cor de algo como parte de seus testes; o problema é que as definições de cores na web não são constantes. Não seria bom se houvesse uma maneira fácil de comparar uma representação HEX de uma cor com uma representação RGB de uma cor, ou uma representação RGBA de uma cor com uma representação HSLA de uma cor?\nNão se preocupe. Existe uma solução: a classe Color!\nEm primeiro lugar, você precisará importar a classe:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.support.Color;   from selenium.webdriver.support.color import Color   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    include Selenium::WebDriver::Support   // This feature is not implemented - Help us by sending a pr to implement this feature    import org.openqa.selenium.support.Color    Agora você pode começar a criar objetos coloridos. Cada objeto de cor precisará ser criado a partir de uma representação de string de sua cor. As representações de cores com suporte são:\nJava Python C# Ruby JavaScript Kotlin private final Color HEX_COLOUR = Color.fromString(\u0026#34;#2F7ED8\u0026#34;); private final Color RGB_COLOUR = Color.fromString(\u0026#34;rgb(255, 255, 255)\u0026#34;); private final Color RGB_COLOUR = Color.fromString(\u0026#34;rgb(40%, 20%, 40%)\u0026#34;); private final Color RGBA_COLOUR = Color.fromString(\u0026#34;rgba(255, 255, 255, 0.5)\u0026#34;); private final Color RGBA_COLOUR = Color.fromString(\u0026#34;rgba(40%, 20%, 40%, 0.5)\u0026#34;); private final Color HSL_COLOUR = Color.fromString(\u0026#34;hsl(100, 0%, 50%)\u0026#34;); private final Color HSLA_COLOUR = Color.fromString(\u0026#34;hsla(100, 0%, 50%, 0.5)\u0026#34;);   HEX_COLOUR = Color.from_string(\u0026#39;#2F7ED8\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(255, 255, 255)\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(40%, 20%, 40%)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(255, 255, 255, 0.5)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(40%, 20%, 40%, 0.5)\u0026#39;) HSL_COLOUR = Color.from_string(\u0026#39;hsl(100, 0%, 50%)\u0026#39;) HSLA_COLOUR = Color.from_string(\u0026#39;hsla(100, 0%, 50%, 0.5)\u0026#39;)   // Não temos ainda um exemplo de C# - Nos ajude envando um PR!    HEX_COLOUR = Color.from_string(\u0026#39;#2F7ED8\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(255, 255, 255)\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(40%, 20%, 40%)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(255, 255, 255, 0.5)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(40%, 20%, 40%, 0.5)\u0026#39;) HSL_COLOUR = Color.from_string(\u0026#39;hsl(100, 0%, 50%)\u0026#39;) HSLA_COLOUR = Color.from_string(\u0026#39;hsla(100, 0%, 50%, 0.5)\u0026#39;)   // Essa funcionalidade não está implementada - Nos ajude enviando um PR implementando essa funcionalidade    private val HEX_COLOUR = Color.fromString(\u0026#34;#2F7ED8\u0026#34;) private val RGB_COLOUR = Color.fromString(\u0026#34;rgb(255, 255, 255)\u0026#34;) private val RGB_COLOUR_PERCENT = Color.fromString(\u0026#34;rgb(40%, 20%, 40%)\u0026#34;) private val RGBA_COLOUR = Color.fromString(\u0026#34;rgba(255, 255, 255, 0.5)\u0026#34;) private val RGBA_COLOUR_PERCENT = Color.fromString(\u0026#34;rgba(40%, 20%, 40%, 0.5)\u0026#34;) private val HSL_COLOUR = Color.fromString(\u0026#34;hsl(100, 0%, 50%)\u0026#34;) private val HSLA_COLOUR = Color.fromString(\u0026#34;hsla(100, 0%, 50%, 0.5)\u0026#34;)     A classe Color também suporta todas as definições de cores básicas especificadas em http://www.w3.org/TR/css3-color/#html4.\nJava Python C# Ruby JavaScript Kotlin private final Color BLACK = Color.fromString(\u0026#34;black\u0026#34;); private final Color CHOCOLATE = Color.fromString(\u0026#34;chocolate\u0026#34;); private final Color HOTPINK = Color.fromString(\u0026#34;hotpink\u0026#34;);   BLACK = Color.from_string(\u0026#39;black\u0026#39;) CHOCOLATE = Color.from_string(\u0026#39;chocolate\u0026#39;) HOTPINK = Color.from_string(\u0026#39;hotpink\u0026#39;)   // Não temos ainda um exemplo de C# - Nos ajude envando um PR!    BLACK = Color.from_string(\u0026#39;black\u0026#39;) CHOCOLATE = Color.from_string(\u0026#39;chocolate\u0026#39;) HOTPINK = Color.from_string(\u0026#39;hotpink\u0026#39;)   // Essa funcionalidade não está implementada - Nos ajude enviando um PR implementando essa funcionalidade    private val BLACK = Color.fromString(\u0026#34;black\u0026#34;) private val CHOCOLATE = Color.fromString(\u0026#34;chocolate\u0026#34;) private val HOTPINK = Color.fromString(\u0026#34;hotpink\u0026#34;)     Às vezes, os navegadores retornam um valor de cor \u0026ldquo;transparent\u0026rdquo; se nenhuma cor foi definida em um elemento. A classe Color também oferece suporte para isso:\nJava Python C# Ruby JavaScript Kotlin private final Color TRANSPARENT = Color.fromString(\u0026#34;transparent\u0026#34;);   TRANSPARENT = Color.from_string(\u0026#39;transparent\u0026#39;)   // Não temos ainda um exemplo de C# - Nos ajude envando um PR!    TRANSPARENT = Color.from_string(\u0026#39;transparent\u0026#39;)   // Essa funcionalidade não está implementada - Nos ajude enviando um PR implementando essa funcionalidade    private val TRANSPARENT = Color.fromString(\u0026#34;transparent\u0026#34;)     Agora você pode consultar com segurança um elemento para obter sua cor / cor de fundo sabendo que qualquer resposta será analisada corretamente e convertido em um objeto Color válido:\nJava Python C# Ruby JavaScript Kotlin Color loginButtonColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;)); Color loginButtonBackgroundColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;background-color\u0026#34;));   login_button_colour = Color.from_string(driver.find_element(By.ID,\u0026#39;login\u0026#39;).value_of_css_property(\u0026#39;color\u0026#39;)) login_button_background_colour = Color.from_string(driver.find_element(By.ID,\u0026#39;login\u0026#39;).value_of_css_property(\u0026#39;background-color\u0026#39;))   // Não temos ainda um exemplo de C# - Nos ajude envando um PR!    login_button_colour = Color.from_string(driver.find_element(id: \u0026#39;login\u0026#39;).css_value(\u0026#39;color\u0026#39;)) login_button_background_colour = Color.from_string(driver.find_element(id: \u0026#39;login\u0026#39;).css_value(\u0026#39;background-color\u0026#39;))   // Essa funcionalidade não está implementada - Nos ajude enviando um PR implementando essa funcionalidade    val loginButtonColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;)) val loginButtonBackgroundColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;background-color\u0026#34;))     Você pode então comparar diretamente os objetos coloridos:\nJava Python C# Ruby JavaScript Kotlin assert loginButtonBackgroundColour.equals(HOTPINK);   assert login_button_background_colour == HOTPINK   // Não temos ainda um exemplo de C# - Nos ajude envando um PR!    assert(login_button_background_colour == HOTPINK)   // Essa funcionalidade não está implementada - Nos ajude enviando um PR implementando essa funcionalidade    assert(loginButtonBackgroundColour.equals(HOTPINK))     Ou você pode converter a cor em um dos seguintes formatos e realizar uma validação estática:\nJava Python C# Ruby JavaScript Kotlin assert loginButtonBackgroundColour.asHex().equals(\u0026#34;#ff69b4\u0026#34;); assert loginButtonBackgroundColour.asRgba().equals(\u0026#34;rgba(255, 105, 180, 1)\u0026#34;); assert loginButtonBackgroundColour.asRgb().equals(\u0026#34;rgb(255, 105, 180)\u0026#34;);   assert login_button_background_colour.hex == \u0026#39;#ff69b4\u0026#39; assert login_button_background_colour.rgba == \u0026#39;rgba(255, 105, 180, 1)\u0026#39; assert login_button_background_colour.rgb == \u0026#39;rgb(255, 105, 180)\u0026#39;   // Não temos ainda um exemplo de C# - Nos ajude envando um PR!    assert(login_button_background_colour.hex == \u0026#39;#ff69b4\u0026#39;) assert(login_button_background_colour.rgba == \u0026#39;rgba(255, 105, 180, 1)\u0026#39;) assert(login_button_background_colour.rgb == \u0026#39;rgb(255, 105, 180)\u0026#39;)   // Essa funcionalidade não está implementada - Nos ajude enviando um PR implementando essa funcionalidade    assert(loginButtonBackgroundColour.asHex().equals(\u0026#34;#ff69b4\u0026#34;)) assert(loginButtonBackgroundColour.asRgba().equals(\u0026#34;rgba(255, 105, 180, 1)\u0026#34;)) assert(loginButtonBackgroundColour.asRgb().equals(\u0026#34;rgb(255, 105, 180)\u0026#34;))     As cores não são mais um problema.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/worst_practices/http_response_codes/","title":"Códigos de respostas HTTP","tags":[],"description":"","content":"Para algumas configurações de navegador no Selenium RC, Selenium atuou como um proxy entre o navegador e o site sendo automatizado. Isso significa que todo o tráfego do navegador que passou pelo Selenium poderia ser capturado ou manipulado. O método captureNetworkTraffic() pretendia capturar todo o tráfego de rede entre o navegador e o site sendo automatizado, incluindo códigos de resposta HTTP.\nSelenium WebDriver é uma abordagem completamente diferente para a automação do navegador, preferindo agir mais como um usuário. Isso é representado na maneira como você escreve testes com o WebDriver. Em testes funcionais automatizados, verificar o código de status não é um detalhe particularmente importante da falha de um teste; as etapas que o precederam são mais importantes.\nO navegador sempre representará o código de status HTTP, imagine, por exemplo, uma página de erro 404 ou 500. Uma maneira simples de “falhar rapidamente” quando você encontrar uma dessas páginas de erro é verificar o título da página ou o conteúdo de um ponto confiável (por exemplo, a tag \u0026lt;h1\u0026gt;) após cada carregamento de página. Se você estiver usando o modelo de objeto de página, você pode incluir esta verificação em seu construtor de classe ou ponto semelhante onde o carregamento da página é esperado. Ocasionalmente, o código HTTP pode até ser representado na página de erro do navegador e você pode usar o WebDriver para ler isso e melhorar sua saída de depuração.\nVerificar se a própria página da web está alinhada com a prática ideal do WebDriver de representar a visão do usuário do site.\nSe você insiste, uma solução avançada para capturar códigos de status HTTP é replicar o comportamento do Selenium RC usando um proxy. A API WebDriver fornece a capacidade de definir um proxy para o navegador, e há uma série de proxies que irão permitir que você manipule de forma programática o conteúdo das solicitações enviadas e recebidas do servidor da web. Usar um proxy permite que você decida como deseja responder para códigos de resposta de redirecionamento. Além disso, nem todo navegador torna os códigos de resposta disponíveis para WebDriver, então optar por usar um proxy permite que você tenha uma solução que funciona para todos os navegadores.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/generating_application_state/","title":"Gerando estado da aplicação","tags":[],"description":"","content":"Selenium não deve ser usado para preparar um caso de teste. Tudo as ações repetitivas e preparações para um caso de teste devem ser feitas por meio de outros métodos. Por exemplo, a maioria das IUs da web tem autenticação (por exemplo, um formulário de login). Eliminar o login via navegador da web antes de cada teste irá melhorar a velocidade e estabilidade do teste. Um método deve ser criado para obter acesso à AUT* (por exemplo, usando uma API para fazer login e definir um cookie). Além disso, a criação de métodos para pré-carregar dados para o teste não deve ser feito usando Selenium. Como dito anteriormente, APIs existentes devem ser aproveitadas para criar dados para a AUT *.\n*AUT: Application under test\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/grid_3/","title":"Grid 3","tags":[],"description":"","content":"Grid 3 Selenium Grid é um servidor proxy inteligente que permite que os testes Selenium encaminhem comandos para instâncias remotas do navegador da web. Seu objetivo é fornecer uma maneira fácil de executar testes em paralelo em várias máquinas.\nCom Selenium Grid, um servidor atua como o hub que roteia comandos de teste formatados em JSON para um ou mais nós registrados. Os testes entram em contato com o hub para obter acesso a instâncias remotas do navegador. O hub tem uma lista de servidores registrados aos quais fornece acesso, e permite o controle dessas instâncias.\nSelenium Grid nos permite executar testes em paralelo em várias máquinas, e gerenciar diferentes versões e configurações do navegador centralmente (em vez de em cada teste individual).\nSelenium Grid não é uma bala de prata. Ele resolve um subconjunto de problemas comuns de delegação e distribuição, mas não irá, por exemplo, gerenciar sua infraestrutura, e pode não atender às suas necessidades específicas.\n** Observe que a Grid 3 não é mais compatível e o projeto Selenium recomenda usar [Grid 4] (/pt-br/grid/grid_4/)**\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/legacy_docs/html-runner/","title":"HTML runner","tags":[],"description":"","content":"Selenium HTML-runner permite que você execute suítes de teste da linha de comando. Suítes de teste são exportações de HTML do Selenium IDE ou ferramentas compatíveis.\nInformação comum  Combinação de lançamentos de geckodriver / firefox / selenium-html-runner são importantes. Pode haver um software matriz de compatibilidade em algum lugar. selenium-html-runner executa apenas suítes de teste (não casos de teste - por exemplo, uma exportação do Monitis Transaction Monitor). Certifique-se de cumprir isso. Para usuários Linux sem DISPLAY - você precisa iniciar o html-runner com display virtual (procure por xvfb)  Exemplo de ambiente Linux Instale / baixe os seguintes pacotes:\n[user@localhost ~]$ cat /etc/redhat-release CentOS Linux release 7.4.1708 (Core) [user@localhost ~]$ rpm -qa | egrep -i \u0026#34;xvfb|java-1.8|firefox\u0026#34; xorg-x11-server-Xvfb-1.19.3-11.el7.x86_64 firefox-52.4.0-1.el7.centos.x86_64 java-1.8.0-openjdk-1.8.0.151-1.b12.el7_4.x86_64 java-1.8.0-openjdk-headless-1.8.0.151-1.b12.el7_4.x86_64 Exemplo de suíte de testes:\n[user@localhost ~]$ cat testsuite.html \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD XHTML 1.0 Strict//EN\u0026#34; \u0026#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\u0026#34;\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34; xml:lang=\u0026#34;en\u0026#34; lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta content=\u0026#34;text/html; charset=UTF-8\u0026#34; http-equiv=\u0026#34;content-type\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Test Suite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table id=\u0026#34;suiteTable\u0026#34; cellpadding=\u0026#34;1\u0026#34; cellspacing=\u0026#34;1\u0026#34; border=\u0026#34;1\u0026#34; class=\u0026#34;selenium\u0026#34;\u0026gt;\u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;b\u0026gt;Test Suite\u0026lt;/b\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;YOUR-TEST-SCENARIO.html\u0026#34;\u0026gt;YOUR-TEST-SCENARIO\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Como rodar o selenium-html-runner headless Agora, a parte mais importante, um exemplo de como executar o selenium-html-runner! Sua experiência pode variar dependendo das combinações de software - versões geckodriver / FF / html-runner.\nxvfb-run java -Dwebdriver.gecko.driver=/home/mmasek/geckodriver.0.18.0 -jar selenium-html-runner-3.7.1.jar -htmlSuite \u0026#34;firefox\u0026#34; \u0026#34;https://YOUR-BASE-URL\u0026#34; \u0026#34;$(pwd)/testsuite.html\u0026#34; \u0026#34;results.html\u0026#34; ; grep result: -A1 results.html/firefox.results.html [user@localhost ~]$ xvfb-run java -Dwebdriver.gecko.driver=/home/mmasek/geckodriver.0.18.0 -jar selenium-html-runner-3.7.1.jar -htmlSuite \u0026#34;*firefox\u0026#34; \u0026#34;https://YOUR-BASE-URL\u0026#34; \u0026#34;$(pwd)/testsuite.html\u0026#34; \u0026#34;results.html\u0026#34; ; grep result: -A1 results.html/firefox.results.html Multi-window mode is longer used as an option and will be ignored. 1510061109691 geckodriver INFO geckodriver 0.18.0 1510061109708 geckodriver INFO Listening on 127.0.0.1:2885 1510061110162 geckodriver::marionette INFO Starting browser /usr/bin/firefox with args [\u0026#34;-marionette\u0026#34;] 1510061111084 Marionette INFO Listening on port 43229 1510061111187 Marionette WARN TLS certificate errors will be ignored for this session Nov 07, 2017 1:25:12 PM org.openqa.selenium.remote.ProtocolHandshake createSession INFO: Detected dialect: W3C 2017-11-07 13:25:12.714:INFO::main: Logging initialized @3915ms to org.seleniumhq.jetty9.util.log.StdErrLog 2017-11-07 13:25:12.804:INFO:osjs.Server:main: jetty-9.4.z-SNAPSHOT 2017-11-07 13:25:12.822:INFO:osjsh.ContextHandler:main: Started o.s.j.s.h.ContextHandler@87a85e1{/tests,null,AVAILABLE} 2017-11-07 13:25:12.843:INFO:osjs.AbstractConnector:main: Started ServerConnector@52102734{HTTP/1.1,[http/1.1]}{0.0.0.0:31892} 2017-11-07 13:25:12.843:INFO:osjs.Server:main: Started @4045ms Nov 07, 2017 1:25:13 PM org.openqa.selenium.server.htmlrunner.CoreTestCase run INFO: |open | /auth_mellon.php | | Nov 07, 2017 1:25:14 PM org.openqa.selenium.server.htmlrunner.CoreTestCase run INFO: |waitForPageToLoad | 3000 | | . . .etc \u0026lt;td\u0026gt;result:\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;PASS\u0026lt;/td\u0026gt; "},{"uri":"https://www.selenium.dev/documentation/pt-br/selenium_installation/installing_standalone_server/","title":"Instalando o servidor Standalone","tags":[],"description":"","content":"Se você planeja usar Grid, você deve baixar o arquivo selenium-server-standalone JAR. Todos os componentes estão disponíveis via selenium-server. O JAR Standalone contém tudo, incluindo o servidor Selenium remoto e as ligações do lado do cliente. Isso significa que se você usar o jar selenium-server-standalone em seu projeto, você não precisa adicionar selenium-java ou um jar específico do navegador.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-server\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; "},{"uri":"https://www.selenium.dev/documentation/pt-br/selenium_installation/","title":"Instalação do Selenium","tags":[],"description":"","content":"Instalação do Selenium A configuração do Selenium é bastante diferente da configuração de outras ferramentas comerciais. Para usar Selenium em seu projeto de automação, você precisa instalar as bibliotecas de linguagem para sua linguagem de escolha. Além disso, você precisará dos binários WebDriver para os navegadores que você deseja automatizar e executar testes.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/locating_elements/","title":"Localizando elementos","tags":[],"description":"","content":"Localizando elementos Uma das técnicas mais fundamentais para aprender ao usar o WebDriver é como encontrar elementos na página. WebDriver oferece uma série de tipos de seletores embutidos, entre eles encontrar um elemento por seu atributo de ID:\nJava Python C# Ruby JavaScript Kotlin WebElement cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;));   driver.find_element(By.ID, \u0026#34;cheese\u0026#34;)   IWebElement element = driver.FindElement(By.Id(\u0026#34;cheese\u0026#34;));   cheese = driver.find_element(id: \u0026#39;cheese\u0026#39;)   const cheese = driver.findElement(By.id(\u0026#39;cheese\u0026#39;));   val cheese: WebElement = driver.findElement(By.id(\u0026#34;cheese\u0026#34;))     Como visto no exemplo, a localização de elementos no WebDriver é feita no objeto da instância WebDriver. O método findElement(By) retorna outro tipo de objeto fundamental, o WebElement.\n WebDriver representa o navegador WebElement representa um nó DOM específico (um controle, por exemplo, um link ou input, etc.)  Depois de ter uma referência a um elemento da web que foi \u0026ldquo;encontrado\u0026rdquo;, você pode restringir o escopo de sua pesquisa usando a mesma chamada nessa instância do objeto:\nJava Python C# Ruby JavaScript Kotlin WebElement cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;)); WebElement cheddar = cheese.findElement(By.id(\u0026#34;cheddar\u0026#34;));   cheese = driver.find_element(By.ID, \u0026#34;cheese\u0026#34;) cheddar = cheese.find_elements_by_id(\u0026#34;cheddar\u0026#34;)   IWebElement cheese = driver.FindElement(By.Id(\u0026#34;cheese\u0026#34;)); IWebElement cheddar = cheese.FindElement(By.Id(\u0026#34;cheddar\u0026#34;));   cheese = driver.find_element(id: \u0026#39;cheese\u0026#39;) cheddar = cheese.find_element(id: \u0026#39;cheddar\u0026#39;)   const cheese = driver.findElement(By.id(\u0026#39;cheese\u0026#39;)); const cheddar = cheese.findElement(By.id(\u0026#39;cheddar\u0026#39;));   val cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;)) val cheddar = cheese.findElement(By.id(\u0026#34;cheddar\u0026#34;))     Você pode fazer isso porque ambos os tipos WebDriver e WebElement implementam a interface SearchContext. No WebDriver, isso é conhecido como interface baseada em função. As interfaces baseadas em funções permitem que você determine se uma implementação do driver suporta um determinado recurso. Essas interfaces são claramente definidas e tentam aderir a ter apenas uma única função de responsabilidade. Você pode ler mais sobre o design do WebDriver e quais funções são suportadas em quais drivers em Alguma outra seção que deve ser nomeada.\nConsequentemente, a interface By usada acima também suporta um número de estratégias de localização adicionais. Uma pesquisa aninhada pode não ser a estratégia de localização de cheese mais eficaz, pois requer dois comandos separados a serem emitidos para o navegador; primeiro pesquisando o DOM para um elemento com o ID \u0026ldquo;cheese\u0026rdquo;, em seguida, uma pesquisa por \u0026ldquo;cheddar\u0026rdquo; em um contexto restrito.\nPara melhorar um pouco o desempenho, devemos tentar usar um localizador mais específico: WebDriver suporta a procura de elementos por localizadores CSS, o que nos permite combinar os dois localizadores anteriores em uma única pesquisa:\nJava Python C# Ruby JavaScript Kotlin driver.findElement(By.cssSelector(\u0026#34;#cheese #cheddar\u0026#34;));   cheddar = driver.find_element_by_css_selector(\u0026#34;#cheese #cheddar\u0026#34;)   driver.FindElement(By.CssSelector(\u0026#34;#cheese #cheddar\u0026#34;));   driver.find_element(css: \u0026#39;#cheese #cheddar\u0026#39;)   const cheddar = driver.findElement(By.css(\u0026#39;#cheese #cheddar\u0026#39;));   driver.findElement(By.cssSelector(\u0026#34;#cheese #cheddar\u0026#34;))     Localizando mútliplos elementos É possível que o documento com o qual estamos trabalhando tenha uma lista ordenada dos queijos que mais gostamos:\n\u0026lt;ol id=cheese\u0026gt; \u0026lt;li id=cheddar\u0026gt;… \u0026lt;li id=brie\u0026gt;… \u0026lt;li id=rochefort\u0026gt;… \u0026lt;li id=camembert\u0026gt;… \u0026lt;/ol\u0026gt; Uma vez que mais queijo é indiscutivelmente melhor, e seria complicado ter que recuperar cada um dos itens individualmente, uma técnica melhor para buscar cheese é fazer uso da versão pluralizada findElements(By). Este método retorna uma coleção de elementos web. Se apenas um elemento for encontrado, ele ainda retornará uma coleção (de um elemento). Se nenhum elemento corresponder ao localizador, um lista vazia será retornada.\nJava Python C# Ruby JavaScript Kotlin List\u0026lt;WebElement\u0026gt; muchoCheese = driver.findElements(By.cssSelector(\u0026#34;#cheese li\u0026#34;));   mucho_cheese = driver.find_elements_by_css_selector(\u0026#34;#cheese li\u0026#34;)   IReadOnlyList\u0026lt;IWebElement\u0026gt; muchoCheese = driver.FindElements(By.CssSelector(\u0026#34;#cheese li\u0026#34;));   mucho_cheese = driver.find_elements(css: \u0026#39;#cheese li\u0026#39;)   const muchoCheese = driver.findElements(By.css(\u0026#39;#cheese li\u0026#39;));   val muchoCheese: List\u0026lt;WebElement\u0026gt; = driver.findElements(By.cssSelector(\u0026#34;#cheese li\u0026#34;))     Estratégias de seleção de elemento Existem oito estratégias diferentes de localização de elementos embutidas no WebDriver:\n   Localizador Descrição     class name Localiza elementos cujo nome de classe contém o valor de pesquisa (nomes de classes compostas não são permitidos)   css selector Localiza elementos que correspondem a um seletor CSS   id Localiza elementos cujo atributo de ID corresponde ao valor de pesquisa   name Localiza elementos cujo atributo NAME corresponde ao valor de pesquisa   link text Localiza elementos âncora cujo texto visível corresponde ao valor de pesquisa   partial link text Localiza elementos âncora cujo texto visível contém o valor da pesquisa. Se vários elementos forem correspondentes, apenas o primeiro será selecionado.   tag name Localiza elementos cujo nome de tag corresponde ao valor de pesquisa   xpath Localiza elementos que correspondem a uma expressão XPath    Dicas sobre como usar seletores No geral, se os IDs de HTML estiverem disponíveis, únicos e consistentemente previsíveis, eles são o método preferido para localizar um elemento uma página. Eles tendem a trabalhar muito rapidamente e dispensar muito processamento que vem com travessias de DOM complicadas.\nSe IDs exclusivos não estiverem disponíveis, um seletor CSS bem escrito é o método preferido de localização de um elemento. XPath funciona bem como CSS seletores, mas a sintaxe é complicada e frequentemente difícil de depurar. Embora os seletores XPath sejam muito flexíveis, eles não são tipicamente testados em performance por fornecedores de navegadores e tendem a ser bastante lentos.\nAs estratégias de seleção baseadas em linkText e partialLinkText têm desvantagens porque eles só funcionam em elementos de link. Além disso, eles chamam seletores XPath internamente no WebDriver.\nO nome da tag pode ser uma maneira perigosa de localizar elementos. tem frequentemente, vários elementos da mesma tag presentes na página. Isso é útil principalmente ao chamar o método _findElements(By) _ que retorna uma coleção de elementos.\nA recomendação é manter seus localizadores compactos e legíveis quanto possível. Pedir ao WebDriver para percorrer a estrutura DOM é uma operação cara, e quanto mais você pode restringir o escopo de sua pesquisa, melhor.\nLocalizadores relativos Selenium 4 traz localizadores relativos que eram anteriormente chamado de Localizadores Amigáveis. Esta funcionalidade foi adicionada para ajudá-lo a localizar elementos que estão próximos a outros elementos. Os localizadores relativos disponíveis são:\n above below toLeftOf toRightOf near  O método findElement agora aceita um novo método withTagName() que retorna um RelativeLocator.\nNOTE: Java bindings now support with(By) instead of withTagName() allowing users to pick locator of their choice like By.id, By.cssSelector etc. This feature landed in Selenium4 - beta3\nComo funciona Selenium usa a função JavaScript getBoundingClientRect() para encontrar os elementos relativos. Esta função retorna propriedades de um elemento, como right, left, bottom, and top.\nVamos considerar o exemplo abaixo para entender os localizadores relativos.\nabove() Retorna o WebElement, que aparece acima do elemento especificado\nJava Python C# Ruby JavaScript Kotlin import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement passwordField = driver.findElement(By.id(\u0026#34;password\u0026#34;)); WebElement emailAddressField = driver.findElement(with(By.tagName(\u0026#34;input\u0026#34;)) .above(passwordField));   from selenium.webdriver.support.relative_locator import with_tag_name passwordField = driver.find_element(By.ID, \u0026#34;password\u0026#34;) emailAddressField = driver.find_element(with_tag_name(\u0026#34;input\u0026#34;).above(passwordField))   using static OpenQA.Selenium.RelativeBy; IWebElement passwordField = driver.FindElement(By.Id(\u0026#34;password\u0026#34;)); IWebElement emailAddressField = driver.FindElement(WithTagName(\u0026#34;input\u0026#34;) .Above(passwordField));   password_field = driver.find_element(:id, \u0026#34;password\u0026#34;) email_address_field = driver.find_element(relative: {tag_name: \u0026#39;input\u0026#39;, above:password_field})   let passwordField = driver.findElement(By.id(\u0026#39;password\u0026#39;)); let emailAddressField = await driver.findElement(withTagName(\u0026#39;input\u0026#39;).above(passwordField));   val passwordField = driver.findElement(By.id(\u0026#34;password\u0026#34;)) val emailAddressField = driver.findElement(with(By.tagName(\u0026#34;input\u0026#34;)).above(passwordField))     below() Retorna o WebElement, que aparece abaixo do elemento especificado\nJava Python C# Ruby JavaScript Kotlin import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement emailAddressField = driver.findElement(By.id(\u0026#34;email\u0026#34;)); WebElement passwordField = driver.findElement(with(By.tagName(\u0026#34;input\u0026#34;)) .below(emailAddressField));   from selenium.webdriver.support.relative_locator import with_tag_name emailAddressField = driver.find_element(By.ID, \u0026#34;email\u0026#34;) passwordField = driver.find_element(with_tag_name(\u0026#34;input\u0026#34;).below(emailAddressField))   using static OpenQA.Selenium.RelativeBy; IWebElement emailAddressField = driver.FindElement(By.Id(\u0026#34;email\u0026#34;)); IWebElement passwordField = driver.FindElement(WithTagName(\u0026#34;input\u0026#34;) .Below(emailAddressField));   email_address_field = driver.find_element(:id, \u0026#34;email\u0026#34;) password_field = driver.find_element(relative: {tag_name: \u0026#39;input\u0026#39;, below: email_address_field})   let emailAddressField = driver.findElement(By.id(\u0026#39;email\u0026#39;)); let passwordField = await driver.findElement(withTagName(\u0026#39;input\u0026#39;).below(emailAddressField));   val emailAddressField = driver.findElement(By.id(\u0026#34;email\u0026#34;)) val passwordField = driver.findElement(with(By.tagName(\u0026#34;input\u0026#34;)).below(emailAddressField))     toLeftOf() Retorna o WebElement, que aparece à esquerda do elemento especificado\nJava Python C# Ruby JavaScript Kotlin import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement submitButton = driver.findElement(By.id(\u0026#34;submit\u0026#34;)); WebElement cancelButton = driver.findElement(with(By.tagName(\u0026#34;button\u0026#34;)) .toLeftOf(submitButton));   from selenium.webdriver.support.relative_locator import with_tag_name submitButton = driver.find_element(By.ID, \u0026#34;submit\u0026#34;) cancelButton = driver.find_element(with_tag_name(\u0026#34;button\u0026#34;). to_left_of(submitButton))   using static OpenQA.Selenium.RelativeBy; IWebElement submitButton = driver.FindElement(By.Id(\u0026#34;submit\u0026#34;)); IWebElement cancelButton = driver.FindElement(WithTagName(\u0026#34;button\u0026#34;) .LeftOf(submitButton));   submit_button = driver.find_element(:id, \u0026#34;submit\u0026#34;) cancel_button = driver.find_element(relative: {tag_name: \u0026#39;button\u0026#39;, left:submit_button})   let submitButton = driver.findElement(By.id(\u0026#34;submit\u0026#34;)); let cancelButton = await driver.findElement(withTagName(\u0026#34;button\u0026#34;).toLeftOf(submitButton));   val submitButton = driver.findElement(By.id(\u0026#34;submit\u0026#34;)) val cancelButton = driver.findElement(with(By.tagName(\u0026#34;button\u0026#34;)).toLeftOf(submitButton))     toRightOf() Retorna o WebElement, que aparece à direita do elemento especificado\nJava Python C# Ruby JavaScript Kotlin import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement cancelButton = driver.findElement(By.id(\u0026#34;cancel\u0026#34;)); WebElement submitButton = driver.findElement(with(By.tagName(\u0026#34;button\u0026#34;)) .toRightOf(cancelButton));   from selenium.webdriver.support.relative_locator import with_tag_name cancelButton = driver.find_element(By.ID, \u0026#34;cancel\u0026#34;) submitButton = driver.find_element(with_tag_name(\u0026#34;button\u0026#34;). to_right_of(cancelButton))   using static OpenQA.Selenium.RelativeBy; IWebElement cancelButton = driver.FindElement(By.Id(\u0026#34;cancel\u0026#34;)); IWebElement submitButton = driver.FindElement(WithTagName(\u0026#34;button\u0026#34;) .RightOf(cancelButton));   cancel_button = driver.find_element(:id, \u0026#34;cancel\u0026#34;) submit_button = driver.find_element(relative: {tag_name: \u0026#39;button\u0026#39;, right:cancel_button})   let cancelButton = driver.findElement(By.id(\u0026#39;cancel\u0026#39;)); let submitButton = await driver.findElement(withTagName(\u0026#39;button\u0026#39;).toRightOf(cancelButton));   val cancelButton = driver.findElement(By.id(\u0026#34;cancel\u0026#34;)) val submitButton = driver.findElement(with(By.tagName(\u0026#34;button\u0026#34;)).toRightOf(cancelButton))     near() Retorna o WebElement, que está no máximo a 50px de distância do elemento especificado.\nJava Python C# Ruby JavaScript Kotlin import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement emailAddressLabel = driver.findElement(By.id(\u0026#34;lbl-email\u0026#34;)); WebElement emailAddressField = driver.findElement(with(By.tagName(\u0026#34;input\u0026#34;)) .near(emailAddressLabel));   from selenium.webdriver.support.relative_locator import with_tag_name emailAddressLabel = driver.find_element(By.ID, \u0026#34;lbl-email\u0026#34;) emailAddressField = driver.find_element(with_tag_name(\u0026#34;input\u0026#34;). near(emailAddressLabel))   using static OpenQA.Selenium.RelativeBy; IWebElement emailAddressLabel = driver.FindElement(By.Id(\u0026#34;lbl-email\u0026#34;)); IWebElement emailAddressField = driver.FindElement(WithTagName(\u0026#34;input\u0026#34;) .Near(emailAddressLabel));   email_address_label = driver.find_element(:id, \u0026#34;lbl-email\u0026#34;) email_address_field = driver.find_element(relative: {tag_name: \u0026#39;input\u0026#39;, near: email_address_label})   let emailAddressLabel = driver.findElement(By.id(\u0026#34;lbl-email\u0026#34;)); let emailAddressField = await driver.findElement(withTagName(\u0026#34;input\u0026#34;).near(emailAddressLabel));   val emailAddressLabel = driver.findElement(By.id(\u0026#34;lbl-email\u0026#34;)) val emailAddressField = driver.findElement(with(By.tagName(\u0026#34;input\u0026#34;)).near(emailAddressLabel))     "},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/browser_manipulation/","title":"Manipulação do Browser","tags":[],"description":"","content":"Ruby Ruby não está instalado por padrão no Windows. Baixe a versão mais recente e execute o instalador. Você podedeixar todas as configurações com os valores padrão, exceto na tela Installation Destination and Optional Tasks verifique onde você precisa marca a caixa de seleção Add Ruby executables to your PATH. Para utilizar qualquer navegador, você deve instalar a gem de Ruby selenium-webdriver. Para instalá-lo, abra o prompt de comando e digite isto:\ngem install selenium-webdriver Ou, se você usa Bundler, adicione esta linha ao Gemfile:\ngem \u0026#34;selenium-webdriver\u0026#34; Em seguida, execute o seguinte comando no prompt de comando:\nbundle install Internet Explorer O Internet Explorer é instalado por padrão no Windows, portanto nenhuma instalação é necessária. Para utilizar o Internet Explorer no Windows, você deve baixar o driver mais recente do Internet Explorer e colocar o arquivo em uma pasta que está no PATH. Para descobrir quais diretórios estão no PATH, digite echo% PATH% no prompt de comando.\n$ echo %PATH% C:\\Ruby200\\bin;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem C:\\Ruby200\\bin parece um bom lugar. Descompacte o arquivo IEDriverServer e mova IEDriverServer.exe para lá.\nIsso deve abrir uma nova janela do Internet Explorer:\nrequire \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer Navegação Navegar para A primeira coisa que você vai querer fazer depois de iniciar um navegador é abrir o seu site. Isso pode ser feito em uma única linha:\nJava Python C# Ruby JavaScript Kotlin //Convenient driver.get(\u0026#34;https://selenium.dev\u0026#34;); //Longer way driver.navigate().to(\u0026#34;https://selenium.dev\u0026#34;);   driver.get(\u0026#34;https://selenium.dev\u0026#34;)   driver.Navigate().GoToUrl(@\u0026#34;https://selenium.dev\u0026#34;);   # Convenient way driver.get \u0026#39;https://selenium.dev\u0026#39; # Longer Way driver.navigate.to \u0026#39;https://selenium.dev\u0026#39;   await driver.get(\u0026#39;https://selenium.dev\u0026#39;);   //Convenient driver.get(\u0026#34;https://selenium.dev\u0026#34;) //Longer way driver.navigate().to(\u0026#34;https://selenium.dev\u0026#34;)     Coletar a URL atual Você pode ler a URL atual na barra de endereço do navegador usando:\nJava Python C# Ruby JavaScript Kotlin driver.getCurrentUrl();  driver.current_url  driver.Url;   driver.current_url  await driver.getCurrentUrl();   driver.currentUrl    Voltar Pressionando o botão Voltar do navegador:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().back();  driver.back()  driver.Navigate().Back();   driver.navigate.back  await driver.navigate().back();   driver.navigate().back()     Avançar Pressionando o botão Avançar do navegador:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().forward();  driver.forward()  driver.Navigate().Forward();   driver.navigate.forward  await driver.navigate().forward();   driver.navigate().forward()    Atualizar Atualizando a página atual:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().refresh();  driver.refresh()  driver.Navigate().Refresh();   driver.navigate.refresh  await driver.navigate().refresh();   driver.navigate().refresh()    Coletar título Você pode ler o título da página atual no navegador:\nJava Python C# Ruby JavaScript Kotlin driver.getTitle();  driver.title  driver.Title;   driver.title  await driver.getTitle();   driver.title    Janelas e guias Pega o puxador da janela O WebDriver não faz distinção entre janelas e guias. E se seu site abre uma nova guia ou janela, o Selenium permitirá que você trabalhe usando um puxador de janela. Cada janela tem um identificador único que permanece persistente em uma única sessão. Você pode pegar o puxador da janela atual usando:\nJava Python C# Ruby JavaScript Kotlin driver.getWindowHandle();  driver.current_window_handle  driver.CurrentWindowHandle;   driver.window_handle  await driver.getWindowHandle();   driver.windowHandle    Alternando janelas ou guias Clicar em um link que abre em uma nova janela  focará a nova janela ou guia na tela, mas o WebDriver não saberá qual janela que o sistema operacional considera ativa. Para trabalhar com a nova janela você precisará mudar para ela. Se você tiver apenas duas guias ou janelas abertas, e você sabe com qual janela você começa, pelo processo de eliminação você pode percorrer as janelas ou guias que o WebDriver pode ver e alternar para aquela que não é o original.\nNo entanto, o Selenium 4 fornece uma nova API NewWindow  que cria uma nova guia (ou) nova janela e muda automaticamente para ela.\nJava Python C# Ruby JavaScript Kotlin //Store the ID of the original window String originalWindow = driver.getWindowHandle(); //Check we don\u0026#39;t have other windows open already assert driver.getWindowHandles().size() == 1; //Click the link which opens in a new window driver.findElement(By.linkText(\u0026#34;new window\u0026#34;)).click(); //Wait for the new window or tab wait.until(numberOfWindowsToBe(2)); //Loop through until we find a new window handle for (String windowHandle : driver.getWindowHandles()) { if(!originalWindow.contentEquals(windowHandle)) { driver.switchTo().window(windowHandle); break; } } //Wait for the new tab to finish loading content wait.until(titleIs(\u0026#34;Selenium documentation\u0026#34;));   from selenium import webdriver from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC # Start the driver with webdriver.Firefox() as driver: # Open URL driver.get(\u0026#34;https://seleniumhq.github.io\u0026#34;) # Setup wait for later wait = WebDriverWait(driver, 10) # Store the ID of the original window original_window = driver.current_window_handle # Check we don\u0026#39;t have other windows open already assert len(driver.window_handles) == 1 # Click the link which opens in a new window driver.find_element(By.LINK_TEXT, \u0026#34;new window\u0026#34;).click() # Wait for the new window or tab wait.until(EC.number_of_windows_to_be(2)) # Loop through until we find a new window handle for window_handle in driver.window_handles: if window_handle != original_window: driver.switch_to.window(window_handle) break # Wait for the new tab to finish loading content wait.until(EC.title_is(\u0026#34;SeleniumHQ Browser Automation\u0026#34;))   //Store the ID of the original window string originalWindow = driver.CurrentWindowHandle; //Check we don\u0026#39;t have other windows open already Assert.AreEqual(driver.WindowHandles.Count, 1); //Click the link which opens in a new window driver.FindElement(By.LinkText(\u0026#34;new window\u0026#34;)).Click(); //Wait for the new window or tab wait.Until(wd =\u0026gt; wd.WindowHandles.Count == 2); //Loop through until we find a new window handle foreach(string window in driver.WindowHandles) { if(originalWindow != window) { driver.SwitchTo().Window(window); break; } } //Wait for the new tab to finish loading content wait.Until(wd =\u0026gt; wd.Title == \u0026#34;Selenium documentation\u0026#34;);   #Store the ID of the original window original_window = driver.window_handle #Check we don\u0026#39;t have other windows open already assert(driver.window_handles.length == 1, \u0026#39;Expected one window\u0026#39;) #Click the link which opens in a new window driver.find_element(link: \u0026#39;new window\u0026#39;).click #Wait for the new window or tab wait.until { driver.window_handles.length == 2 } #Loop through until we find a new window handle driver.window_handles.each do |handle| if handle != original_window driver.switch_to.window handle break end end #Wait for the new tab to finish loading content wait.until { driver.title == \u0026#39;Selenium documentation\u0026#39;}   //Store the ID of the original window const originalWindow = await driver.getWindowHandle(); //Check we don\u0026#39;t have other windows open already assert((await driver.getAllWindowHandles()).length === 1); //Click the link which opens in a new window await driver.findElement(By.linkText(\u0026#39;new window\u0026#39;)).click(); //Wait for the new window or tab await driver.wait( async () =\u0026gt; (await driver.getAllWindowHandles()).length === 2, 10000 ); //Loop through until we find a new window handle const windows = await driver.getAllWindowHandles(); windows.forEach(async handle =\u0026gt; { if (handle !== originalWindow) { await driver.switchTo().window(handle); } }); //Wait for the new tab to finish loading content await driver.wait(until.titleIs(\u0026#39;Selenium documentation\u0026#39;), 10000);   //Store the ID of the original window val originalWindow = driver.getWindowHandle() //Check we don\u0026#39;t have other windows open already assert(driver.getWindowHandles().size() === 1) //Click the link which opens in a new window driver.findElement(By.linkText(\u0026#34;new window\u0026#34;)).click() //Wait for the new window or tab wait.until(numberOfWindowsToBe(2)) //Loop through until we find a new window handle for (windowHandle in driver.getWindowHandles()) { if (!originalWindow.contentEquals(windowHandle)) { driver.switchTo().window(windowHandle) break } } //Wait for the new tab to finish loading content wait.until(titleIs(\u0026#34;Selenium documentation\u0026#34;))     Criar nova janela (ou) nova guia e alternar Cria uma nova janela (ou) guia e focará a nova janela ou guia na tela. Você não precisa mudar para trabalhar com a nova janela (ou) guia. Se você tiver mais de duas janelas (ou) guias abertas diferentes da nova janela, você pode percorrer as janelas ou guias que o WebDriver pode ver e mudar para aquela que não é a original.\nNota: este recurso funciona com Selenium 4 e versões posteriores.\nJava Python C# Ruby JavaScript Kotlin // Opens a new tab and switches to new tab driver.switchTo().newWindow(WindowType.TAB); // Opens a new window and switches to new window driver.switchTo().newWindow(WindowType.WINDOW);   # Opens a new tab and switches to new tab driver.switch_to.new_window(\u0026#39;tab\u0026#39;) # Opens a new window and switches to new window driver.switch_to.new_window(\u0026#39;window\u0026#39;)   // Opens a new tab and switches to new tab driver.SwitchTo().NewWindow(WindowType.Tab) // Opens a new window and switches to new window driver.SwitchTo().NewWindow(WindowType.Window)   # Note: The new_window in ruby only opens a new tab (or) Window and will not switch automatically # The user has to switch to new tab (or) new window # Opens a new tab and switches to new tab driver.manage.new_window(:tab) # Opens a new window and switches to new window driver.manage.new_window(:window)   // Opens a new tab and switches to new tab await driver.switchTo().newWindow(\u0026#39;tab\u0026#39;); // Opens a new window and switches to new window await driver.switchTo().newWindow(\u0026#39;window\u0026#39;);   // Opens a new tab and switches to new tab driver.switchTo().newWindow(WindowType.TAB) // Opens a new window and switches to new window driver.switchTo().newWindow(WindowType.WINDOW)     Fechando uma janela ou guia Quando você terminar com uma janela ou guia e não é a última janela ou guia aberta em seu navegador, você deve fechá-la e alternar de volta para a janela que você estava usando anteriormente. Supondo que você seguiu a amostra de código na seção anterior, você terá o identificador da janela anterior armazenado em uma variável. Junte isso e você obterá:\nJava Python C# Ruby JavaScript Kotlin //Close the tab or window driver.close(); //Switch back to the old tab or window driver.switchTo().window(originalWindow);   #Close the tab or window driver.close() #Switch back to the old tab or window driver.switch_to.window(original_window)   //Close the tab or window driver.Close(); //Switch back to the old tab or window driver.SwitchTo().Window(originalWindow);   #Close the tab or window driver.close #Switch back to the old tab or window driver.switch_to.window original_window   //Close the tab or window await driver.close(); //Switch back to the old tab or window await driver.switchTo().window(originalWindow);   //Close the tab or window driver.close() //Switch back to the old tab or window driver.switchTo().window(originalWindow)     Esquecer de voltar para outro gerenciador de janela após fechar uma janela deixará o WebDriver em execução na página agora fechada e acionar uma No Such Window Exception. Você deve trocar de volta para um identificador de janela válido para continuar a execução.\nSair do navegador no final de uma sessão Quando você terminar a sessão do navegador, você deve chamar quit, em vez de fechar:\nJava Python C# Ruby JavaScript Kotlin driver.quit();  driver.quit()  driver.Quit();   driver.quit  await driver.quit();   driver.quit()     quit irá:  Fechar todas as janelas e guias associadas a essa sessão do WebDriver Fechar o processo do navegador Fechar o processo do driver em segundo plano Notificar o Selenium Grid de que o navegador não está mais em uso para que possa ser usado por outra sessão (se você estiver usando Selenium Grid)    A falha em encerrar deixará processos e portas extras em segundo plano rodando em sua máquina, o que pode causar problemas mais tarde.\nAlgumas estruturas de teste oferecem métodos e anotações em que você pode ligar para derrubar no final de um teste.\nJava Python C# Ruby JavaScript Kotlin /** * Example using JUnit * https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterAll.html */ @AfterAll public static void tearDown() { driver.quit(); }   # unittest teardown # https://docs.python.org/3/library/unittest.html?highlight=teardown#unittest.TestCase.tearDown def tearDown(self): self.driver.quit()   /* Example using Visual Studio\u0026#39;s UnitTesting https://msdn.microsoft.com/en-us/library/microsoft.visualstudio.testtools.unittesting.aspx */ [TestCleanup] public void TearDown() { driver.Quit(); }   # UnitTest Teardown # https://www.rubydoc.info/github/test-unit/test-unit/Test/Unit/TestCase def teardown @driver.quit end   /** * Example using Mocha * https://mochajs.org/#hooks */ after(\u0026#39;Tear down\u0026#39;, async function () { await driver.quit(); });   /** * Example using JUnit * https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterAll.html */ @AfterAll fun tearDown() { driver.quit() }     Se não estiver executando o WebDriver em um contexto de teste, você pode considerar o uso do try/finally que é oferecido pela maioria das linguagens para que uma exceção ainda limpe a sessão do WebDriver.\nJava Python C# Ruby JavaScript Kotlin try { //WebDriver code here... } finally { driver.quit(); }   try: #WebDriver code here... finally: driver.quit()   try { //WebDriver code here... } finally { driver.Quit(); }   begin #WebDriver code here... ensure driver.quit end   try { //WebDriver code here... } finally { await driver.quit(); }   try { //WebDriver code here... } finally { driver.quit() }     O WebDriver do Python agora suporta o gerenciador de contexto python, que ao usar a palavra-chave with pode encerrar automaticamente o driver no fim da execução.\nwith webdriver.Firefox() as driver: # WebDriver code here... # WebDriver will automatically quit after indentation Frames e Iframes Frames são um meio obsoleto de construir um layout de site a partir de vários documentos no mesmo domínio. É improvável que você trabalhe com eles a menos que você esteja trabalhando com um webapp pré-HTML5. Iframes permitem a inserção de um documento de um domínio totalmente diferente, e são ainda comumente usado.\nSe você precisa trabalhar com frames ou iframes, o WebDriver permite que você trabalhe com eles da mesma maneira. Considere um botão dentro de um iframe. Se inspecionarmos o elemento usando as ferramentas de desenvolvimento do navegador, podemos ver o seguinte:\n\u0026lt;div id=\u0026#34;modal\u0026#34;\u0026gt; \u0026lt;iframe id=\u0026#34;buttonframe\u0026#34; name=\u0026#34;myframe\u0026#34; src=\u0026#34;https://seleniumhq.github.io\u0026#34;\u0026gt; \u0026lt;button\u0026gt;Click here\u0026lt;/button\u0026gt; \u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; Se não fosse pelo iframe, esperaríamos clicar no botão usando algo como:\nJava Python C# Ruby JavaScript Kotlin //This won\u0026#39;t work driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # This Wont work driver.find_element(By.TAG_NAME, \u0026#39;button\u0026#39;).click()   //This won\u0026#39;t work driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # This won\u0026#39;t work driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // This won\u0026#39;t work await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //This won\u0026#39;t work driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     No entanto, se não houver botões fora do iframe, você pode em vez disso, obter um erro no such element. Isso acontece porque o Selenium é ciente apenas dos elementos no documento de nível superior. Para interagir com o botão, precisamos primeiro mudar para o quadro, de forma semelhante a como alternamos janelas. WebDriver oferece três maneiras de mudar para um frame.\nUsando um WebElement Alternar usando um WebElement é a opção mais flexível. Você pode encontrar o quadro usando seu seletor preferido e mudar para ele.\nJava Python C# Ruby JavaScript Kotlin //Store the web element WebElement iframe = driver.findElement(By.cssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); //Switch to the frame driver.switchTo().frame(iframe); //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # Store iframe web element iframe = driver.find_element(By.CSS_SELECTOR, \u0026#34;#modal \u0026gt; iframe\u0026#34;) # switch to selected iframe driver.switch_to.frame(iframe) # Now click on button driver.find_element(By.TAG_NAME, \u0026#39;button\u0026#39;).click()   //Store the web element IWebElement iframe = driver.FindElement(By.CssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); //Switch to the frame driver.SwitchTo().Frame(iframe); //Now we can click the button driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # Store iframe web element iframe = driver.find_element(:css,\u0026#39;#modal \u0026gt; iframe\u0026#39;) # Switch to the frame driver.switch_to.frame iframe # Now, Click on the button driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // Store the web element const iframe = driver.findElement(By.css(\u0026#39;#modal \u0026gt; iframe\u0026#39;)); // Switch to the frame await driver.switchTo().frame(iframe); // Now we can click the button await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //Store the web element val iframe = driver.findElement(By.cssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)) //Switch to the frame driver.switchTo().frame(iframe) //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     Usando um name ou ID Se o seu frame ou iframe tiver um atributo id ou name, ele pode ser usado alternativamente. Se o name ou ID não for exclusivo na página, o primeiro encontrado será utilizado.\nJava Python C# Ruby JavaScript Kotlin //Using the ID driver.switchTo().frame(\u0026#34;buttonframe\u0026#34;); //Or using the name instead driver.switchTo().frame(\u0026#34;myframe\u0026#34;); //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # Switch frame by id driver.switch_to.frame(\u0026#39;buttonframe\u0026#39;) # Now, Click on the button driver.find_element(By.TAG_NAME, \u0026#39;button\u0026#39;).click()   //Using the ID driver.SwitchTo().Frame(\u0026#34;buttonframe\u0026#34;); //Or using the name instead driver.SwitchTo().Frame(\u0026#34;myframe\u0026#34;); //Now we can click the button driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # Switch by ID driver.switch_to.frame \u0026#39;buttonframe\u0026#39; # Now, Click on the button driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // Using the ID await driver.switchTo().frame(\u0026#39;buttonframe\u0026#39;); // Or using the name instead await driver.switchTo().frame(\u0026#39;myframe\u0026#39;); // Now we can click the button await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //Using the ID driver.switchTo().frame(\u0026#34;buttonframe\u0026#34;) //Or using the name instead driver.switchTo().frame(\u0026#34;myframe\u0026#34;) //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     Usando um índice Também é possível usar o índice do frame, podendo ser consultado usando window.frames em JavaScript.\nJava Python C# Ruby JavaScript Kotlin // Switches to the second frame driver.switchTo().frame(1);   # Switch to the second frame driver.switch_to.frame(1)   // Switches to the second frame driver.SwitchTo().Frame(1);   # switching to second iframe based on index iframe = driver.find_elements_by_tag_name(\u0026#39;iframe\u0026#39;)[1] # switch to selected iframe driver.switch_to.frame(iframe)   // Switches to the second frame await driver.switchTo().frame(1);   // Switches to the second frame driver.switchTo().frame(1)     Deixando um frame Para deixar um iframe ou frameset, volte para o conteúdo padrão como a seguir:\nJava Python C# Ruby JavaScript Kotlin // Return to the top level driver.switchTo().defaultContent();   # switch back to default content driver.switch_to.default_content()   // Return to the top level driver.SwitchTo().DefaultContent();   # Return to the top level driver.switch_to.default_content   // Return to the top level await driver.switchTo().defaultContent();   // Return to the top level driver.switchTo().defaultContent()     Gerenciamento de janelas A resolução da tela pode impactar como seu aplicativo da web é renderizado, então WebDriver fornece mecanismos para mover e redimensionar a janela do navegador.\nColetar o tamanho da janela Obtém o tamanho da janela do navegador em pixels.\nJava Python C# Ruby JavaScript Kotlin //Access each dimension individually int width = driver.manage().window().getSize().getWidth(); int height = driver.manage().window().getSize().getHeight(); //Or store the dimensions and query them later Dimension size = driver.manage().window().getSize(); int width1 = size.getWidth(); int height1 = size.getHeight();   # Access each dimension individually width = driver.get_window_size().get(\u0026#34;width\u0026#34;) height = driver.get_window_size().get(\u0026#34;height\u0026#34;) # Or store the dimensions and query them later size = driver.get_window_size() width1 = size.get(\u0026#34;width\u0026#34;) height1 = size.get(\u0026#34;height\u0026#34;)   //Access each dimension individually int width = driver.Manage().Window.Size.Width; int height = driver.Manage().Window.Size.Height; //Or store the dimensions and query them later System.Drawing.Size size = driver.Manage().Window.Size; int width1 = size.Width; int height1 = size.Height;   # Access each dimension individually width = driver.manage.window.size.width height = driver.manage.window.size.height # Or store the dimensions and query them later size = driver.manage.window.size width1 = size.width height1 = size.height   // Access each dimension individually const { width, height } = await driver.manage().window().getRect(); // Or store the dimensions and query them later const rect = await driver.manage().window().getRect(); const width1 = rect.width; const height1 = rect.height;   //Access each dimension individually val width = driver.manage().window().size.width val height = driver.manage().window().size.height //Or store the dimensions and query them later val size = driver.manage().window().size val width1 = size.width val height1 = size.height     Definir o tamanho da janela Restaura a janela e define o tamanho da janela. Java Python C# Ruby JavaScript Kotlin driver.manage().window().setSize(new Dimension(1024, 768));  driver.set_window_size(1024, 768)  driver.Manage().Window.Size = new Size(1024, 768);   driver.manage.window.resize_to(1024,768)  await driver.manage().window().setRect({ width: 1024, height: 768 });   driver.manage().window().size = Dimension(1024, 768)   \nColetar posição da janela Busca as coordenadas da coordenada superior esquerda da janela do navegador.\nJava Python C# Ruby JavaScript Kotlin // Access each dimension individually int x = driver.manage().window().getPosition().getX(); int y = driver.manage().window().getPosition().getY(); // Or store the dimensions and query them later Point position = driver.manage().window().getPosition(); int x1 = position.getX(); int y1 = position.getY();   # Access each dimension individually x = driver.get_window_position().get(\u0026#39;x\u0026#39;) y = driver.get_window_position().get(\u0026#39;y\u0026#39;) # Or store the dimensions and query them later position = driver.get_window_position() x1 = position.get(\u0026#39;x\u0026#39;) y1 = position.get(\u0026#39;y\u0026#39;)   //Access each dimension individually int x = driver.Manage().Window.Position.X; int y = driver.Manage().Window.Position.Y; //Or store the dimensions and query them later Point position = driver.Manage().Window.Position; int x1 = position.X; int y1 = position.Y;   #Access each dimension individually x = driver.manage.window.position.x y = driver.manage.window.position.y # Or store the dimensions and query them later rect = driver.manage.window.rect x1 = rect.x y1 = rect.y   // Access each dimension individually const { x, y } = await driver.manage().window().getRect(); // Or store the dimensions and query them later const rect = await driver.manage().window().getRect(); const x1 = rect.x; const y1 = rect.y;   // Access each dimension individually val x = driver.manage().window().position.x val y = driver.manage().window().position.y // Or store the dimensions and query them later val position = driver.manage().window().position val x1 = position.x val y1 = position.y     Definir posição da janela Move a janela para a posição escolhida.\nJava Python C# Ruby JavaScript Kotlin // Move the window to the top left of the primary monitor driver.manage().window().setPosition(new Point(0, 0));   # Move the window to the top left of the primary monitor driver.set_window_position(0, 0)   // Move the window to the top left of the primary monitor driver.Manage().Window.Position = new Point(0, 0);   driver.manage.window.move_to(0,0)   // Move the window to the top left of the primary monitor await driver.manage().window().setRect({ x: 0, y: 0 });   // Move the window to the top left of the primary monitor driver.manage().window().position = Point(0,0)     Maximizar janela Aumenta a janela. Para a maioria dos sistemas operacionais, a janela irá preencher a tela, sem bloquear os próprios menus do sistema operacional e barras de ferramentas.\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().maximize();  driver.maximize_window()  driver.Manage().Window.Maximize();   driver.manage.window.maximize  await driver.manage().window().maximize();   driver.manage().window().maximize()    Minimizar janela Minimiza a janela do contexto de navegação atual. O comportamento exato deste comando é específico para gerenciadores de janela individuais.\nMinimizar Janela normalmente oculta a janela na bandeja do sistema.\nNota: este recurso funciona com Selenium 4 e versões posteriores.\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().minimize();  driver.minimize_window()  driver.Manage().Window.Minimize();   driver.manage.window.minimize  await driver.manage().window().minimize();   driver.manage().window().minimize()    Janela em tamanho cheio Preenche a tela inteira, semelhante a pressionar F11 na maioria dos navegadores.\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().fullscreen();  driver.fullscreen_window()  driver.Manage().Window.FullScreen();   driver.manage.window.full_screen  await driver.manage().window().fullscreen();   driver.manage().window().fullscreen()    TakeScreenshot Usado para capturar a tela do contexto de navegação atual. O endpoint WebDriver screenshot retorna a captura de tela codificada no formato Base64.\nJava Python C# Ruby JavaScript Kotlin import org.apache.commons.io.FileUtils; import org.openqa.selenium.chrome.ChromeDriver; import java.io.*; import org.openqa.selenium.*; public class SeleniumTakeScreenshot { public static void main(String args[]) throws IOException { WebDriver driver = new ChromeDriver(); driver.get(\u0026#34;http://www.example.com\u0026#34;); File scrFile = ((TakesScreenshot)driver).getScreenshotAs(OutputType.FILE); FileUtils.copyFile(scrFile, new File(\u0026#34;./image.png\u0026#34;)); driver.quit(); } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) # Returns and base64 encoded string into image driver.save_screenshot(\u0026#39;./image.png\u0026#39;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Support.UI; var driver = new ChromeDriver(); driver.Navigate().GoToUrl(\u0026#34;http://www.example.com\u0026#34;); Screenshot screenshot = (driver as ITakesScreenshot).GetScreenshot(); screenshot.SaveAsFile(\u0026#34;screenshot.png\u0026#34;, ScreenshotImageFormat.Png); // Format values are Bmp, Gif, Jpeg, Png, Tiff    require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://example.com/\u0026#39; # Takes and Stores the screenshot in specified path driver.save_screenshot(\u0026#39;./image.png\u0026#39;) end   let {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); let fs = require(\u0026#39;fs\u0026#39;); (async function example() { let driver = await new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Returns base64 encoded string  let encodedString = await driver.takeScreenshot(); await fs.writeFileSync(\u0026#39;./image.png\u0026#39;, encodedString, \u0026#39;base64\u0026#39;); await driver.quit(); }())   import com.oracle.tools.packager.IOUtils.copyFile import org.openqa.selenium.* import org.openqa.selenium.chrome.ChromeDriver import java.io.File fun main(){ val driver = ChromeDriver() driver.get(\u0026#34;https://www.example.com\u0026#34;) val scrFile = (driver as TakesScreenshot).getScreenshotAs\u0026lt;File\u0026gt;(OutputType.FILE) copyFile(scrFile, File(\u0026#34;./image.png\u0026#34;)) driver.quit() }     TakeElementScreenshot Usado para capturar a imagem de um elemento para o contexto de navegação atual. O endpoint WebDriver screenshot retorna a captura de tela codificada no formato Base64.\nJava Python C# Ruby JavaScript Kotlin import org.apache.commons.io.FileUtils; import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; import java.io.File; import java.io.IOException; public class SeleniumelementTakeScreenshot { public static void main(String args[]) throws IOException { WebDriver driver = new ChromeDriver(); driver.get(\u0026#34;https://www.example.com\u0026#34;); WebElement element = driver.findElement(By.cssSelector(\u0026#34;h1\u0026#34;)); File scrFile = element.getScreenshotAs(OutputType.FILE); FileUtils.copyFile(scrFile, new File(\u0026#34;./image.png\u0026#34;)); driver.quit(); } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) ele = driver.find_element(By.CSS_SELECTOR, \u0026#39;h1\u0026#39;) # Returns and base64 encoded string into image ele.screenshot(\u0026#39;./image.png\u0026#39;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Support.UI; // Webdriver  var driver = new ChromeDriver(); driver.Navigate().GoToUrl(\u0026#34;http://www.example.com\u0026#34;); // Fetch element using FindElement  var webElement = driver.FindElement(By.CssSelector(\u0026#34;h1\u0026#34;)); // Screenshot for the element  var elementScreenshot = (webElement as ITakesScreenshot).GetScreenshot(); elementScreenshot.SaveAsFile(\u0026#34;screenshot_of_element.png\u0026#34;);   # Works with Selenium4-alpha7 Ruby bindings and above require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://example.com/\u0026#39; ele = driver.find_element(:css, \u0026#39;h1\u0026#39;) # Takes and Stores the element screenshot in specified path ele.save_screenshot(\u0026#39;./image.jpg\u0026#39;) end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); let fs = require(\u0026#39;fs\u0026#39;); (async function example() { let driver = await new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); let ele = await driver.findElement(By.css(\u0026#34;h1\u0026#34;)); // Captures the element screenshot  let encodedString = await ele.takeScreenshot(true); await fs.writeFileSync(\u0026#39;./image.png\u0026#39;, encodedString, \u0026#39;base64\u0026#39;); await driver.quit(); }())   import org.apache.commons.io.FileUtils import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.* import java.io.File fun main() { val driver = ChromeDriver() driver.get(\u0026#34;https://www.example.com\u0026#34;) val element = driver.findElement(By.cssSelector(\u0026#34;h1\u0026#34;)) val scrFile: File = element.getScreenshotAs(OutputType.FILE) FileUtils.copyFile(scrFile, File(\u0026#34;./image.png\u0026#34;)) driver.quit() }     Executar Script Executa o snippet de código JavaScript no contexto atual de um frame ou janela selecionada.\nJava Python C# Ruby JavaScript Kotlin //Creating the JavascriptExecutor interface object by Type casting  JavascriptExecutor js = (JavascriptExecutor)driver; //Button Element  WebElement button =driver.findElement(By.name(\u0026#34;btnLogin\u0026#34;)); //Executing JavaScript to click on element  js.executeScript(\u0026#34;arguments[0].click();\u0026#34;, element); //Get return value from script  String text = (String) javascriptExecutor.executeScript(\u0026#34;return arguments[0].innerText\u0026#34;, element); //Executing JavaScript directly  js.executeScript(\u0026#34;console.log(\u0026#39;hello world\u0026#39;)\u0026#34;);   # code sample not available please raise a PR   // code sample not available please raise a PR    # code sample not available please raise a PR   // Stores the header element let header = await driver.findElement(By.css(\u0026#39;h1\u0026#39;)); // Executing JavaScript to capture innerText of header element let text = await driver.executeScript(\u0026#39;return arguments[0].innerText\u0026#39;, header);   // code sample not available please raise a PR      Imprimir Página Imprime a página atual dentro do navegador\nNota: isto requer que navegadores Chromium estejam no modo sem cabeçalho\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.print.PrintOptions; driver.get(\u0026#34;https://www.selenium.dev\u0026#34;); printer = (PrintsPage) driver; PrintOptions printOptions = new PrintOptions(); printOptions.setPageRanges(\u0026#34;1-2\u0026#34;); Pdf pdf = printer.print(printOptions); String content = pdf.getContent();   from selenium.webdriver.common.print_page_options import PrintOptions print_options = PrintOptions() print_options.page_ranges = [\u0026#39;1-2\u0026#39;] driver.get(\u0026#34;printPage.html\u0026#34;) base64code = driver.print_page(print_options)   // code sample not available please raise a PR    driver.navigate_to \u0026#39;https://www.selenium.dev\u0026#39; base64encodedContent = driver.print_page(orientation: \u0026#39;landscape\u0026#39;)   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); const chrome = require(\u0026#39;selenium-webdriver/chrome\u0026#39;); let opts = new chrome.Options(); let fs = require(\u0026#39;fs\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .setChromeOptions(opts.headless()) .build(); await driver.get(\u0026#39;https://www.selenium.dev\u0026#39;); try { let base64 = await driver.printPage({pageRanges:[\u0026#34;1-2\u0026#34;]}); await fs.writeFileSync(\u0026#39;./test.pdf\u0026#39;, base64, \u0026#39;base64\u0026#39;); } catch (e) { console.log(e) } await driver.quit();   // code sample not available please raise a PR      "},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/grid_4/graphql_support/","title":"Suporte a buscas em GraphQL","tags":[],"description":"","content":"GraphQL é uma linguagem de consulta para APIs e um runtime para atender a essas consultas com seus dados existentes. Ele dá aos usuários o poder de pedir exatamente o que precisam e nada mais.\nEnums Enums representam possíveis conjuntos de valores para um campo.\nPor exemplo, o objeto Node possui um campo chamado status. O estado é um enum (especificamente, do tipo Status) porque pode ser UP, DRAINING ou UNAVAILABLE.\nEscalares Escalares são valores primitivos: Int, Float, String, Boolean ou ID.\nAo chamar a API GraphQL, você deve especificar o subcampo aninhado até retornar apenas escalares.\nEstrutura do Schema A estrutura do esquema de grade é a seguinte:\n{ session(id: \u0026#34;\u0026lt;session-id\u0026gt;\u0026#34;) : { id, capabilities, startTime, uri, nodeId, nodeUri, sessionDurationMillis slot : { id, stereotype, lastStarted } } grid: { uri, totalSlots, nodeCount, maxSession, sessionCount, version, sessionQueueSize } sessionsInfo: { sessionQueueRequests, sessions: [ { id, capabilities, startTime, uri, nodeId, nodeUri, sessionDurationMillis slot : { id, stereotype, lastStarted } } ] } nodesInfo: { nodes : [ { id, uri, status, maxSession, slotCount, sessions: [ { id, capabilities, startTime, uri, nodeId, nodeUri, sessionDurationMillis slot : { id, stereotype, lastStarted } } ], sessionCount, stereotypes, version, osInfo: { arch, name, version } } ] } } Consultando GraphQL O melhor jeito de consultar GraphQL é utilizando requisições curl. GraphQL permite que você busque apenas os dados que você quer, nada mais, anda menos.\nAlguns exemplos de buscas em GraphQL estão abaixo. Você pode montar as queries como quiser.\nBuscando o número total de slots (maxSession) e slots usados (sessionCount) na Grid: curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;query\u0026#34;: \u0026#34;{ grid { maxSession, sessionCount } }\u0026#34;}\u0026#39; -s \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; Geralmente na máquina local o \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; será http://localhost:4444/graphql\nBuscando todos os detalhes da Sessão, Nó e Grid: curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;query\u0026#34;:\u0026#34;{ grid { uri, maxSession, sessionCount }, nodesInfo { nodes { id, uri, status, sessions { id, capabilities, startTime, uri, nodeId, nodeUri, sessionDurationMillis, slot { id, stereotype, lastStarted } }, slotCount, sessionCount }} }\u0026#34;}\u0026#39; -s \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; Buscando o número de sessões atual na Grid: curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;query\u0026#34;:\u0026#34;{ grid { sessionCount } }\u0026#34;}\u0026#39; -s \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; Buscando a contagem máxima de sessões na Grid: curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;query\u0026#34;:\u0026#34;{ grid { maxSession } }\u0026#34;}\u0026#39; -s \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; Buscando todos os detalhes de todas as sessões de todos os nós na Grid: curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;query\u0026#34;:\u0026#34;{ sessionsInfo { sessions { id, capabilities, startTime, uri, nodeId, nodeId, sessionDurationMillis } } }\u0026#34;}\u0026#39; -s \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; Buscando informações dos slots de todas as sessões de cada Nó na Grid: curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;query\u0026#34;:\u0026#34;{ sessionsInfo { sessions { id, slot { id, stereotype, lastStarted } } } }\u0026#34;}\u0026#39; -s \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; Buscando informação da sessão para uma sessão específica: curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;query\u0026#34;:\u0026#34;{ session (id: \u0026#34;\u0026lt;session-id\u0026gt;\u0026#34;) { id, capabilities, startTime, uri, nodeId, nodeUri, sessionDurationMillis, slot { id, stereotype, lastStarted } } } \u0026#34;}\u0026#39; -s \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; Buscando os recursos de cada nó na Grid: curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;query\u0026#34;: \u0026#34;{ nodesInfo { nodes { stereotypes } } }\u0026#34;}\u0026#39; -s \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; Buscando o status de cada Nó na Grid: curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;query\u0026#34;: \u0026#34;{ nodesInfo { nodes { status } } }\u0026#34;}\u0026#39; -s \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; Buscando a URI de cada Nó e da Grid: curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;query\u0026#34;: \u0026#34;{ nodesInfo { nodes { uri } } }\u0026#34;}\u0026#39; -s \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; Query for getting the current requests in the New Session Queue: curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;query\u0026#34;:\u0026#34;{ sessionsInfo { sessionQueueRequests } }\u0026#34;}\u0026#39; -s \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; Query for getting the New Session Queue size : curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{\u0026#34;query\u0026#34;:\u0026#34;{ grid { sessionQueueSize } }\u0026#34;}\u0026#39; -s \u0026lt;LINK_TO_GRAPHQL_ENDPOINT\u0026gt; "},{"uri":"https://www.selenium.dev/documentation/pt-br/introduction/types_of_testing/","title":"Tipos de teste","tags":[],"description":"","content":"Teste de aceitação Este tipo de teste é feito para determinar se um recurso ou sistema atende às expectativas e requisitos do cliente. Este tipo de teste geralmente envolve cooperação ou feedback do cliente, sendo uma atividade de validação que responde a pergunta:\n Estamos construindo o produto certo?.\n Para aplicações web, a automação desse teste pode ser feita diretamente com o Selenium, simulando o comportamento esperado do usuário. Esta simulação pode ser feita por gravação / reprodução ou por meio dos diferentes idiomas suportados, conforme explicado nesta documentação. Observação: o teste de aceitação é um subtipo de teste funcional, ao qual algumas pessoas também podem se referir.\nTeste funcional Este tipo de teste é feito para determinar se um recurso ou sistema funciona corretamente sem problemas. Verifica o sistema em diferentes níveis para garantir que todos os cenários são cobertos e que o sistema faz o que está suposto fazer. É uma atividade de verificação que responde a pergunta:\n Estamos construindo o produto corretamente?.\n Isso geralmente inclui: os testes funcionam sem erros (404, exceções \u0026hellip;), de forma utilizável (redirecionamentos corretos), de forma acessível e atendendo às suas especificações (consulte teste de aceitação acima).\nPara aplicativos da web, a automação desse teste pode ser feito diretamente com o Selenium, simulando os retornos esperados. Esta simulação pode ser feita por gravação / reprodução ou por meio de os diferentes idiomas suportados, conforme explicado nesta documentação.\nTeste de performance/desempenho Como o próprio nome indica, testes de desempenho são feitos para medir o desempenho de um aplicativo.\nExistem dois subtipos principais para testes de desempenho:\nTeste de carga O teste de carga é feito para verificar o quão bem o aplicativo funciona sob diferentes cargas definidas (geralmente um determinado número de usuários conectados ao mesmo tempo).\nTeste de estresse O teste de estresse é feito para verificar o quão bem a aplicação funciona sob estresse (ou acima da carga máxima suportada).\nGeralmente, os testes de estresse são feitos executando alguns testes escritos com Selenium simulando diferentes usuários utilizando uma função específica no aplicativo da web e recuperando algumas medições significativas.\nIsso geralmente é feito por outras ferramentas que recuperam as métricas. Uma dessas ferramentas é a JMeter.\nPara um aplicativo da web, os detalhes a serem medidos incluem taxa de transferência, latência, perda de dados, tempos de carregamento de componentes individuais \u0026hellip;\nNota 1: todos os navegadores têm uma guia de desempenho em seus seção de ferramentas para desenvolvedores (acessível pressionando F12)\nNota 2: é um subtipo de teste não funcional já que isso geralmente é medido por sistema e não por função / recurso.\nTeste regressivo Esse teste geralmente é feito após uma alteração, correção ou adição de recurso.\nPara garantir que a mudança não quebrou nenhumas das funcionalidades, alguns testes já executados são executados novamente.\nO conjunto de testes re-executados pode ser total ou parcial e pode incluir vários tipos diferentes, dependendo da equipe de aplicação e desenvolvimento.\nDesenvolvimento orientado a testes (TDD) Em vez de um tipo de teste per se, o TDD é uma metodologia iterativa de desenvolvimento na qual os testes conduzem o design de um recurso.\nCada ciclo começa criando um conjunto de testes de unidade no qual o recurso deve eventualmente ser aprovado (eles devem falhar na primeira execução).\nDepois disso, ocorre o desenvolvimento para fazer os testes passarem. Os testes são executados novamente, iniciando outro ciclo e esse processo continua até que todos os testes sejam aprovados.\nVisa acelerar o desenvolvimento de um aplicativo com base no fato de que os defeitos custam menos quanto mais cedo são encontrados.\nDesenvolvimento orientado a comportamento (BDD) BDD também é uma metodologia de desenvolvimento iterativa com base no TDD acima, em que o objetivo é envolver todas as partes no desenvolvimento de um aplicativo.\nCada ciclo começa criando algumas especificações (que deve falhar). Em seguida, crie a os testes de unidade com falha (que também devem falhar) e, em seguida, faça o desenvolvimento.\nEste ciclo é repetido até que todos os tipos de testes sejam aprovados.\nPara fazer isso, uma linguagem de especificação é usada. Deve ser compreensível por todas as partes e ser simples, padronizada e explícita. A maioria das ferramentas usa Gherkin como esse idioma.\nO objetivo é ser capaz de detectar ainda mais erros do que TDD, visando potenciais erros de aceitação também e tornar a comunicação entre as partes mais fácil.\nUm conjunto de ferramentas está atualmente disponível para escrever as especificações e combiná-las com funções de código, como Cucumber ou SpecFlow.\nUm conjunto de ferramentas é construído em cima do Selenium para tornar este processo ainda mais rápido, transformando diretamente as especificações BDD em código executável. Alguns deles são JBehave, Capybara e Robot Framework.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/support_packages/working_with_select_elements/","title":"Trabalhando com elementos select","tags":[],"description":"","content":"Os elementos select podem exigir um pouco de código padrão para serem automatizados. Para reduzir isso e tornar seus testes mais limpos, existe uma Classe Select no pacote de suporte do Selenium. Para usá-lo, você precisará da seguinte instrução de importação:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.support.ui.Select;   from selenium.webdriver.support.select import Select   using OpenQA.Selenium.Support.UI   include Selenium::WebDriver::Support   // This feature is not implemented - Help us by sending a pr to implement this feature    import org.openqa.selenium.support.ui.Select     Você pode então criar um objeto Select usando um WebElement que faz referência a um elemento \u0026lt;select\u0026gt;.\nJava Python C# Ruby JavaScript Kotlin WebElement selectElement = driver.findElement(By.id(\u0026#34;selectElementID\u0026#34;)); Select selectObject = new Select(selectElement);   select_element = driver.find_element(By.ID,\u0026#39;selectElementID\u0026#39;) select_object = Select(select_element)   IWebElement selectElement = driver.FindElement(By.Id(\u0026#34;selectElementID\u0026#34;)); var selectObject = new SelectElement(selectElement);   select_element = driver.find_element(id: \u0026#39;selectElementID\u0026#39;) select_object = Select(select_element)   // This feature is not implemented - Help us by sending a pr to implement this feature    val selectElement = driver.findElement(By.id(\u0026#34;selectElementID\u0026#34;)) val selectObject = new Select(selectElement)     O objeto Select agora lhe dará uma série de comandos que permitem que você interaja com um elemento \u0026lt;select\u0026gt;. Em primeiro lugar, existem diferentes maneiras de selecionar uma opção do elemento \u0026lt;select\u0026gt;.\n\u0026lt;select\u0026gt; \u0026lt;option value=value1\u0026gt;Bread\u0026lt;/option\u0026gt; \u0026lt;option value=value2 selected\u0026gt;Milk\u0026lt;/option\u0026gt; \u0026lt;option value=value3\u0026gt;Cheese\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; Existem três maneiras de selecionar a primeira opção do elemento acima:\nJava Python C# Ruby JavaScript Kotlin // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.selectByIndex(1); // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.selectByValue(\u0026#34;value1\u0026#34;); // Select an \u0026lt;option\u0026gt; based upon its text selectObject.selectByVisibleText(\u0026#34;Bread\u0026#34;);   # Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.select_by_index(1) # Select an \u0026lt;option\u0026gt; based upon its value attribute select_object.select_by_value(\u0026#39;value1\u0026#39;) # Select an \u0026lt;option\u0026gt; based upon its text select_object.select_by_visible_text(\u0026#39;Bread\u0026#39;)   // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.SelectByIndex(1); // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.SelectByValue(\u0026#34;value1\u0026#34;); // Select an \u0026lt;option\u0026gt; based upon its text  selectObject.SelectByText(\u0026#34;Bread\u0026#34;);   # Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.select_by(:index, 1) # Select an \u0026lt;option\u0026gt; based upon its value attribute select_object.select_by(:value, \u0026#39;value1\u0026#39;) # Select an \u0026lt;option\u0026gt; based upon its text select_object.select_by(:text, \u0026#39;Bread\u0026#39;)   // This feature is not implemented - Help us by sending a pr to implement this feature    // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.selectByIndex(1) // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.selectByValue(\u0026#34;value1\u0026#34;) // Select an \u0026lt;option\u0026gt; based upon its text selectObject.selectByVisibleText(\u0026#34;Bread\u0026#34;)     You can then check which options are selected by using:\nJava Python C# Ruby JavaScript Kotlin // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected List\u0026lt;WebElement\u0026gt; allSelectedOptions = selectObject.getAllSelectedOptions(); // Return a WebElement referencing the first selection option found by walking down the DOM WebElement firstSelectedOption = selectObject.getFirstSelectedOption();   # Return a list[WebElement] of options that have been selected all_selected_options = select_object.all_selected_options # Return a WebElement referencing the first selection option found by walking down the DOM first_selected_option = select_object.first_selected_option   // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected var allSelectedOptions = selectObject.AllSelectedOptions; // Return a WebElement referencing the first selection option found by walking down the DOM var firstSelectedOption = selectObject.AllSelectedOptions.FirstOrDefault();   # Return an Array[Element] of options that have been selected all_selected_options = select_object.selected_options # Return a WebElement referencing the first selection option found by walking down the DOM first_selected_option = select_object.first_selected_option   // This feature is not implemented - Help us by sending a pr to implement this feature    // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected val allSelectedOptions = selectObject.allSelectedOptions // Return a WebElement referencing the first selection option found by walking down the DOM val firstSelectedOption = selectObject.firstSelectedOption     Ou você pode apenas estar interessado em quais elementos \u0026lt;option\u0026gt; o elemento \u0026lt;select\u0026gt; contém:\nJava Python C# Ruby JavaScript Kotlin // Return a List\u0026lt;WebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains List\u0026lt;WebElement\u0026gt; allAvailableOptions = selectObject.getOptions();   # Return a list[WebElement] of options that the \u0026amp;lt;select\u0026amp;gt; element contains all_available_options = select_object.options   // Return a IList\u0026lt;IWebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains IList\u0026lt;IWebElement\u0026gt; allAvailableOptions = selectObject.Options;   # Return an Array[Element] of options that the \u0026amp;lt;select\u0026amp;gt; element contains all_available_options = select_object.options   // This feature is not implemented - Help us by sending a pr to implement this feature    // Return a List\u0026lt;WebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains val allAvailableOptions = selectObject.options     Se você deseja desmarcar qualquer elemento, agora você tem quatro opções:\nJava Python C# Ruby JavaScript Kotlin // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.deselectByIndex(1); // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.deselectByValue(\u0026#34;value1\u0026#34;); // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.deselectByVisibleText(\u0026#34;Bread\u0026#34;); // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.deselectAll();   # Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.deselect_by_index(1) # Deselect an \u0026lt;option\u0026gt; based upon its value attribute select_object.deselect_by_value(\u0026#39;value1\u0026#39;) # Deselect an \u0026lt;option\u0026gt; based upon its text select_object.deselect_by_visible_text(\u0026#39;Bread\u0026#39;) # Deselect all selected \u0026lt;option\u0026gt; elements select_object.deselect_all()   // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.DeselectByIndex(1); // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.DeselectByValue(\u0026#34;value1\u0026#34;); // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.DeselectByText(\u0026#34;Bread\u0026#34;); // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.DeselectAll();   # Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.deselect_by(:index, 1) # Deselect an \u0026lt;option\u0026gt; based upon its value attribute select_object.deselect_by(:value, \u0026#39;value1\u0026#39;) # Deselect an \u0026lt;option\u0026gt; based upon its text select_object.deselect_by(:text, \u0026#39;Bread\u0026#39;) # Deselect all selected \u0026lt;option\u0026gt; elements select_object.deselect_all   // This feature is not implemented - Help us by sending a pr to implement this feature    // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.deselectByIndex(1) // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.deselectByValue(\u0026#34;value1\u0026#34;) // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.deselectByVisibleText(\u0026#34;Bread\u0026#34;) // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.deselectAll()     Finalmente, alguns elementos \u0026lt;select\u0026gt; permitem que você selecione mais de uma opção. Você pode descobrir se o seu elemento \u0026lt;select\u0026gt; é um deles usando:\nJava Python C# Ruby JavaScript Kotlin Boolean doesThisAllowMultipleSelections = selectObject.isMultiple();   does_this_allow_multiple_selections = select_object.is_multiple   bool doesThisAllowMultipleSelections = selectObject.IsMultiple;   does_this_allow_multiple_selections = select_object.multiple?   // This feature is not implemented - Help us by sending a pr to implement this feature    val doesThisAllowMultipleSelections = selectObject.isMultiple     "},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/bidi_apis/","title":"WebDriver Bidi APIs","tags":[],"description":"","content":"  Page being translated from English to Portuguese. Do you speak Portuguese? Help us to translate it by sending us pull requests!\n In Selenium 4, new Evented APIs were introduced that allow users to be able to capture events from the browser as they happen rather than using the traditional approach of Request/Response that WebDriver has used for other APIs.\nInternally WebDriver will create a WebSocket connection to the browser for events and commands to be transmitted.\nThe following list of APIs will be growing as the Selenium project works through supporting real world use cases. If there is a missing API, please raise a feature request.\nMutation Observation Mutation Observation is the ability to capture events via WebDriver BiDi when there are DOM mutations on a specific element in the DOM.\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); HasLogEvents logger = (HasLogEvents) driver; AtomicReference\u0026lt;DomMutationEvent\u0026gt; seen = new AtomicReference\u0026lt;\u0026gt;(); CountDownLatch latch = new CountDownLatch(1); logger.onLogEvent(domMutation(mutation -\u0026gt; { seen.set(mutation); latch.countDown(); })); driver.get(\u0026#34;http://www.google.com\u0026#34;); WebElement span = driver.findElement(By.cssSelector(\u0026#34;span\u0026#34;)); ((JavascriptExecutor) driver).executeScript(\u0026#34;arguments[0].setAttribute(\u0026#39;cheese\u0026#39;, \u0026#39;gouda\u0026#39;);\u0026#34;, span); assertThat(latch.await(10, SECONDS)).isTrue(); assertThat(seen.get().getAttributeName()).isEqualTo(\u0026#34;cheese\u0026#34;); assertThat(seen.get().getCurrentValue()).isEqualTo(\u0026#34;gouda\u0026#34;);   from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.wait import WebDriverWait driver = webdriver.Chrome() async with driver.log.mutation_events() as event: pages.load(\u0026#34;dynamic.html\u0026#34;) driver.find_element(By.ID, \u0026#34;reveal\u0026#34;).click() WebDriverWait(driver, 5)\\ .until(EC.visibility_of(driver.find_element(By.ID, \u0026#34;revealed\u0026#34;))) assert event[\u0026#34;attribute_name\u0026#34;] == \u0026#34;style\u0026#34; assert event[\u0026#34;current_value\u0026#34;] == \u0026#34;\u0026#34; assert event[\u0026#34;old_value\u0026#34;] == \u0026#34;display:none;\u0026#34;   IWebDriver driver = new FirefoxDriver(); driver.Url = \u0026#34;http://www.google.com\u0026#34;; // Please help with a .NET example    require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin driver.on_log_event(:mutation) { |mutation| mutations.push(mutation) } driver.navigate.to url_for(\u0026#39;dynamic.html\u0026#39;) driver.find_element(id: \u0026#39;reveal\u0026#39;).click wait.until { mutations.any? } mutation = mutations.first expect(mutation.element).to eq(driver.find_element(id: \u0026#39;revealed\u0026#39;)) expect(mutation.attribute_name).to eq(\u0026#39;style\u0026#39;) expect(mutation.current_value).to eq(\u0026#39;\u0026#39;) expect(mutation.old_value).to eq(\u0026#39;display:none;\u0026#39;) ensure driver.quit end   let {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); driver = new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); (async function test(){ const cdpConnection = await driver.createCDPConnection(\u0026#39;page\u0026#39;) await driver.logMutationEvents(cdpConnection, function (event) { assert.strictEqual(event[\u0026#39;attribute_name\u0026#39;], \u0026#39;style\u0026#39;) assert.strictEqual(event[\u0026#39;current_value\u0026#39;], \u0026#39;\u0026#39;) assert.strictEqual(event[\u0026#39;old_value\u0026#39;], \u0026#39;display:none;\u0026#39;) }) await driver.get(\u0026#34;https://www.google.com\u0026#34;) let element = driver.findElement({ id: \u0026#39;reveal\u0026#39; }) await element.click() let revealed = driver.findElement({ id: \u0026#39;revealed\u0026#39; }) await driver.wait(until.elementIsVisible(revealed), 5000) })();   val driver = FirefoxDriver() driver.get(\u0026#34;http://www.google.com\u0026#34;) // Please help us create an example for Kotlin      "},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/grid_4/advanced_features/","title":"Advanced Features","tags":[],"description":"","content":"  Page being translated from English to Portuguese (Brazil). Do you speak Portuguese (Brazil)? Help us to translate it by sending us pull requests!\n To get all the details of the advanced features, understand how it works, and how to set up your own, please browse thorough the following sections.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/support_packages/mouse_and_keyboard_actions_in_detail/","title":"Ações do mouse em detalhe","tags":[],"description":"","content":"Mouse representa um evento do mouse. Ações do mouse são realizadas usando interface de baixo nível que nos permite fornecer ação de entrada de dispositivo virtualizado para o navegador da web.\nclickAndHold Ele se moverá para o elemento e clicar (sem soltar) no meio do elemento fornecido.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class clickAndHold { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform click-and-hold action on the element  actionProvider.clickAndHold(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element searchBtn = driver.find_element(By.LINK_TEXT, \u0026#34;Sign in\u0026#34;) # Perform click-and-hold action on the element webdriver.ActionChains(driver).click_and_hold(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class ClickAndHold { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform click-and-hold action on the element  actionProvider.ClickAndHold(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Sign In\u0026#39; button web element sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Perform click-and-hold action on the element driver.action.click_and_hold(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function clickAndHold() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;google search\u0026#39; button web element  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Perform mouseMove to element and mouseDown (press) action on the element  await actions.move({origin:searchBtn}).press().perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;google search\u0026#39; button web element  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Perform click-and-hold action on the element  actionProvider.clickAndHold(searchBtn).build().perform() } finally { driver.quit() } }     contextClick Este método primeiro executa um movimento do mouse para a localização do elemento e executa o clique de contexto (clique com o botão direito) no elemento fornecido.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class contextClick { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform context-click action on the element  actionProvider.contextClick(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element searchBtn = driver.find_element(By.LINK_TEXT, \u0026#34;Sign in\u0026#34;) # Perform context-click action on the element webdriver.ActionChains(driver).context_click(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class ContextClick { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform context-click action on the element  actionProvider.ContextClick(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Sign In\u0026#39; button web element sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Perform context-click action on the element driver.action.context_click(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function contextClick() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;google search\u0026#39; button web element  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Perform context-click action on the element  await actions.contextClick(searchBtn).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;google search\u0026#39; button web element  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Perform context-click action on the element  actionProvider.contextClick(searchBtn).build().perform() } finally { driver.quit() } }     doubleClick Ele se moverá para o elemento e executará um clique duplo no meio do elemento fornecido.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class doubleClick { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform double-click action on the element  actionProvider.doubleClick(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element searchBtn = driver.find_element(By.LINK_TEXT, \u0026#34;Sign in\u0026#34;) # Perform double-click action on the element webdriver.ActionChains(driver).double_click(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DoubleClick { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform double-click action on the element  actionProvider.DoubleClick(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Sign In\u0026#39; button web element sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Perform double-click action on the element driver.action.double_click(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function doubleClick() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;google search\u0026#39; button web element  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Perform double-click action on the element  await actions.doubleClick(searchBtn).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;google search\u0026#39; button web element  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Perform double-click action on the element  actionProvider.doubleClick(searchBtn).build().perform() } finally { driver.quit() } }     moveToElement Este método move o mouse para o meio do elemento. O elemento também é rolado para a exibição ao executar esta ação.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class moveToElement { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;Gmail\u0026#39; anchor web element  WebElement gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs mouse move action onto the element  actionProvider.moveToElement(gmailLink).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element gmailLink = driver.find_element(By.LINK_TEXT, \u0026#34;Gmail\u0026#34;) # Performs mouse move action onto the element webdriver.ActionChains(driver).move_to_element(gmailLink).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class MoveToElement { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement gmailLink = driver.FindElement(By.LinkText(\u0026#34;Gmail\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs mouse move action onto the element  actionProvider.MoveToElement(gmailLink).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Gmail\u0026#39; anchor web element gmail_link = driver.find_element(link_text: \u0026#39;Gmail\u0026#39;) # Performs mouse move action onto the element driver.action.move_to(gmail_link).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function moveToElement() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;Gmail\u0026#39; anchor web element  let gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); const actions = driver.actions({async: true}); // Performs mouse move action onto the element  await actions.move({origin:gmailLink}).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;Gmail\u0026#39; anchor web element  val gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)) val actionProvider = Actions(driver) // Performs mouse move action onto the element  actionProvider.moveToElement(gmailLink).build().perform() } finally { driver.quit() } }     moveByOffset: Este método move o mouse de sua posição atual (ou 0,0) pelo deslocamento fornecido. Se as coordenadas estiverem fora da janela de visualização, o mouse ficará fora da janela do navegador.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class moveByOffset { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;Gmail\u0026#39; anchor web element  WebElement gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); // Capture x and y offset positions of element  int xOffset = gmailLink.getRect().getX(); int yOffset = gmailLink.getRect().getY(); Actions actionProvider = new Actions(driver); // Performs mouse move action onto the offset position  actionProvider.moveByOffset(xOffset, yOffset).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element gmailLink = driver.find_element(By.LINK_TEXT, \u0026#34;Gmail\u0026#34;) #Set x and y offset positions of element xOffset = 100 yOffset = 100 # Performs mouse move action onto the element webdriver.ActionChains(driver).move_by_offset(xOffset,yOffset).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class MoveByOffset { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement gmailLink = driver.FindElement(By.LinkText(\u0026#34;Gmail\u0026#34;)); // Set x and y offset positions of element  int xOffset = 100; int yOffset = 100; Actions actionProvider = new Actions(driver); // Performs mouse move action onto the offset position  actionProvider.MoveByOffset(xOffset, yOffset).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Gmail\u0026#39; anchor web element gmail_link = driver.find_element(link_text: \u0026#39;Gmail\u0026#39;) # Capture x and y offset positions of element x_offset = gmail_link.rect.x y_offset = gmail_link.rect.y # Performs mouse move action onto the offset position driver.action.move_to_location(x_offset, y_offset).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function moveByOffset() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;Gmail\u0026#39; anchor web element  let gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); // Capture offset positions of element  let offset = await gmailLink.getRect(); let x = await offset.x; let y = await offset.y; const actions = driver.actions({async: true}); // Performs mouse move action onto the element  await actions.move({x:parseInt(x),y:parseInt(y)}).pause(3000).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;Gmail\u0026#39; anchor web element  val gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)) // Capture x and y offset positions of element  val xOffset = gmailLink.rect.getX() val yOffset = gmailLink.rect.getY() val actionProvider = Actions(driver) // Performs mouse move action onto the element  actionProvider.moveByOffset(xOffset, yOffset).build().perform() } finally { driver.quit() } }     dragAndDrop Este método primeiro executa um clique e segura no elemento de origem, move-se para o local do elemento de destino e, em seguida, libera o mouse.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class dragAndDrop { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.dragAndDrop(sourceEle, targetEle).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Store \u0026#39;box A\u0026#39; as source element sourceEle = driver.find_element(By.ID, \u0026#34;draggable\u0026#34;) # Store \u0026#39;box B\u0026#39; as source element targetEle = driver.find_element(By.ID, \u0026#34;droppable\u0026#34;) # Performs drag and drop action of sourceEle onto the targetEle webdriver.ActionChains(driver).drag_and_drop(sourceEle,targetEle).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DragAndDrop { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.DragAndDrop(sourceEle, targetEle).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; # Store \u0026#39;box A\u0026#39; as source element source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) # Store \u0026#39;box B\u0026#39; as source element target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) # Performs drag and drop action of sourceEle onto the targetEle driver.action.drag_and_drop(source_ele, target_ele).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function dragAndDrop() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Store \u0026#39;box A\u0026#39; as source element  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); const actions = driver.actions({async: true}); // Performs drag and drop action of sourceEle onto the targetEle  await actions.dragAndDrop(sourceEle, targetEle).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Store \u0026#39;box A\u0026#39; as source element  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Store \u0026#39;box B\u0026#39; as source element  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val actionProvider = Actions(driver) // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.dragAndDrop(sourceEle, targetEle).build().perform() } finally { driver.quit() } }     dragAndDropBy Este método primeiro executa um clique e segura no elemento de origem, move-se para o deslocamento fornecido e, em seguida, libera o mouse.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class dragAndDropBy { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); int targetEleXOffset = targetEle.getLocation().getX(); int targetEleYOffset = targetEle.getLocation().getY(); Actions actionProvider = new Actions(driver); // Performs dragAndDropBy onto the target element offset position  actionProvider.dragAndDropBy(sourceEle, targetEleXOffset, targetEleYOffset).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Store \u0026#39;box A\u0026#39; as source element sourceEle = driver.find_element(By.ID, \u0026#34;draggable\u0026#34;) # Store \u0026#39;box B\u0026#39; as source element targetEle = driver.find_element(By.ID, \u0026#34;droppable\u0026#34;) targetEleXOffset = targetEle.location.get(\u0026#34;x\u0026#34;) targetEleYOffset = targetEle.location.get(\u0026#34;y\u0026#34;) # Performs dragAndDropBy onto the target element offset position webdriver.ActionChains(driver).drag_and_drop_by_offset(sourceEle, targetEleXOffset, targetEleYOffset).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DragAndDropToOffset { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); int targetEleXOffset = targetEle.Location.X; int targetEleYOffset = targetEle.Location.Y; Actions actionProvider = new Actions(driver); // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.DragAndDropToOffset(sourceEle, targetEleXOffset, targetEleYOffset).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; # Store \u0026#39;box A\u0026#39; as source element source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) # Capture x and y offset positions of element x_offset = target_ele.rect.x y_offset = target_ele.rect.y # Performs dragAndDropBy onto the target element offset position driver.action.drag_and_drop_by(source_ele, x_offset, y_offset).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function dragAndDropBy() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Store \u0026#39;box A\u0026#39; as source element  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); let offset = await targetEle.getRect(); let x = await offset.x; let y = await offset.y; const actions = driver.actions({async: true}); // Performs dragAndDropBy onto the target element offset position  await actions.dragAndDrop(sourceEle, {x:parseInt(x), y:parseInt(y)}).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Store \u0026#39;box A\u0026#39; as source element  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Store \u0026#39;box B\u0026#39; as source element  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val targetEleXOffset = targetEle.location.getX() val targetEleYOffset = targetEle.location.getY() val actionProvider = Actions(driver) // Performs dragAndDropBy onto the target element offset position  actionProvider.dragAndDropBy(sourceEle, targetEleXOffset, targetEleYOffset).build().perform() } finally { driver.quit() } }     release Esta ação libera o botão esquerdo do mouse pressionado. Se WebElement for aprovado, ele irá liberar o botão esquerdo do mouse pressionado no WebElement fornecido\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class release { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); actionProvider.clickAndHold(sourceEle).moveToElement(targetEle).build().perform(); // Performs release event  actionProvider.release().build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Store \u0026#39;box A\u0026#39; as source element sourceEle = driver.find_element(By.ID, \u0026#34;draggable\u0026#34;) # Store \u0026#39;box B\u0026#39; as source element targetEle = driver.find_element(By.ID, \u0026#34;droppable\u0026#34;) # Performs dragAndDropBy onto the target element offset position webdriver.ActionChains(driver).click_and_hold(sourceEle).move_to_element(targetEle).perform() #Performs release event webdriver.ActionChains(driver).release().perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class Release { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); actionProvider.ClickAndHold(sourceEle).MoveToElement(targetEle).Build().Perform(); // Performs release event  actionProvider.Release().Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) driver.action.click_and_hold(source_ele).move_to(target_ele).perform # Performs release event driver.action.release.perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function release() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Store \u0026#39;box A\u0026#39; as source element  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); const actions = driver.actions({async: true}); await actions.move({origin:sourceEle}).press().perform(); // Performs release event on target element  await actions.move({origin:targetEle}).release().perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Store \u0026#39;box A\u0026#39; as source element  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Store \u0026#39;box B\u0026#39; as source element  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val actionProvider = Actions(driver) actionProvider.clickAndHold(sourceEle).moveToElement(targetEle).build().perform() // Performs release event  actionProvider.release().build().perform() } finally { driver.quit() } }     "},{"uri":"https://www.selenium.dev/documentation/pt-br/getting_started_with_webdriver/","title":"Começando com o WebDriver","tags":[],"description":"","content":"Começando com o WebDriver Selenium suporta automação de todos os principais navegadores do mercado por meio do uso do WebDriver. WebDriver é uma API e protocolo que define uma interface de linguagem neutra para controlar o comportamento dos navegadores da web. Cada navegador é apoiado por uma implementação WebDriver específica, chamada de driver. O driver é o componente responsável por delegar ao navegador, e lida com a comunicação de e para o Selenium e o navegador.\nEssa separação é parte de um esforço consciente para que os fornecedores de navegadores assumam a responsabilidade pela implementação de seus navegadores. Selenium faz uso desses drivers de terceiros sempre que possível, mas também fornece seus próprios drivers mantidos pelo projeto para os casos em que isso não é uma realidade.\nA estrutura do Selenium une todas essas peças por meio de uma interface voltada para o usuário que permite aos diferentes back-ends de navegador serem usados de forma transparente, permitindo a automação entre navegadores e plataformas cruzadas.\nMais detalhes sobre os drivers podem ser encontrados em Idiossincrasias do driver.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/waits/","title":"Esperas","tags":[],"description":"","content":"Geralmente, pode-se dizer que o WebDriver tem uma API de blocante. Porque é uma biblioteca fora de processo que instrui ao navegador o que fazer, e porque a plataforma web tem uma natureza intrinsecamente assíncrona, O WebDriver não rastreia o estado ativo em tempo real do DOM. Isso traz alguns desafios que discutiremos aqui.\nPor experiência, a maioria dos problemas intermitentes que surgem do uso de Selenium e WebDriver estão conectados a condições de corrida que ocorrem entre o navegador e as instruções do usuário. Um exemplo pode ser que o usuário instrui o navegador a navegar para uma página, em seguida, obtém um erro no such element ao tentar encontrar um elemento.\nConsidere o seguinte documento:\n\u0026lt;!doctype html\u0026gt; \u0026lt;meta charset=utf-8\u0026gt; \u0026lt;title\u0026gt;Race Condition Example\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; var initialised = false; window.addEventListener(\u0026#34;load\u0026#34;, function() { var newElement = document.createElement(\u0026#34;p\u0026#34;); newElement.textContent = \u0026#34;Hello from JavaScript!\u0026#34;; document.body.appendChild(newElement); initialised = true; }); \u0026lt;/script\u0026gt; As instruções do WebDriver podem parecer inocentes:\nJava Python C# Ruby JavaScript Kotlin driver.get(\u0026#34;file:///race_condition.html\u0026#34;); WebElement element = driver.findElement(By.tagName(\u0026#34;p\u0026#34;)); assertEquals(element.getText(), \u0026#34;Hello from JavaScript!\u0026#34;);   driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) el = driver.find_element(By.TAG_NAME, \u0026#34;p\u0026#34;) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   driver.Navigate().GoToUrl(\u0026#34;file:///race_condition.html\u0026#34;); IWebElement element = driver.FindElement(By.TagName(\u0026#34;p\u0026#34;)); assertEquals(element.Text, \u0026#34;Hello from JavaScript!\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;file:///race_condition.html\u0026#39; # Get and store Paragraph Text search_form = driver.find_element(:css,\u0026#39;p\u0026#39;).text \u0026#34;Hello from JavaScript!\u0026#34;.eql? search_form ensure driver.quit end   await driver.get(\u0026#39;file:///race_condition.html\u0026#39;); const element = driver.findElement(By.css(\u0026#39;p\u0026#39;)); assert.strictEqual(await element.getText(), \u0026#39;Hello from JavaScript!\u0026#39;);   driver.get(\u0026#34;file:///race_condition.html\u0026#34;) val element = driver.findElement(By.tagName(\u0026#34;p\u0026#34;)) assert(element.text == \u0026#34;Hello from JavaScript!\u0026#34;)     O problema aqui é que a estratégia de carregamento de página padrão usado no WebDriver escuta o document.readyState para mudar para \u0026quot;complete\u0026quot; antes de retornar da chamada para navigate. Porque o elemento p é adicionado após o carregamento do documento concluído, este script WebDriver pode ser intermitente. \u0026ldquo;Pode\u0026rdquo; ser intermitente porque nenhuma garantia pode ser feita sobre elementos ou eventos que disparam de forma assíncrona sem esperar explicitamente - ou bloquear - nesses eventos.\nFelizmente, o conjunto normal de instruções disponível na interface _WebElement _ - tal como WebElement.click e WebElement.sendKeys — são garantidamente síncrono, em que as chamadas de função não retornarão (ou o retorno de chamada não será acionado em linguagens de estilo de retorno de chamada) até que o comando seja concluído no navegador. As APIs avançadas de interação com o usuário, Keyboard e Mouse, são exceções, pois são explicitamente pretendidas como comandos assíncronos “faça o que eu digo”.\nEsperar é fazer a execução de tarefa automatizada esperar passar um certo tempo antes de continuar com a próxima etapa.\nPara superar o problema das condições de corrida entre o navegador e o script WebDriver, a maioria dos clientes Selenium vem com um pacote wait. Ao empregar uma espera, você está usando o que é comumente referido como uma espera explícita.\nEspera explícita Esperas explícitas estão disponíveis para clientes Selenium para linguagens procedurais imperativas. Eles permitem que seu código interrompa a execução do programa, ou congelar o tópico, até que a condição que você passe resolva. A condição é chamada com uma certa frequência até que o tempo limite de espera tenha decorrido. Isso significa que, enquanto a condição retornar um valor falso, ele continuará tentando e esperando.\nComo as esperas explícitas permitem que você espere até que uma condição ocorra, eles são adequados para sincronizar o estado entre o navegador e seu DOM, e seu script WebDriver.\nPara remediar o nosso conjunto de instruções com erros de antes, poderíamos empregar um tempo de espera para que a chamada findElement espere até que o elemento adicionado dinamicamente do script seja adicionado ao DOM:\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new ChromeDriver(); driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); // Initialize and wait till element(link) became clickable - timeout in 10 seconds WebElement firstResult = new WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;))); // Print the first result System.out.println(firstResult.getText());   from selenium.webdriver.support.ui import WebDriverWait def document_initialised(driver): return driver.execute_script(\u0026#34;return initialised\u0026#34;) driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) WebDriverWait(driver).until(document_initialised) el = driver.find_element(By.TAG_NAME, \u0026#34;p\u0026#34;) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   driver = new ChromeDriver(); driver.Url = \u0026#34;https://www.google.com/ncr\u0026#34;; driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;cheese\u0026#34; + Keys.Enter); WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10)); IWebElement firstResult = wait.Until(e =\u0026gt; e.FindElement(By.XPath(\u0026#34;//a/h3\u0026#34;))); Console.WriteLine(firstResult.Text);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) def document_initialised(driver) driver.execute_script(\u0026#39;return initialised\u0026#39;) end begin driver.get \u0026#39;file:///race_condition.html\u0026#39; wait.until{document_initialised driver} search_form = driver.find_element(:css,\u0026#39;p\u0026#39;).text \u0026#34;Hello from JavaScript!\u0026#34;.eql? search_form ensure driver.quit end   const documentInitialised = () =\u0026gt; driver.executeScript(\u0026#39;return initialised\u0026#39;); await driver.get(\u0026#39;file:///race_condition.html\u0026#39;); await driver.wait(() =\u0026gt; documentInitialised(), 10000); const element = driver.findElement(By.css(\u0026#39;p\u0026#39;)); assert.strictEqual(await element.getText(), \u0026#39;Hello from JavaScript!\u0026#39;);   driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER) // Initialize and wait till element(link) became clickable - timeout in 10 seconds val firstResult = WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;))) // Print the first result println(firstResult.text)     Passamos a condição como uma referência de função que o wait executará repetidamente até que seu valor de retorno seja verdadeiro. Um valor de retorno “verdadeiro” é qualquer coisa avaliada como booleana verdadeira na linguagem em questão, como string, número, booleano, um objeto (incluindo um WebElement), ou uma sequência ou lista preenchida (não vazia). Isso significa que uma lista vazia é avaliada como falsa. Quando a condição é verdadeira e a espera de bloqueio é abortada, o valor de retorno da condição se torna o valor de retorno da espera.\nCom este conhecimento, e como o utilitário de espera ignora erros no such element por padrão, podemos refatorar nossas instruções para sermos mais concisos:\nJava Python C# Ruby JavaScript Kotlin WebElement foo = new WebDriverWait(driver, Duration.ofSeconds(3)) .until(driver -\u0026gt; driver.findElement(By.name(\u0026#34;q\u0026#34;))); assertEquals(foo.getText(), \u0026#34;Hello from JavaScript!\u0026#34;);   from selenium.webdriver.support.ui import WebDriverWait driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) el = WebDriverWait(driver).until(lambda d: d.find_element_by_tag_name(\u0026#34;p\u0026#34;)) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   using (var driver = new FirefoxDriver()) { var foo = new WebDriverWait(driver, TimeSpan.FromSeconds(3)) .Until(drv =\u0026gt; drv.FindElement(By.Name(\u0026#34;q\u0026#34;))); Debug.Assert(foo.Text.Equals(\u0026#34;Hello from JavaScript!\u0026#34;)); }   driver.get \u0026#39;file:///race_condition.html\u0026#39; wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) ele = wait.until { driver.find_element(css: \u0026#39;p\u0026#39;)} foo = ele.text assert_match foo, \u0026#39;Hello from JavaScript\u0026#39;   let ele = await driver.wait(until.elementLocated(By.css(\u0026#39;p\u0026#39;)),10000); let foo = await ele.getText(); assert(foo == \u0026#34;Hello from JavaScript\u0026#34;);   driver.get(\u0026#34;file:///race_condition.html\u0026#34;) val ele = WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.presenceOfElementLocated(By.tagName(\u0026#34;p\u0026#34;))) assert(ele.text == \u0026#34;Hello from JavaScript!\u0026#34;)     Nesse exemplo, passamos uma função anônima (mas também podemos definá-la explicitamente, como fizemos antes, para que possa ser reutilizado). O primeiro e único argumento que é passado para nossa condição é sempre uma referência ao nosso objeto driver, WebDriver. Em um ambiente multi-thread, você deve ter cuidado para operar na referência do driver passada para a condição em vez da referência ao driver no escopo externo.\nDado que a espera vai engolir erros no such element que são gerados quando o elemento não é encontrado, a condição tentará novamente até que o elemento seja encontrado. Em seguida, ele receberá o valor de retorno, um WebElement, e o passará de volta para o nosso script.\nSe a condição falhar, por exemplo um valor de retorno verdadeiro da condição nunca for alcançado, a espera lançará/gerará um erro/exceção chamado timeout error.\nOpções A condição de espera pode ser personalizada para atender às suas necessidades. Às vezes, é desnecessário esperar todo o tempo limite padrão, já que a penalidade por não atingir uma condição de sucesso pode ser cara.\nA espera permite que você passe um argumento para substituir o tempo limite:\nJava Python C# Ruby JavaScript Kotlin new WebDriverWait(driver, Duration.ofSeconds(3)).until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;)));   WebDriverWait(driver, timeout=3).until(some_condition)   new WebDriverWait(driver, TimeSpan.FromSeconds(3)).Until(ExpectedConditions.ElementToBeClickable(By.XPath(\u0026#34;//a/h3\u0026#34;)));   wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) wait.until { driver.find_element(:id, \u0026#39;message\u0026#39;).displayed? }   await driver.wait(until.elementLocated(By.id(\u0026#39;foo\u0026#39;)), 30000);   WebDriverWait(driver, Duration.ofSeconds(3)).until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;)))     Condições esperadas Já que é uma ocorrência bastante comum ter que sincronizar o DOM e suas instruções, a maioria dos clientes também vem com um conjunto de condições esperadas predefinidas. Como pode ser óbvio pelo nome, são condições predefinidas para operações de espera frequentes.\nAs condições disponíveis nas diferentes linguagens variam, mas esta é uma lista não exaustiva de alguns:\n alert is present element exists element is visible title contains title is element staleness visible text  Você pode consultar a documentação da API para cada biblioteca de cliente para encontrar uma lista exaustiva das condições esperadas:\n Classe Java org.openqa.selenium.support.ui.ExpectedConditions Classe Python selenium.webdriver.support.expected_conditions Tipo .NET OpenQA.Selenium.Support.UI.ExpectedConditions JavaScript\u0026rsquo;s selenium-webdriver/lib/until module  Espera implícita Há um segundo tipo de espera que é diferente de espera explícita chamada espera implícita. Esperando implicitamente, o WebDriver pesquisa o DOM por um certo período ao tentar encontrar qualquer elemento. Isso pode ser útil quando certos elementos da página da web não estão disponíveis imediatamente e precisam de algum tempo para carregar.\nA espera implícita pelo aparecimento de elementos está desativada por padrão e precisará ser habilitada manualmente por sessão. Misturar esperas explícitas e esperas implícitas irá causar consequências não intencionais, ou seja, espera dormir pelo máximo tempo mesmo se o elemento estiver disponível ou a condição for verdadeira.\nAtenção: Não misture esperas implícitas e explícitas. Isso pode causar tempos de espera imprevisíveis. Por exemplo, definir uma espera implícita de 10 segundos e uma espera explícita de 15 segundos pode causar um tempo limite após 20 segundos.\nUma espera implícita é dizer ao WebDriver para pesquisar o DOM por um certo período de tempo ao tentar encontrar um elemento ou elementos se não estiverem imediatamente disponíveis. A configuração padrão é 0, o que significa desativado. Depois de definida, a espera implícita é definida para a duração da sessão.\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS); driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;); WebElement myDynamicElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;));   driver = Firefox() driver.implicitly_wait(10) driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) my_dynamic_element = driver.find_element(By.ID, \u0026#34;myDynamicElement\u0026#34;)   IWebDriver driver = new ChromeDriver(); driver.Manage().Timeouts().ImplicitWait = TimeSpan.FromSeconds(10); driver.Url = \u0026#34;http://somedomain/url_that_delays_loading\u0026#34;; IWebElement dynamicElement = driver.FindElement(By.Name(\u0026#34;dynamicElement\u0026#34;));   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox driver.manage.timeouts.implicit_wait = 10 begin driver.get \u0026#39;http://somedomain/url_that_delays_loading\u0026#39; search_form = driver.find_element(:id,\u0026#39;dynamic_element\u0026#39;) ensure driver.quit end   (async function(){ // Apply timeout for 10 seconds await driver.manage().setTimeouts( { implicit: 10000 } ); // Navigate to url await driver.get(\u0026#39;http://somedomain/url_that_delays_loading\u0026#39;); let webElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;)); }());   val driver = FirefoxDriver() driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS) driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) val myDynamicElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;))     FluentWait A instância FluentWait define a quantidade máxima de tempo de espera por uma condição, bem como a frequência com que verificar a condição.\nOs usuários podem configurar a espera para ignorar tipos específicos de exceções enquanto esperam, como NoSuchElementException ao pesquisar um elemento na página.\nJava Python C# Ruby JavaScript Kotlin // Waiting 30 seconds for an element to be present on the page, checking // for its presence once every 5 seconds. Wait\u0026lt;WebDriver\u0026gt; wait = new FluentWait\u0026lt;WebDriver\u0026gt;(driver) .withTimeout(Duration.ofSeconds(30)) .pollingEvery(Duration.ofSeconds(5)) .ignoring(NoSuchElementException.class); WebElement foo = wait.until(new Function\u0026lt;WebDriver, WebElement\u0026gt;() { public WebElement apply(WebDriver driver) { return driver.findElement(By.id(\u0026#34;foo\u0026#34;)); } });   driver = Firefox() driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) wait = WebDriverWait(driver, 10, poll_frequency=1, ignored_exceptions=[ElementNotVisibleException, ElementNotSelectableException]) element = wait.until(EC.element_to_be_clickable((By.XPATH, \u0026#34;//div\u0026#34;)))   using (var driver = new FirefoxDriver()) { WebDriverWait wait = new WebDriverWait(driver, timeout: TimeSpan.FromSeconds(30)) { PollingInterval = TimeSpan.FromSeconds(5), }; wait.IgnoreExceptionTypes(typeof(NoSuchElementException)); var foo = wait.Until(drv =\u0026gt; drv.FindElement(By.Id(\u0026#34;foo\u0026#34;))); }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox exception = Selenium::WebDriver::Error::NoSuchElementError begin driver.get \u0026#39;http://somedomain/url_that_delays_loading\u0026#39; wait = Selenium::WebDriver::Wait.new(timeout: 30, interval: 5, message: \u0026#39;Timed out after 30 sec\u0026#39;, ignore: exception) foo = wait.until { driver.find_element(id: \u0026#39;foo\u0026#39;)} ensure driver.quit end   const {Builder, until} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); await driver.get(\u0026#39;http://somedomain/url_that_delays_loading\u0026#39;); // Waiting 30 seconds for an element to be present on the page, checking  // for its presence once every 5 seconds.  let foo = await driver.wait(until.elementLocated(By.id(\u0026#39;foo\u0026#39;)), 30000, \u0026#39;Timed out after 30 seconds\u0026#39;, 5000); })();   val wait = FluentWait\u0026lt;WebDriver\u0026gt;(driver) .withTimeout(Duration.ofSeconds(30)) .pollingEvery(Duration.ofSeconds(3)) .ignoring(NoSuchElementException::class.java) val foo = wait.until {it.findElement(By.id(\u0026#34;foo\u0026#34;)) }     "},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/grid_4/","title":"Grid 4","tags":[],"description":"","content":"Grid 4 Selenium Grid 4 é uma implementação nova e não compartilha a base de código da versão anterior.\nGrid 4 tem uma abordagem para tirar proveito de uma série de novas tecnologias para facilitar o escalonamento, permitindo ainda a execução local.\nPara obter todos os detalhes dos componentes do Grid 4, entenda como funciona e como definir o seu próprio. Navegue pelas seguintes seções.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/worst_practices/gmail_email_and_facebook_logins/","title":"Login via Gmail, email e Facebook","tags":[],"description":"","content":"Por vários motivos, fazer login em sites como Gmail e Facebook usando do WebDriver não é recomendado. Além de ser contra os termos de uso desses sites (onde você corre o risco de ter a conta encerrada), é lento e não confiável.\nA prática ideal é usar as APIs que os provedores de e-mail oferecem, ou no caso do Facebook, o serviço de ferramentas para desenvolvedores que expõe uma API para criar contas de teste, amigos e assim por diante. Embora usar uma API possa parecer um pouco trabalhoso, você será recompensado em velocidade, confiabilidade e estabilidade. A API também não deve mudar, enquanto as páginas da web e os localizadores de HTML mudam frequentemente e exigem que você atualize sua estrutura de teste.\nLogin em sites de terceiros usando WebDriver em qualquer ponto do seu teste aumenta o risco de seu teste falhar porque torna o teste mais longo. Uma regra geral é que testes mais longos são mais frágeis e não confiáveis.\nImplementações WebDriver que estão em conformidade com W3C também anotam o objeto navigator com uma propriedade WebDriver para que os ataques de negação de serviço possam ser mitigados.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/grid_4/grid_endpoints/","title":"Rotas da Grid","tags":[],"description":"","content":"Grid Status da Grid O status da Grid fornece o estado atual da grid. Consiste em detalhes sobre cada nó registrado. Para cada nó, o status inclui informações sobre a disponibilidade, sessões e slots do nó.\ncURL GET \u0026#39;http://localhost:4444/status\u0026#39; No modo Standalone, o URL da Grid é o endereço do servidor Standalone.\nNo modo Hub-Node, a URL da Grid é o endereço do servidor Hub.\nNo modo totalmente distribuído, a URL da Grid é o endereço do servidor do roteador.\nA URL padrão para todos os modos acima é http://localhost:4444.\nDistribuidor Remover Nó Para remover o Nó da Grid, use o comando cURL listado abaixo. Ele não interrompe nenhuma sessão em andamento em execução nesse nó. O Node continua rodando como está, a menos que seja explicitamente eliminado. O Distribuidor não está mais ciente do Nó e, portanto, qualquer solicitação de nova sessão correspondente não será encaminhado para esse Nó.\nNo modo Standalone, a URL do distribuidor é o endereço do servidor Standalone.\nNo modo Hub-Node, a URL do Distribuidor é o endereço do servidor Hub.\ncURL --request DELETE \u0026#39;http://localhost:4444/se/grid/distributor/node/\u0026lt;node-id\u0026gt;\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET: \u0026lt;secret\u0026gt; \u0026#39; No modo totalmente distribuído, a URL é o endereço do servidor Distribuidor.\ncURL --request DELETE \u0026#39;http://localhost:5553/se/grid/distributor/node/\u0026lt;node-id\u0026gt;\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET: \u0026lt;secret\u0026gt;\u0026#39; Se nenhum segredo de registro foi configurado durante a configuração da Grid, use\ncURL --request DELETE \u0026#39;http://\u0026lt;Distributor-URL\u0026gt;/se/grid/distributor/node/\u0026lt;node-id\u0026gt;\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET;\u0026#39; Drenar Nó O comando de drenagem de nó é para desligamento normal de nó. A drenagem para o Node após a conclusão de todas as sessões em andamento. No entanto, ele não aceita novas solicitações de sessão.\nNo modo Standalone, a URL do distribuidor é o endereço do servidor Standalone.\nNo modo Hub-Node, a URL do Distribuidor é o endereço do servidor Hub.\ncURL --request POST \u0026#39;http://localhost:4444/se/grid/distributor/node/\u0026lt;node-id\u0026gt;/drain\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET: \u0026lt;secret\u0026gt; \u0026#39; No modo totalmente distribuído, a URL é o endereço do servidor Distribuidor.\ncURL --request POST \u0026#39;http://localhost:5553/se/grid/distributor/node/\u0026lt;node-id\u0026gt;/drain\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET: \u0026lt;secret\u0026gt;\u0026#39; Se nenhum segredo de registro foi configurado durante a configuração da Grid, use\ncURL --request POST \u0026#39;http://\u0026lt;Distributor-URL\u0026gt;/se/grid/distributor/node/\u0026lt;node-id\u0026gt;/drain\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET;\u0026#39; Nó Os terminais nesta seção são aplicáveis ao modo Hub-Node e ao modo Grid totalmente distribuída, onde o Nó é executado de forma independente. A URL do Nó padrão é http://localhost:5555 no caso de um Nó. No caso de vários Nós, use Grid status para obter todos os detalhes do Nó e localizar o endereço do Nó.\nStatus O status do Nó é essencialmente uma verificação de integridade do Nó. O distribuidor executa ping no status do Nó em intervalos regulares e atualiza o modelo de Grid de acordo. O status inclui informações sobre disponibilidade, sessões e slots.\ncURL --request GET \u0026#39;http://localhost:5555/status\u0026#39; Drenagem O Distribuidor passa o comando [drain](# drain-node) para o Nó apropriado identificado pelo ID do Nó. Para drenar o Nó diretamente, use o comando cuRL listado abaixo. Ambos as rotas são válidas e produzem o mesmo resultado. Drenar termina as sessões em andamento antes de interromper o Nó.\ncURL --request POST \u0026#39;http://localhost:5555/se/grid/node/drain\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET: \u0026lt;secret\u0026gt;\u0026#39; Se nenhum segredo de registro foi configurado durante a configuração da Grid, use\ncURL --request POST \u0026#39;http://\u0026lt;node-URL\u0026gt;/se/grid/node/drain\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET;\u0026#39; Checar dono da sessão Para verificar se uma sessão pertence a um Nó, use o comando cURL listado abaixo.\ncURL --request GET \u0026#39;http://localhost:5555/se/grid/node/owner/\u0026lt;session-id\u0026gt;\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET: \u0026lt;secret\u0026gt;\u0026#39; Se nenhum segredo de registro foi configurado durante a configuração da Grid, use\ncURL --request GET \u0026#39;http://\u0026lt;bode-URL\u0026gt;/se/grid/node/owner/\u0026lt;session-id\u0026gt;\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET;\u0026#39; Ele retornará true se a sessão pertencer ao Nó, caso contrário, retornará false.\nDeletar sessão A exclusão da sessão encerra a sessão do WebDriver, fecha o driver e o remove do mapa de sessões ativas. Qualquer solicitação usando o id de sessão removido ou reutilizando a instância do driver gerará um erro.\ncURL --request DELETE \u0026#39;http://localhost:5555/se/grid/node/session/\u0026lt;session-id\u0026gt;\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET: \u0026lt;secret\u0026gt;\u0026#39; Se nenhum segredo de registro foi configurado durante a configuração da Grid, use\ncURL --request DELETE \u0026#39;http://\u0026lt;node-URL\u0026gt;/se/grid/node/session/\u0026lt;session-id\u0026gt;\u0026#39; --header \u0026#39;X-REGISTRATION-SECRET;\u0026#39; Fila de Sessão Limpar a Fila de Sessão A Fila de Sessão contém as novas solicitações de sessão. Para limpar a fila, use o comando cURL listado abaixo. Limpar a fila rejeita todas as solicitações na fila. Para cada solicitação, o servidor retorna uma resposta de erro ao respectivo cliente. O resultado do comando clear é o número total de solicitações excluídas.\nNo modo Standalone, a URL queuer é o endereço do servidor Standalone.\nNo modo Hub-Node, a URL do enfileirador é o endereço do servidor Hub.\ncURL --request DELETE \u0026#39;http://localhost:4444/se/grid/newsessionqueuer/queue\u0026#39; No modo totalmente distribuído, a URL do enfileirador é o endereço do servidor do Enfileirador de Sessões.\ncURL --request DELETE \u0026#39;http://localhost:5559/se/grid/newsessionqueuer/queue\u0026#39; Get New Session Queue Requests New Session Request Queue holds the new session requests. To get the current requests in the queue, use the cURL command enlisted below. The response returns the total number of requests in the queue and the request payloads.\nIn the Standalone mode, the queuer URL is the Standalone server address.\nIn the Hub-Node mode, the queuer URL is the Hub server address.\ncURL --request GET \u0026#39;http://localhost:4444/se/grid/newsessionqueuer/queue\u0026#39; In the fully distributed mode, the queuer URL is New Session Queuer server address.\ncURL --request GET \u0026#39;http://localhost:5559/se/grid/newsessionqueuer/queue\u0026#39; "},{"uri":"https://www.selenium.dev/documentation/pt-br/legacy_docs/selenium_ide/","title":"Selenium IDE Legado","tags":[],"description":"","content":"Introdução A Selenium-IDE (Integrated Development Environment) é a ferramenta que você usa para desenvolver seus casos de teste Selenium. É um plug-in do Firefox fácil de usar e é geralmente a maneira mais eficiente de desenvolver casos de teste. Ela também contém um menu de contexto que permite que você primeiro selecione um elemento de UI do navegador atualmente exibido na página e, em seguida, selecione de uma lista de comandos Selenium com parâmetros predefinidos de acordo com o contexto do elemento de UI selecionado. Isso não é apenas uma economia de tempo, mas também uma excelente maneira de aprender a sintaxe do script Selenium.\nEste capítulo é sobre a Selenium IDE e como usá-la efetivamente.\nInstalando a IDE Usando o Firefox, primeiro, baixe a IDE da página de downloads do SeleniumHQ.\nO Firefox irá protegê-lo contra a instalação de complementos de locais desconhecidos, então você precisará clicar em \u0026ldquo;Permitir\u0026rdquo; para prosseguir com a instalação, conforme mostrado na imagem a seguir.\nAo fazer download do Firefox, você verá a seguinte janela.\nSelecione Instalar Agora. A janela de complementos do Firefox aparece, mostrando primeiro uma barra de progresso, e quando o download for concluído, exibe o seguinte.\nReinicie o Firefox. Após a reinicialização do Firefox, você encontrará a Selenium-IDE listada no menu Ferramentas do Firefox.\nAbrindo a IDE Para executar a Selenium-IDE, simplesmente selecione-a no menu Ferramentas do Firefox. Ela abrirá como segue com uma janela de edição de script vazia e um menu para carregar ou criar novos casos de teste.\nFuncionalidades da IDE Barra de Menu O menu Arquivo tem opções para Caso de Teste e Suíte de Testes (conjunto de casos de teste). Usando isso, você pode adicionar um novo caso de teste, abrir um caso de teste, salvar um caso de teste, e exportar um caso de teste em uma linguagem de sua escolha. Você também pode abrir o caso de teste mais recente. Todas essas opções também estão disponíveis para a suíte de testes.\nO menu Editar permite copiar, colar, excluir, desfazer e selecionar todas as operações para editar os comandos em seu caso de teste. O menu Opções permite a mudança de configurações. Você pode definir o valor de tempo limite para certos comandos, extensões de usuário para o conjunto básico de comandos Selenium e especificar o formato (linguagem) usado ao salvar seus casos de teste. O menu Ajuda é o padrão Menu Ajuda do Firefox; há apenas um item neste menu - Documentação do elemento de UI - pertencente ao Selenium-IDE.\nBarra de Ferramentas A barra de ferramentas contém botões para controlar a execução de seus casos de teste, incluindo um recurso de etapas para depurar seus casos de teste. O botão mais à direita, aquele com o ponto vermelho, é o botão de gravação.\nControle de velocidade: controla a velocidade de execução do seu caso de teste.\nExecutar todos: executa todo a suíte de testes quando uma suíte de testes com vários casos de teste é carregado.\nExecutar: executa o teste atualmente selecionado. Quando apenas um único teste é carregado este botão e o botão Executar todos têm o mesmo efeito.\nPausar/Continuar: permite interromper e reiniciar um caso de teste em execução.\nStep: permite que você \u0026ldquo;avance\u0026rdquo; por um caso de teste, executando um comando de cada vez. Use para depurar casos de teste.\nModo TestRunner: permite que você execute o caso de teste em um navegador carregado com o Selenium-Core TestRunner. O TestRunner não é comumente usado agora e é provável seja descontinuado. Este botão é para avaliar casos de teste para compatibilidade com versões anteriores com o TestRunner. A maioria dos usuários provavelmente não precisará desse botão.\nAplicar regras de Rollup: Este recurso avançado permite sequências repetitivas de comandos do Selenium a serem agrupadas em uma única ação. A documentação detalhada sobre as regras de rollup podem ser encontradas na documentação do Elemento de UI no menu Ajuda.\nPainel de casos de teste Seu script é exibido no painel de casos de teste. Tem duas guias, uma para exibir o comando e seus parâmetros em um formato de “tabela” legível.\nA outra guia - Código Fonte exibe o caso de teste no formato nativo no qual o arquivo será armazenado. Por padrão, é HTML, embora possa ser alterado para uma linguagem de programação como Java ou C#, ou uma linguagem de script como Python. Consulte o menu Opções para obter detalhes. A visualização do Código Fonte também permite editar o caso de teste em sua forma bruta, incluindo operações de copiar, recortar e colar.\nOs campos de entrada de Comando, Destino e Valor exibem o comando atualmente selecionado junto com seus parâmetros. Estes são campos de entrada onde você pode modificar o comando atualmente selecionado. O primeiro parâmetro especificado para um comando na guia Referência do painel inferior sempre vai para o campo Destino. Se um segundo parâmetro é especificado pela guia Referência, ele sempre vai no campo Valor.\nSe você começar a digitar no campo Comando, uma lista suspensa será preenchida com base nos primeiros caracteres que você digitar; você pode então selecionar o comando que deseja no menu suspenso.\nPainel de Log / Referência / Elemento de UI / Rollup O painel inferior é usado para quatro funções diferentes - Log, Referência, Elemento de UI e Rollup - dependendo da guia selecionada.\nLog Quando você executa seu caso de teste, mensagens de erro e mensagens de informação mostrando o progresso são exibidas neste painel automaticamente, mesmo se você não selecionar a guia Log primeiro. Essas mensagens geralmente são úteis para depuração de casos de teste. Observe o botão Limpar para limpar o registro. Observe também que o botão Informações é um drop-down permitindo a seleção de diferentes níveis de informação para registrar.\nReferência A guia Referência é a seleção padrão sempre que você entrar ou modificar comandos e parâmetros Selenium no modo Tabela. No modo Tabela, o painel de Referência exibirá a documentação do comando atual. Ao inserir ou modificar comandos, seja do modo Tabela ou Código Fonte, é criticamente importante garantir que os parâmetros especificados nos campos Destino e Valor correspondem aos especificados na lista de parâmetros do painel Referência. O número de parâmetros fornecidos deve corresponder ao número especificado, a ordem dos parâmetros fornecidos deve corresponder à ordem especificada e os tipos de parâmetros fornecidos devem corresponder aos tipos especificados. Se houver uma incompatibilidade em qualquer uma dessas três áreas, o comando não funcionará corretamente.\nEmbora a guia Referência seja ótima como uma referência rápida, ainda é necessário consultar a documentação de referência do Selenium.\nElemento de UI e Rollup Informações detalhadas sobre esses dois painéis (que abrangem recursos avançados) podem ser encontradas na documentação do Elemento de UI no menu Ajuda do Selenium-IDE.\nConstruindo casos de teste Existem três métodos principais para desenvolver casos de teste. Frequentemente, um desenvolvedor de testes necessita de todas as três técnicas.\nGravando Muitos usuários de primeira viagem começam gravando um caso de teste de suas interações com um site. Quando a Selenium-IDE é aberta pela primeira vez, o botão de gravação é ativado por padrão. Se você não quiser que a Selenium-IDE comece a gravar automaticamente, você pode desligar isso indo em Opções \u0026gt; Opções… e desmarcando “Iniciar gravação imediatamente ao abrir.”\nDurante a gravação, a Selenium-IDE irá inserir comandos automaticamente em seu caso de teste com base em suas ações. Normalmente, isso incluirá:\n clicar em um link - comandos click ou clickAndWait inserir valores - comando type selecionar opções de uma caixa de listagem suspensa - comando select clicar em caixas de seleção ou botões de rádio - comando click  Aqui estão algumas “pegadinhas” para ficar atento:\n O comando type pode exigir o clique em alguma outra área da página da web para começar a gravar. Seguir um link geralmente registra um comando de clique. Frequentemente, você precisará mudar isso para clickAndWait para garantir que seu caso de teste pause até que a nova página seja completamente carregada. Caso contrário, seu caso de teste continuará executando comandos antes que a página carregue todos os seus elementos de UI. Isso causará uma falha de teste inesperada.  Adicionando verificações e asserções com o Menu de Contexto Seus casos de teste também precisarão verificar as propriedades de uma página da web. Isto requer comandos de asserção e verificação. Não descreveremos os detalhes desses comandos aqui; que estão no capítulo sobre Comandos do Selenium - “Selenese”. Aqui vamos simplesmente descrever como adicioná-los ao seu caso de teste.\nCom a gravação da Selenium-IDE, vá para o navegador exibindo sua aplicação de teste e clique com o botão direito em qualquer lugar da página. Você verá um menu de contexto mostrando comandos verificar e/ou declarar.\nNa primeira vez que você usa o Selenium, pode haver apenas um comando Selenium listado. Ao usar a IDE, no entanto, você encontrará comandos adicionais que serão rapidamente adicionados a este menu. A Selenium-IDE tentará prever qual comando, junto com os parâmetros, você precisará para um elemento de interface selecionado na atual página da web.\nVamos ver como isso funciona. Abra uma página da web de sua escolha e selecione um bloco de texto na página. Um parágrafo ou título funcionará bem. Agora, clique com o botão direito no texto selecionado. O menu de contexto deve fornecer um comando verifyTextPresent e o parâmetro sugerido deve ser o próprio texto.\nAlém disso, observe a opção Mostrar Todos os Comandos Disponíveis. Isso mostra muitos, muitos mais comandos, novamente, junto com parâmetros sugeridos, para testar seu elemento de UI atualmente selecionado.\nExperimente mais alguns elementos de UI. Tente clicar com o botão direito em uma imagem ou em um controle de usuário, como um botão ou uma caixa de seleção. Você pode precisar usar Mostrar Todos os Comandos Disponíveis para ver opções diferentes de verifyTextPresent. Depois de selecionar essas outras opções, os mais usados aparecerão no menu de contexto principal. Por exemplo, selecionar verifyElementPresent para uma imagem deve posteriormente fazer com que esse comando esteja disponível no menu de contexto principal na próxima vez que você selecionar uma imagem e clicar com o botão direito.\nNovamente, esses comandos serão explicados em detalhes no capítulo sobre comandos Selenium. Por enquanto, fique à vontade para usar a IDE para gravar e selecionar comandos em um caso de teste e, em seguida, execute-o. Você pode aprender muito sobre os comandos do Selenium simplesmente experimentando com a IDE.\nEditando Inserir comando Visualização Tabela Selecione o ponto em seu caso de teste onde deseja inserir o comando. No painel de caso de teste, clique com o botão esquerdo na linha onde deseja inserir um novo comando. Clique com o botão direito e selecione Inserir Comando; a IDE irá adicionar um espaço em branco imediatamente à frente da linha que você selecionou. Agora use os campos de edição de texto para inserir seu novo comando e seus parâmetros.\nVisualização Código Fonte Selecione o ponto em seu caso de teste onde deseja inserir o comando. No painel do caso de teste, clique com o botão esquerdo entre os comandos onde você deseja insira um novo comando e insira as tags HTML necessárias para criar uma linha de 3 colunas contendo o Comando, primeiro parâmetro (se for exigido pelo Comando), e segundo parâmetro (novamente, se for necessário para localizar um elemento) e terceiro parâmetro (novamente, se for necessário ter um valor). Exemplo:\n\u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Command\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;target (locator)\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Value\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; Inserir comentário Comentários podem ser adicionados para tornar seu caso de teste mais legível. Esses comentários são ignorados quando o caso de teste é executado.\nOs comentários também podem ser usados para adicionar espaço em branco vertical (uma ou mais linhas em branco) em seus testes; apenas crie comentários vazios. Um comando vazio causará um erro durante a execução; um comentário vazio, não.\nVisualização Tabela Selecione a linha em seu caso de teste onde deseja inserir o comentário. Clique com o botão direito e selecione Inserir Comentário. Agora use o campo Comando para inserir o comentário. Seu comentário aparecerá em roxo.\nVisualização Código Fonte Selecione o ponto em seu caso de teste onde deseja inserir o comentário. Adicione um comentário no estilo HTML, ou seja, \u0026lt;!-- seu comentário aqui --\u0026gt;\nEditar um comando ou comentário Visualização Tabela Basta selecionar a linha a ser alterada e editá-la usando os campos de comando, destino, e valor.\nVisualização Código Fonte Uma vez que a visualização do Código Fonte fornece o equivalente a um editor WYSIWYG (What You See Is What You Get), simplesmente modifique a linha que você deseja - comando, parâmetro ou comentário.\nAbrindo e salvando um caso de teste Como a maioria dos programas, existem comandos Salvar e Abrir no menu Arquivo. No entanto, o Selenium distingue entre casos de teste e suítes de teste. Para salvar seus testes Selenium-IDE para uso posterior, você pode salvar os casos de teste individualmente ou salvar a suíte de testes. Se os casos de teste de sua suíte de testes não foram salvos, você será solicitado a salvá-los antes de salvar a suíte.\nQuando você abre um caso de teste ou suíte existente, a Selenium-IDE exibe seu comandos do Selenium no painel de caso de teste.\nExecutando casos de teste A IDE fornece muitas opções para executar seu caso de teste. Você pode executar um caso de teste inteiro de uma vez, parar e iniciar, executar uma linha de cada vez, executar um único comando que você está desenvolvendo atualmente e pode fazer uma execução em lote de uma suíte de testes. A execução de casos de teste é muito flexível na IDE.\nExecutar um caso de teste\nClique no botão Executar para executar o caso de teste mostrado.\nExecutar uma suíte de testes\nClique no botão Executar Todos para executar todos os testes dentro da suíte de testes\nParar e Continuar\nO botão de Pausa pode ser utilizado para parar o caso de teste no meio da sua execução. O ícone do botão então muda para indicar que você pode Continuar. Para continuar, clique nele.\nParar no meio\nVocê pode definir um ponto de interrupção (breakpoint) no caso de teste para que ele pare em um comando específico. Isto é útil para depurar seu teste. Para definir um ponto de interrupção, selecione um comando, clique com o botão direito e a partir do Menu de Contexto selecione Alternar ponto de interrupção.\nComeçar do meio\nVocê pode preferir que a IDE comece a executar a partir de um comando específico no meio do caso de teste. Isto também pode ser usado para depuração. Para definir um ponto de começo, selecione o comando, clique com o botão direito e a partir do Menu de Contexto selecione Set/Clear Start Point.\nExecute um comando isolado\nDe um duplo-clique em qualquer comando para executá-lo. Isto é útil quando você está escrevendo um único comando. Permite testar imediatamente o comando sendo construído, quando não tem certeza se ele está certo. Você pode dar um duplo-clique para ver se o comando é executado corretamente. Isto também está disponível no Menu de Contexto.\nUsando uma URL base para executar casos de teste em diferentes domínios O campo URL base na parte superior da janela da Selenium-IDE é muito útil para permitir que os casos de teste sejam executados em diferentes domínios. Suponha que um site chamado http://news.portal.com tenha um site beta interno chamado http://beta.news.portal.com. Quaisquer casos de teste para esses sites que começam com um comando open devem especificar uma URL relativa como o argumento para abrir, em vez de uma URL absoluta (começando com um protocolo como http: ou https:). A Selenium-IDE irá então criar uma URL absoluta anexando o argumento do comando open no final do valor da URL base. Por exemplo, o caso de teste abaixo seria executado em http://news.portal.com/about.html:\nEste mesmo caso de teste com uma configuração de URL base modificada seria executado em http://beta.news.portal.com/about.html:\nComandos Selenium – “Selenese” Os comandos do Selenium, muitas vezes chamados de Selenese, são o conjunto de comandos que executam o seu testes. Uma sequência desses comandos é um script de teste. Aqui nós explicamos esses comandos em detalhes, e apresentamos as diversas opções que você tem ao testar a sua aplicação web usando o Selenium.\nSelenium fornece um conjunto rico de comandos para testar totalmente sua aplicação web quase de qualquer maneira que você possa imaginar. O conjunto de comandos é frequentemente chamado de Selenese. Esses comandos criam essencialmente uma linguagem de teste.\nEm Selenese, pode-se testar a existência de elementos de UI com base em suas tags HTML, testar a existência de um conteúdo específico, testar a existência de links quebrados, campos de entrada, opções de lista de seleção, envio de formulários e dados de tabela, entre outras coisas. Além do mais os comandos do Selenium suportam testes de tamanho de janela, posição do mouse, alertas, funcionalidade Ajax, janelas pop-up, tratamento de eventos e muitas outras características de aplicativos da web. A Referência de Comandos lista todos os comandos disponíveis.\nUm comando diz ao Selenium o que fazer. Os comandos do Selenium vêm em três \u0026ldquo;sabores\u0026rdquo;: Ações, Acessores e Asserções.\n  Ações são comandos que geralmente manipulam o estado do aplicativo. Elas fazem coisas como “clicar neste link” e “selecionar essa opção”. Se uma ação falhar ou tiver um erro, a execução do teste atual é interrompida.\nMuitas ações podem ser chamadas com o sufixo \u0026ldquo;AndWait\u0026rdquo;, por ex. “ClickAndWait”. Este sufixo diz ao Selenium que a ação fará com que o navegador faça uma chamada para o servidor, e que o Selenium deve aguardar o carregamento de uma nova página.\n  Acessores examinam o estado do aplicativo e armazenam os resultados em variáveis, por exemplo “StoreTitle”. Eles também são usados para gerar Asserções automaticamente.\n  Asserções são como Acessores, mas verificam se o estado da aplicação está em conformidade com o que é esperado. Os exemplos incluem “certifique-se de que o título da página é X” e “verifique se esta caixa de seleção está marcada”.\n  Todas as asserções do Selenium podem ser usadas em 3 modos: \u0026ldquo;assert\u0026rdquo;, \u0026ldquo;verify\u0026rdquo; e \u0026ldquo;wait for\u0026rdquo;. Por exemplo, você pode usar “assertText”, “verifyText” e “waitForText”. Quando uma asserção falha, o teste é abortado. Quando uma verificação falha, o teste continuará a execução, registrando a falha. Isso permite uma única asserção para certificar-se de que o aplicativo está na página correta, seguido por um monte de verificações para testar os valores dos campos do formulário, rótulos, etc.\nOs comandos \u0026ldquo;waitFor\u0026rdquo; aguardam até que alguma condição se torne verdadeira (o que pode ser útil para testar aplicativos Ajax). Eles terão sucesso imediatamente se a condição já é verdadeira. No entanto, eles falharão e interromperão o teste se a condição não se tornar verdadeira dentro da configuração de timeout atual (veja o setTimeout ação abaixo).\nSintaxe do Script Os comandos do Selenium são simples, consistem no comando e em dois parâmetros. Por exemplo:\n          verifyText //div//a[2] Login    Os parâmetros nem sempre são necessários, depende do comando. Em alguns casos ambos são necessários, em outros um parâmetro é necessário, e ainda em outros, o comando pode não ter nenhum parâmetro. Aqui estão mais alguns exemplos:\n          goBackAndWait     verifyTextPresent  Welcome to My Home Page   type id=phone (555) 666-7066   type id=address1 ${myVariableAddress}    A referência de comandos descreve os requisitos de parâmetro para cada comando.\nOs parâmetros variam, mas normalmente são:\n um localizador para identificar um elemento de UI em uma página. um padrão de texto para verificar ou fazer uma asserção do conteúdo esperado da página um padrão de texto ou uma variável Selenium para inserir texto em um campo de entrada ou para selecionar uma opção de uma lista de opções.  Localizadores, padrões de texto, variáveis Selenium e os próprios comandos são descritos em bastante detalhe na seção sobre Comandos do Selenium.\nOs scripts do Selenium que serão executados a partir da Selenium-IDE serão armazenados em um arquivo de texto HTML. Isso consiste em uma tabela HTML com três colunas. A primeira coluna identifica o comando Selenium, a segunda é um alvo e a última coluna contém um valor. A segunda e terceira colunas podem não exigir valores dependendo do comando Selenium escolhido, mas elas devem estar presentes. Cada linha da tabela representa um novo comando Selenium. Aqui está um exemplo de um teste que abre uma página, faz um asserção no título da página e, em seguida, verifica algum conteúdo na página:\n\u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;/download/\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;assertTitle\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;Downloads\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;verifyText\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;//h2\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;Downloads\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; Renderizado como uma tabela em um navegador, seria assim:\n          open /download/    assertTitle  Downloads   verifyText //h2 Downloads    A sintaxe HTML Selenese pode ser usada para escrever e executar testes sem exigir conhecimento de uma linguagem de programação. Com um conhecimento básico de Selenese e Selenium-IDE você pode produzir e executar casos de teste rapidamente.\nSuítes de Teste Uma suíte de testes é uma coleção de testes. Frequentemente, você executará todos os testes em uma suite de teste como um trabalho em lote contínuo.\nAo usar a Selenium-IDE, as suítes de testes também podem ser definidas usando um arquivo HTML simples. A sintaxe novamente é simples. Uma tabela HTML define uma lista de testes onde cada linha define o caminho do sistema de arquivos para cada teste. Um exemplo diz tudo.\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Test Suite Function Tests - Priority 1\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;b\u0026gt;Suite Of Tests\u0026lt;/b\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./Login.html\u0026#34;\u0026gt;Login\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./SearchValues.html\u0026#34;\u0026gt;Test Searching for Values\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./SaveValues.html\u0026#34;\u0026gt;Test Save\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Um arquivo semelhante a este permitiria executar todos os testes de uma vez, um após o outro, a partir da Selenium-IDE.\nAs suítes de testes também podem ser mantidas ao usar o Selenium-RC. Isso é feito via programação de várias maneiras. Normalmente Junit é usado para manter um conjunto de testes se estiver usando Selenium-RC com Java. Além disso, se C# é a linguagem escolhida, o Nunit pode ser utilizado. Se estiver usando uma linguagem interpretada como Python com Selenium-RC, então alguma programação simples seria envolvida na configuração de uma suíte. Uma vez que o motivo de usar Selenium-RC é se aproveitar da lógica de programação para o seu teste, geralmente não é um problema.\nComandos Selenium usados com frequencia Para concluir nossa introdução ao Selenium, mostraremos alguns comandos típicos. Estes são provavelmente os comandos mais comumente usados para construir testes.\nopen\nabre uma página usando a URL.\nclick/clickAndWait\nrealiza um clique e opcionalmente aguarda o carregamento de uma nova página.\nverifyTitle/assertTitle\nverifica se o título da página é o esperado.\nverifyTextPresent\nverifica se o texto esperado está em algum lugar da página.\nverifyElementPresent\nverifica se o elemento de UI esperado, definido pela tag HTML, está em algum lugar da página.\nverifyText\nverficia se o texto esperado e a tag HTML correspondente estão presentes na página.\nverifyTable\nverifica se o conteúdo da tabela é o esperado.\nwaitForPageToLoad\npausa a execução até que a nova página carregue. Chamado automaticamente quando clickAndWait é utilizado.\nwaitForElementPresent\npausa a execução até que um elemento HTML, definido por sua tag HTML, esteja presenta na página.\nVerificando elementos da página Verificar os elementos de UI em uma página da web é provavelmente o recurso mais comum dos seus testes automatizados. Selenese permite várias maneiras de verificar os elementos de UI. É importante que você entenda esses métodos diferentes porque eles definem o que você está realmente testando.\nPor exemplo, você vai testar se\u0026hellip;\n um elemento está presente em algum lugar da página? um texto específico está em algum lugar da página? um texto específico está em um local específico na página?  Por exemplo, se você estiver testando um título de texto, o texto e sua posição na parte superior da página provavelmente são relevantes para o seu teste. Se, no entanto, você está testando a existência de uma imagem na página inicial, e os web designers frequentemente alteram o arquivo de imagem específico junto com sua posição na página, então você só quer testar se uma imagem (em oposição à um arquivo de imagem específico) existe em algum lugar.\nAsserção ou Verificação? Escolher entre \u0026ldquo;assert\u0026rdquo; e \u0026ldquo;verify\u0026rdquo; se resume à conveniência e gerenciamento de falhas. Não vale a pena verificar se o primeiro parágrafo da página é correto se o seu teste já falhou ao verificar se o navegador está exibindo a página esperada. Se você não estiver na página correta, você provavelmente vai querer abortar seu caso de teste para poder investigar a causa e corrigir o(s) problema(s) imediatamente. Por outro lado, você pode querer verificar muitos atributos de uma página sem abortar o caso de teste na primeira falha pois isso permitirá que você analise todas as falhas na página e tome a ação apropriada. Efetivamente, um \u0026ldquo;assert\u0026rdquo; irá falhar no teste e abortar o caso de teste atual, enquanto um \u0026ldquo;verify\u0026rdquo; irá falhar no teste e continuar a executar o caso de teste.\nO melhor uso desse recurso é agrupar logicamente seus comandos de teste e iniciar cada grupo com um \u0026ldquo;assert\u0026rdquo; seguido por um ou mais comandos de \u0026ldquo;verify\u0026rdquo;. Segue um exemplo:\n   Command Target Value     open /download/    assertTitle  Downloads   verifyText //h2 Downloads   assertTable 1.2.1 Selenium IDE   verifyTable 1.2.2 June 3, 2008   verifyTable 1.2.3 1.0 beta 2    O exemplo acima primeiro abre uma página e, em seguida, faz uma asserção para saber se a página correta é carregada comparando o título com o valor esperado. Só se passar, o seguinte comando será executado e verificará se o texto está presente na localização esperada. O caso de teste, então, faz uma asserção para saber se a primeira coluna na segunda linha da primeira tabela contém o valor esperado, e somente se este for aprovado as células restantes nessa linha serão “verificadas”.\nverifyTextPresent O comando verifyTextPresent é usado para verificar se existe um texto específico em algum lugar na página. Leva um único argumento - o texto a ser verificado. Por exemplo:\n   Command Target Value     verifyTextPresent Marketing Analysis     Isso faria com que o Selenium procurasse e verificasse que a string de texto “Marketing Analysis” aparece em algum lugar na página que está sendo testada. Use verifyTextPresent quando você está interessado apenas no próprio texto estar presente na página. Não use isso quando você também precisa testar onde o texto está na página.\nverifyElementPresent Use este comando quando precisar testar a presença de um elemento de UI específico, em vez de seu conteúdo. Esta verificação não verifica o texto, apenas a tag HTML. Um uso comum é verificar a presença de uma imagem.\n   Command Target Value     verifyElementPresent //div/p/img     Este comando verifica se uma imagem, especificada pela existência de uma tag HTML \u0026lt;img\u0026gt;, está presente na página e aparece após uma tag \u0026lt;div\u0026gt; e uma tag \u0026lt;p\u0026gt;. O primeiro (e único) parâmetro é um localizador para informar o comando Selenese de como encontrar o elemento. Os localizadores são explicados na próxima seção.\nverifyElementPresent pode ser usado para verificar a existência de qualquer tag HTML dentro da página. Você pode verificar a existência de links, parágrafos, divisões \u0026lt;div\u0026gt;, etc. Aqui estão mais alguns exemplos.\n   Command Target Value     verifyElementPresent //div/p    verifyElementPresent //div/a    verifyElementPresent id=Login    verifyElementPresent link=Go to Marketing Research    verifyElementPresent //a[2]    verifyElementPresent //head/title     Esses exemplos ilustram a variedade de maneiras pelas quais um elemento de UI pode ser testado. Novamente, os localizadores são explicados na próxima seção.\nverifyText Use verifyText quando o texto e seu elemento de UI devem ser testados. verifyText deve usar um localizador. Se você escolher um localizador XPath ou DOM, você pode verificar se um texto específico aparece em um local específico na página em relação a outro componente na página.\n   Command Target Value     verifyText //table/tr/td/div/p This is my text and it occurs right after the div inside the table.    Localizando elementos Para muitos comandos do Selenium, um alvo é necessário. Este alvo identifica um elemento no conteúdo do aplicativo da web, e consiste na estratégia de localização seguida pela localização no formato locatorType = location. O tipo de localizador pode ser omitido em muitos casos. Os vários tipos de localizadores são explicados abaixo com exemplos para cada um.\nLocalizando pelo Identificador Este é provavelmente o método mais comum de localização de elementos e é o padrão quando nenhum tipo de localizador reconhecido é usado. Com esta estratégia, o primeiro elemento com o valor do atributo id correspondente ao local será usado. E se nenhum elemento tem um atributo id correspondente, então o primeiro elemento com um atributo name correspondente ao local será usado.\nPor exemplo, o código fonte da sua página pode ter atributos id e name do seguinte modo:\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt; As seguintes estratégias de localização retornariam os elementos do HTML acima indicado pelo número da linha:\n identifier=loginForm (3) identifier=password (5) identifier=continue (6) continue (6)  Como o tipo de localizador identifier é o padrão, o identifier = nos primeiros três exemplos acima não é necessário.\nLocalizando pelo id Este tipo de localizador é mais limitado do que o tipo Localizador por Identificador, mas também mais explícito. Use isto quando você souber o atributo id de um elemento.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  id=loginForm (3)  Localizando pelo name O tipo Localizador de Nome irá localizar o primeiro elemento com um atributo name correspondente. Se vários elementos tiverem o mesmo valor para um atributo name, então você pode usar filtros para refinar ainda mais sua estratégia de localização. O tipo de filtro padrão é value (correspondendo ao atributo value).\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  name=username (4) name=continue value=Clear (7) name=continue Clear (7) name=continue type=button (7)  Nota: Ao contrário de alguns tipos de localizadores XPath e DOM, os três tipos de localizadores acima permitem que o Selenium teste um elemento de UI independente de sua localização em a página. Portanto, se a estrutura e a organização da página forem alteradas, o teste ainda vai passar. Você pode ou não querer também testar se a página tem mudanças de estrutura. No caso em que os web designers frequentemente alteram a página, mas sua funcionalidade deve ser testada por regressão, testando via id e atributos de nome, ou realmente através de qualquer propriedade HTML, torna-se muito importante.\nLocalizando pelo XPath XPath é a linguagem usada para localizar nós em um documento XML. Como o HTML pode ser uma implementação de XML (XHTML), os usuários do Selenium podem aproveitar esta poderosa linguagem para encontrar elementos em seus aplicativos da web. XPath vai além (bem como apoia) os métodos simples de localização por atributos id ou name e abre todos os tipos de novas possibilidades, como localizar a terceira caixa de seleção na página.\nUma das principais razões para usar XPath é quando você não tem um id adequado ou atributo de nome para o elemento que você deseja localizar. Você pode usar XPath para localizar o elemento em termos absolutos (não recomendado) ou em relação a um elemento que possui um atributo id ou name. Localizadores XPath também podem ser usados para especificar elementos por meio de atributos diferentes de id e name.\nOs XPaths absolutos contêm a localização de todos os elementos da raiz (html) e como resultado, é provável que falhe com apenas o menor ajuste na aplicação. Ao encontrar um elemento próximo com um atributo id ou name (de preferência um elemento pai), você pode localizar seu elemento de destino com base no relacionamento. É muito menos provável que isso mude e pode tornar seus testes mais robustos.\nUma vez que apenas os localizadores xpath começam com \u0026ldquo;//\u0026quot;, não é necessário incluir o rótulo xpath= ao especificar um localizador XPath.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  xpath=/html/body/form[1] (3) - Caminho absoluto (seria quebrado se o HTML sofresse qualquer pequena mudança) //form[1] (3) - Primeiro elemento \u0026lt;form\u0026gt; no HTML xpath=//form[@id='loginForm'] (3) - O elemento \u0026lt;form\u0026gt; com o atributo \u0026lsquo;id\u0026rsquo; e o valor \u0026lsquo;loginForm\u0026rsquo; xpath=//form[input/@name='username'] (3) - Primeiro elemento \u0026lt;form\u0026gt; com um elemento filho \u0026lt;input\u0026gt; com o atributo \u0026lsquo;name\u0026rsquo; e o valor \u0026lsquo;username\u0026rsquo; //input[@name='username'] (4) - Primeiro elemento \u0026lt;input\u0026gt; com o atributo \u0026lsquo;name\u0026rsquo; e o valor \u0026lsquo;username\u0026rsquo; //form[@id='loginForm']/input[1] (4) - Primeiro elemento filho \u0026lt;input\u0026gt; do elemento \u0026lt;form\u0026gt; com o atributo \u0026lsquo;id\u0026rsquo; e o valor \u0026lsquo;loginForm\u0026rsquo; //input[@name='continue'][@type='button'] (7) - \u0026lt;input\u0026gt; com o atributo \u0026lsquo;name\u0026rsquo; e o valor \u0026lsquo;continue\u0026rsquo; e o atributo \u0026lsquo;type\u0026rsquo; e o valor \u0026lsquo;button\u0026rsquo; //form[@id='loginForm']/input[4] (7) - Quarto elemento filho \u0026lt;input\u0026gt; do elemento \u0026lt;form\u0026gt; com atributo \u0026lsquo;id\u0026rsquo; e valor \u0026lsquo;loginForm\u0026rsquo;  Esses exemplos cobrem alguns princípios básicos, mas para aprender mais, as seguintes referências são recomendadas:\n W3Schools XPath Tutorial W3C XPath Recommendation  Existem também alguns complementos do Firefox muito úteis que podem ajudar a descobrir o XPath de um elemento:\n XPath Checker - Pode ser usado para testar os resultados do XPath. Firebug - Sugestões de XPath é apenas um dos muitos recursos poderosos deste complemento muito útil.  Localizando hyperlinks pelo texto do link Este é um método simples de localizar um hiperlink em sua página da web usando o texto do link. Se dois links com o mesmo texto estiverem presentes, então a primeira correspondência será usada.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Are you sure you want to do this?\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;continue.html\u0026#34;\u0026gt;Continue\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;cancel.html\u0026#34;\u0026gt;Cancel\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  link=Continue (4) link=Cancel (5)  Localizando pelo DOM O Document Object Model representa um documento HTML e pode ser acessado usando JavaScript. Esta estratégia de localização usa um JavaScript que representa um elemento na página, que pode ser simplesmente a localização do elemento usando a notação hierárquica.\nUma vez que apenas os localizadores dom começam com \u0026ldquo;document\u0026rdquo;, não é necessário incluir o rótulo dom= ao especificar um localizador DOM.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  dom=document.getElementById('loginForm') (3) dom=document.forms['loginForm'] (3) dom=document.forms[0] (3) document.forms[0].username (4) document.forms[0].elements['username'] (4) document.forms[0].elements[0] (4) document.forms[0].elements[3] (7)  Você pode usar o próprio Selenium, bem como outros sites e extensões para explorar o DOM do seu aplicativo da web. Uma boa referência é a W3Schools.\nLocalizando pelo CSS CSS (Cascading Style Sheets) é uma linguagem para descrever a renderização de HTML e documentos XML. CSS usa seletores para vincular propriedades de estilo a elementos no documento. Esses seletores podem ser usados pelo Selenium como outra estratégia de localização.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input class=\u0026#34;required\u0026#34; name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input class=\u0026#34;required passfield\u0026#34; name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  css=form#loginForm (3) css=input[name=\u0026quot;username\u0026quot;] (4) css=input.required[type=\u0026quot;text\u0026quot;] (4) css=input.passfield (5) css=#loginForm input[type=\u0026quot;button\u0026quot;] (7) css=#loginForm input:nth-child(2) (5)  Para obter mais informações sobre seletores CSS, o melhor lugar para ir é a publicação do W3C. Você encontrará todas as referências lá.\nLocalizadores implícitos Você pode optar por omitir o tipo de localizador nas seguintes situações:\n  Localizadores sem uma estratégia de localização explicitamente definida utilizará a estratégia de localização padrão. Veja Localizando pelo Identificador.\n  Localizadores começando com \u0026ldquo;//\u0026rdquo; usarão a estratégia de localização XPath. Veja Localizando pelo XPath.\n  Os localizadores que começam com \u0026ldquo;document\u0026rdquo; usarão a estratégia do localização DOM. Veja Localizando pelo DOM\n  Padrões de texto Como os localizadores, padrões são um tipo de parâmetro frequentemente exigido pelos comandos Selenese. Exemplos de comandos que exigem padrões são verifyTextPresent, verifyTitle, verifyAlert, assertConfirmation, verifyText, e verifyPrompt. E como foi mencionado acima, os localizadores de link podem utilizar um padrão. Os padrões permitem que você descreva, por meio do uso de caracteres especiais, qual texto é esperado em vez de precisar especificar esse texto exatamente.\nExistem três tipos de padrões: globbing, expressões regulares e exato.\nPadrão de Globbing A maioria das pessoas está familiarizada com o uso de globbing em expansão de nome de arquivo em uma linha de comando DOS ou Unix / Linux como ls * .c. Neste caso, globbing é usado para exibir todos os arquivos no diretório atual que terminam com uma extensão .c. Globbing é bastante limitado. Apenas dois caracteres especiais são suportados na implementação do Selenium:\n* que é traduzido como \u0026ldquo;corresponder a qualquer coisa\u0026rdquo;, ou seja, nada, um único caractere ou muitos caracteres.\n[ ] (classe de caracteres) que é traduzido como \u0026ldquo;corresponder a qualquer caractere dentro dos colchetes.\u0026rdquo; Um travessão (hífen) pode ser usado como uma abreviação para especificar um intervalo de caracteres (que são contíguos no conjunto ASCII). Alguns exemplos tornarão clara a funcionalidade de uma classe de caracteres:\n[aeiou] corresponde a qualquer vogal minúscula\n[0-9] corresponde a qualquer dígito\n[a-zA-Z0-9] corresponde a qualquer caractere alfanumérico\nNa maioria dos outros contextos, globbing inclui um terceiro caractere especial, o ?. No entanto, os padrões de globbing do Selenium suportam apenas o asterisco e a classe de caracteres.\nPara especificar um parâmetro de padrão globbing para um comando Selenese, você pode prefixar o padrão com um rótulo glob:. No entanto, já que o padrão globbing é o padrão, você também pode omitir o rótulo e especificar apenas o padrão em si.\nAbaixo está um exemplo de dois comandos que usam padrões globbing. O texto real do link na página que está sendo testada foi \u0026ldquo;Film/Television Department\u0026rdquo;; usando um padrão em vez do texto exato, o comando click funcionará mesmo se o o texto do link for alterado para \u0026ldquo;Film \u0026amp; Television Department\u0026rdquo; ou \u0026ldquo;Film and Television Department\u0026rdquo;. O asterisco do padrão glob corresponderá a \u0026ldquo;qualquer coisa ou nada\u0026rdquo; entre a palavra \u0026ldquo;Film\u0026rdquo; e a palavra \u0026ldquo;Television\u0026rdquo;.\n   Command Target Value     click link=glob:Film*Television Department    verifyTitle glob:*Film*Television*     O título real da página acessada clicando no link era \u0026ldquo;De Anza Film And Television Department - Menu\u0026rdquo;. Usando um padrão em vez do texto exato, o verifyTitle vai passar enquanto as duas palavras \u0026ldquo;Film\u0026rdquo; e \u0026ldquo;Television\u0026rdquo; aparecerem (nessa ordem) em qualquer lugar no título da página. Por exemplo, se o proprietário da página encurtar o título apenas para \u0026ldquo;Film \u0026amp; Television Department\u0026rdquo;, o teste ainda seria aprovado. Usar um padrão para um link e um teste simples de que o link funcionou (como o verifyTitle acima faz) pode reduzir bastante a manutenção de tais casos de teste.\nPadrão de Expressões Regulares Os padrões de expressão regular são os mais poderosos dos três tipos de padrões que o Selenese suporta. Expressões regulares também são suportados pela maioria das linguagens de programação de alto nível, muitos editores de texto e uma série de ferramentas, incluindo utilitários grep, sed e awk da linha de comando Linux / Unix. Em Selenese, padrões de expressão regular permitem que um usuário execute muitas tarefas que iriam ser muito difíceis de outra forma. Por exemplo, suponha que seu teste precise garantir que uma determinada célula da tabela contivesse nada além de um número. regexp:[0-9]+ é um padrão simples que corresponderá a um número decimal de qualquer comprimento.\nEnquanto os padrões de Globbing do Selenese suportam apenas o * e [ ] (classe de caracteres), os padrões de expressão regular Selenese oferecem a mesma ampla gama de caracteres especiais que existem em JavaScript. Abaixo está um subconjunto desses caracteres especiais:\n   PATTERN MATCH     . qualquer caractere isolado   [ ] classe de caracteres: qualquer caractere definido dentros dos colchetes   * quantificação: 0 ou mais do caractere anterior (ou grupo)   + quantificação: 1 ou mais do caractere anterior (ou grupo)   ? quantificação: 0 ou 1 do caractere anterior (ou grupo)   {1,5} quantificação: 1 até 5 repetições do caractere anterior (ou grupo)   | alternação: o caractere/grupo na esquerda OU o caractere/grupo na direita   ( ) agrupamento: normalmente usado com alternação e/ou quantificação    Os padrões de expressão regular em Selenese precisam ser prefixados com regexp: ou regexpi:. O primeiro é sensível a maiúsculas e minúsculas; o último não faz distinção entre maiúsculas e minúsculas.\nAlguns exemplos ajudarão a esclarecer como os padrões de expressão regular podem ser usados com comandos Selenese. O primeiro usa o que é provavelmente o padrão de expressão regular mais comumente usado - .* (\u0026ldquo;ponto estrela\u0026rdquo;). Esta sequência de dois caracteres pode ser traduzida como \u0026ldquo;0 ou mais ocorrências de qualquer caractere\u0026rdquo; ou, mais simplesmente, \u0026ldquo;qualquer coisa ou nada.\u0026rdquo; É o equivalente do padrão globbing de um caractere * (um único asterisco).\n   Command Target Value     click link=glob:Film*Television Department    verifyTitle regexp:.*Film.*Television.*     O exemplo acima é funcionalmente equivalente ao exemplo anterior que usou padrões de globbing para este mesmo teste. As únicas diferenças são o prefixo (regexp: em vez de glob:) e o padrão \u0026ldquo;qualquer coisa ou nada\u0026rdquo; (.* em vez de apenas *).\nO exemplo mais complexo abaixo testa que a página de clima do Yahoo! para Anchorage, Alasca, contém informações sobre o horário do nascer do sol:\n   Command Target Value     open http://weather.yahoo.com/forecast/USAK0012.html    verifyTextPresent regexp:Sunrise: *[0-9]{1,2}:[0-9]{2} [ap]m     Vamos examinar a expressão regular acima em partes:\n         Sunrise: * A string Sunrise: seguida por 0 ou mais espaços   [0-9]{1,2} 1 ou 2 dígitos (para a hora do dia)   : O caractere : (sem caracteres especiais envolvidos)   [0-9]{2} 2 dígitos (para os minutos) seguidos de um espaço   [ap]m \u0026ldquo;a\u0026rdquo; ou \u0026ldquo;p\u0026rdquo; seguido por \u0026ldquo;m\u0026rdquo; (am ou pm)    Padrão Exato O tipo de padrão exato do Selenium é de utilidade marginal. Ele não usa nenhum caractere especial. Então, se você precisasse procurar um caractere de asterisco real (que é especial para globbing e padrões de expressão regular), o padrão exato seria uma maneira fazer isso. Por exemplo, se você quiser selecionar um item rotulado \u0026ldquo;Real*\u0026rdquo; em uma lista suspensa, o código a seguir pode funcionar ou não. O asterisco no padrão glob:Real* irá corresponder a qualquer coisa ou a nada. Portanto, se houvesse uma opção de seleção anterior rotulada \u0026ldquo;Números reais\u0026rdquo;, ser a opção selecionada em vez da opção \u0026ldquo;Real*\u0026quot;.\n   Command Target Value     select //select glob:Real *    A fim de garantir que o item \u0026ldquo;Real*\u0026rdquo; seja selecionado, o prefixo exact: pode ser usado para criar um padrão exato conforme mostrado abaixo:\n   Command Target Value     select //select exact:Real *    Mas o mesmo efeito pode ser alcançado escapando o asterisco em um padrão de expressão regular:\n   Command Target Value     select //select regexp:Real \\*    É bastante improvável que a maioria dos testadores precise procurar um asterisco ou um conjunto de colchetes com caracteres dentro deles (a classe de caracteres para padrões globbing). Assim, os padrões de globbing e os padrões de expressão regular são suficientes para a grande maioria de nós.\nOs comandos \u0026ldquo;AndWait\u0026rdquo; A diferença entre um comando e sua alternativa AndWait é que o comando regular (por exemplo, click) fará a ação e continuará com o seguinte comando o mais rápido possível, enquanto a alternativa AndWait (por exemplo, clickAndWait) diz ao Selenium para esperar que a página carregue após a ação ter sido realizada.\nA alternativa AndWait é sempre usada quando a ação faz com que o navegador navegue para outra página ou recarregue a atual.\nEsteja ciente, se você usar um comando AndWait para uma ação que não aciona uma navegação/atualização, seu teste falhará. Isto acontece porque o Selenium alcançará o timeout de AndWait sem ver nenhuma navegação ou atualização sendo feita, fazendo com que o Selenium lance uma exceção de timeout.\nOs comandos waitFor em aplicações Ajax Em aplicações web orientadas a AJAX, os dados são recuperados do servidor sem atualização da página. Usar os comandos AndWait não funcionará porque a página não é realmente atualizada. Pausar a execução do teste por um determinado período de tempo também não é uma boa abordagem, pois o elemento da web pode aparecer mais tarde ou antes do período estipulado dependendo da capacidade de resposta do sistema, carga ou outros fatores descontrolados do momento, levando a falhas de teste. A melhor abordagem seria esperar pelo elemento necessário em um período dinâmico e então continuar a execução assim que o elemento for encontrado.\nIsso é feito usando comandos waitFor, como waitForElementPresent ou waitForVisible, que espera dinamicamente, verificando a condição desejada a cada segundo e continuando para o próximo comando no script assim que a condição for atendida.\nSequências de avaliação e controle de fluxo Quando um script é executado, ele simplesmente é executado em sequência, um comando após o outro.\nSelenese, por si só, não suporta declarações de condição (if-else, etc.) ou iteração (for, while, etc.). Muitos testes úteis podem ser realizados sem fluxo de controle. No entanto, para um teste funcional de conteúdo dinâmico, possivelmente envolvendo múltiplas páginas, a lógica de programação é frequentemente necessária.\nQuando o controle de fluxo é necessário, existem três opções:\na) Execute o script usando Selenium-RC e uma biblioteca cliente, como Java ou PHP para utilizar os recursos de controle de fluxo da linguagem de programação.\nb) Execute um pequeno fragmento de JavaScript de dentro do script usando o comando storeEval.\nc) Instale a extensão goto_sel_ide.js.\nA maioria dos testadores exportará o script de teste para um arquivo de linguagem de programação que usa a API Selenium-RC (consulte o capítulo Selenium-IDE). No entanto, algumas organizações preferem executar seus scripts a partir do Selenium-IDE sempre que possível (por exemplo, quando eles têm muitas pessoas de nível júnior executando testes para eles, ou quando as habilidades de programação estão em falta). Se este for o seu caso, considere um snippet de JavaScript ou a extensão goto_sel_ide.js.\nComandos de armazenamento e variáveis Selenium Você pode usar variáveis Selenium para armazenar constantes no início de um script. Além disso, quando combinado com um design de teste baseado em dados (discutido em uma seção posterior), as variáveis Selenium podem ser usadas para armazenar valores passados para o seu programa de teste da linha de comando, de outro programa ou de um arquivo.\nO comando store é o mais básico dos muitos comandos de armazenamento e pode ser usado para simplesmente armazenar um valor constante em uma variável Selenium. Leva dois parâmetros, o valor do texto a ser armazenado e uma variável Selenium. Use as convenções de nomenclatura de variável padrão de apenas caracteres alfanuméricos quando escolher um nome para sua variável.\n   Command Target Value     store paul@mysite.org     Posteriormente em seu script, você desejará usar o valor armazenado de sua variável. Para acessar o valor de uma variável, coloque a variável em colchetes ({}) e preceda-a com um cifrão como a seguir.\n   Command Target Value     verifyText //div/p \\${userName}    Um uso comum de variáveis é armazenar a entrada para um campo input.\n   Command Target Value     type id=login \\${userName}    Variáveis Selenium podem ser usadas no primeiro ou segundo parâmetro e são interpretadas pelo Selenium antes de quaisquer outras operações realizadas pelo comando. Uma variável Selenium também pode ser usada em uma expressão de localização.\nExiste um comando de armazenamento equivalente para cada comando de verificação e asserção. Aqui são alguns comandos de armazenamento mais comumente usados.\nstoreElementPresent Isso corresponde a verifyElementPresent. Ele simplesmente armazena um valor booleano - \u0026ldquo;true\u0026rdquo; ou \u0026ldquo;false\u0026rdquo; - dependendo se o elemento de UI for encontrado.\nstoreText StoreText corresponde a verifyText. Ele usa um localizador para identificar um texto específico na página. O texto, se encontrado, é armazenado na variável. StoreText pode ser usado para extrair texto da página que está sendo testada.\nstoreEval Este comando leva um script como seu primeiro parâmetro. A incorporação de JavaScript no Selenese é abordada na próxima seção. StoreEval permite que o teste armazene o resultado da execução do script em uma variável.\nJavaScript e parâmetros Selenese JavaScript pode ser usado com dois tipos de parâmetros Selenese: script e não-script (geralmente expressões). Na maioria dos casos, você deseja acessar e/ou manipular uma variável de caso de teste dentro do snippet JavaScript usado como um parâmetro Selenese. Todas as variáveis criadas em seu caso de teste são armazenadas em um array associativo JavaScript. Uma matriz associativa tem índices de string em vez de índices numéricos sequenciais. A matriz associativa contendo as variáveis do seu caso de teste é chamada storedVars. Sempre que você quiser acessar ou manipular uma variável em um snippet de JavaScript, você deve consultá-la como storedVars[\u0026lsquo;yourVariableName\u0026rsquo;].\nUsando JavaScript com parâmetros de script Vários comandos Selenese especificam um parâmetro script incluindo assertEval, verifyEval, storeEval e waitForEval. Esses parâmetros não requerem sintaxe especial. Um usuário da Selenium-IDE simplesmente colocaria um snippet de código JavaScript no campo apropriado, normalmente o campo Target (porque um parâmetro script é normalmente o primeiro ou único parâmetro).\nO exemplo abaixo ilustra como um snippet de JavaScript pode ser usado para realizar um cálculo numérico simples:\n   Command Target Value     store 10 hits   storeXpathCount //blockquote blockquotes   storeEval storedVars[\u0026lsquo;hits\u0026rsquo;].storedVars[\u0026lsquo;blockquotes\u0026rsquo;] paragraphs    Este próximo exemplo ilustra como um snippet de JavaScript pode incluir chamadas para métodos, neste caso, os métodos toUpperCase e toLowerCasedo objeto JavaScript String.\n   Command Target Value     store Edith Wharton name   storeEval storedVars[\u0026lsquo;name\u0026rsquo;].toUpperCase() uc   storeEval storedVars[\u0026lsquo;name\u0026rsquo;].toUpperCase() lc    Usando JavaScript com parâmetros não-script JavaScript também pode ser usado para ajudar a gerar valores para parâmetros, mesmo quando o parâmetro não é especificado para ser do tipo script. No entanto, neste caso, uma sintaxe especial é necessária - o parâmetro inteiro deve ser prefixado por javascript{ com um } final, que envolve o snippet JavaScript, como em javascript{*yourCodeHere*}. Abaixo está um exemplo em que o segundo parâmetro do comando type\n value - é gerado através do código JavaScript usando esta sintaxe especial:     Command Target Value     store league of nations searchString   type q javascript{storedVars[\u0026lsquo;searchString\u0026rsquo;].toUpperCase()}    echo - O comando de print do Selenese Selenese tem um comando simples que permite imprimir texto para a saída do seu teste. Isso é útil para fornecer notas de progresso informativas em seu teste que são exibidas no console durante a execução. Essas notas também podem ser usadas para fornecer contexto em seus relatórios de resultados de teste, o que pode ser útil para descobrir onde existe um defeito em uma página, caso seu teste encontre um problema. Finalmente, declarações echo podem ser usadas para imprimir o conteúdo de variáveis Selenium.\n   Command Target Value     echo Testing page footer now.    echo Username is \\${userName}     Alertas, Popups e Múltiplas Janelas Suponha que você esteja testando uma página semelhante a esta.\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function output(resultText){ document.getElementById(\u0026#39;output\u0026#39;).childNodes[0].nodeValue=resultText; } function show_confirm(){ var confirmation=confirm(\u0026#34;Chose an option.\u0026#34;); if (confirmation==true){ output(\u0026#34;Confirmed.\u0026#34;); } else{ output(\u0026#34;Rejected!\u0026#34;); } } function show_alert(){ alert(\u0026#34;I\u0026#39;m blocking!\u0026#34;); output(\u0026#34;Alert is gone.\u0026#34;); } function show_prompt(){ var response = prompt(\u0026#34;What\u0026#39;s the best web QA tool?\u0026#34;,\u0026#34;Selenium\u0026#34;); output(response); } function open_window(windowName){ window.open(\u0026#34;newWindow.html\u0026#34;,windowName); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnConfirm\u0026#34; onclick=\u0026#34;show_confirm()\u0026#34; value=\u0026#34;Show confirm box\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnAlert\u0026#34; onclick=\u0026#34;show_alert()\u0026#34; value=\u0026#34;Show alert\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnPrompt\u0026#34; onclick=\u0026#34;show_prompt()\u0026#34; value=\u0026#34;Show prompt\u0026#34; /\u0026gt; \u0026lt;a href=\u0026#34;newWindow.html\u0026#34; id=\u0026#34;lnkNewWindow\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;New Window Link\u0026lt;/a\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnNewNamelessWindow\u0026#34; onclick=\u0026#34;open_window()\u0026#34; value=\u0026#34;Open Nameless Window\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnNewNamedWindow\u0026#34; onclick=\u0026#34;open_window(\u0026#39;Mike\u0026#39;)\u0026#34; value=\u0026#34;Open Named Window\u0026#34; /\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;span id=\u0026#34;output\u0026#34;\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; O usuário deve responder às caixas de alerta / confirmação, bem como mover o foco para as novas janelas pop-up abertas. Felizmente, o Selenium pode cobrir pop-ups de JavaScript.\nMas antes de começarmos a abordar alertas / confirmações / solicitações em detalhes individuais, é útil compreender a semelhança entre eles. Alertas, caixas de confirmação e todos os prompts têm variações do seguinte\n   Command Description     assertFoo(pattern) gera erro se o padrão não corresponder ao texto do pop-up   assertFooPresent gera erro se o pop-up estiver presente   assertFooNotPresent gera um erro se algum pop-up não estiver presente   storeFoo(variable) armazena o texto do pop-up em uma variável   storeFooPresent(variable) armazena o texto do pop-up em uma variável e retorna verdadeiro ou falso    Ao executar no Selenium, pop-ups de JavaScript não aparecerão. Isto é porque as chamadas de função são realmente substituídas em tempo de execução pelo próprio JavaScript do Selenium. No entanto, só porque você não pode ver o pop-up, não significa que você não tem que lidar com isso. Para lidar com um pop-up, você deve chamar sua função assertFoo(padrão). Se você falhar em fazer a asserção da presença de um pop-up, seu próximo comando será bloqueado e você obterá um erro semelhante ao seguinte [error] Error: There was an unexpected Confirmation! [Chose an option.]\nAlertas Vamos começar com alertas porque eles são os pop-ups mais simples de lidar. Para começar, abra o exemplo de HTML acima em um navegador e clique no botão \u0026ldquo;Show alert\u0026rdquo;. Você vai observar que, depois de fechar o alerta, o texto \u0026ldquo;Alert is gone.\u0026rdquo; é exibido na página. Agora execute as mesmas etapas com a gravação da Selenium IDE e verifique que o texto é adicionado após fechar o alerta. Seu teste será parecido com este:\n   Command Target Value     open /    click btnAlert    assertAlert I’m blocking!    verifyTextPresent Alert is gone.     Você pode estar pensando: \u0026ldquo;Isso é estranho, nunca tentei fazer uma asserção nesse alerta.\u0026rdquo; Mas isso é a Selenium-IDE manipulando e fechando o alerta para você. Se você remover essa etapa e repetir o teste você obterá o seguinte erro [error] Error: There was an unexpected Alert! [I'm blocking!]. Você deve incluir uma asserção do alerta para reconhecer sua presença.\nSe você apenas deseja verificar que um alerta está presente, mas não sabe ou não se importa o texto que ele contém, você pode usar assertAlertPresent. Isso retornará verdadeiro ou falso, sendo que falso faz o teste parar.\nConfirmações As confirmações se comportam da mesma forma que os alertas, com assertConfirmation e assertConfirmationPresent oferecendo as mesmas características de suas contrapartes de alerta. No entanto, por padrão, o Selenium selecionará OK quando uma confirmação for exibida. Tente gravar clicando no botão \u0026ldquo;Show confirm box\u0026rdquo; na página de amostra, mas clique no botão \u0026ldquo;Cancel\u0026rdquo; no pop-up e, em seguida, confirme o texto de saída. Seu teste pode ser semelhante a este:\n   Command Target Value     open /    click btnConfirm    chooseCancelOnNextConfirmation     assertConfirmation Choose an option.    verifyTextPresent Rejected     A função chooseCancelOnNextConfirmation diz ao Selenium que todas as seguintes confirmações devem retornar falso. Ela pode ser redefinido chamando chooseOkOnNextConfirmation.\nVocê vai notar que não pode repetir este teste, porque o Selenium reclama que há uma confirmação não tratada. Isso ocorre porque a ordem dos registros de eventos do Selenium-IDE faz com que o clique e chooseCancelOnNextConfirmation sejam colocados na ordem errada (faz sentido se você pensar sobre isso, o Selenium não pode saber que você está cancelando antes de abrir uma confirmação). Simplesmente troque esses dois comandos e seu teste funcionará bem.\nPrompts Os prompts se comportam da mesma forma que os alertas, com assertPrompt e assertPromptPresent oferecendo as mesmas características que suas contrapartes de alerta. Por padrão, o Selenium irá esperar você inserir dados quando o prompt for exibido. Tente gravar clicando no botão \u0026ldquo;Show prompt\u0026rdquo; na página de amostra e digite \u0026ldquo;Selenium\u0026rdquo; no prompt. Seu teste pode ser semelhante a este:\n   Command Target Value     open /    answerOnNextPrompt Selenium!    click id=btnPrompt    assertPrompt What’s the best web QA tool?    verifyTextPresent Selenium!     Se você escolher \u0026ldquo;Cancel\u0026rdquo; no prompt, poderá observar que answerOnNextPrompt simplesmente mostrará um alvo em branco. Selenium trata o cancelamento e uma entrada em branco no prompt basicamente como a mesma coisa.\nDepuração Depurar significa encontrar e corrigir erros em seu caso de teste. Isso é normal e parte do desenvolvimento.\nNão vamos ensinar depuração aqui, pois a maioria dos novos usuários do Selenium já terá alguma experiência básica com depuração. Se isso for novo para você, recomendamos que você pergunte a um dos desenvolvedores em sua organização.\nPontos de interrupção e pontos de começo O Sel-IDE suporta a configuração de pontos de interrupção e a capacidade de iniciar e interromper a execução de um caso de teste, de qualquer ponto dele. Ou seja, você pode executar até um comando específico no meio do caso de teste e inspecionar como o caso de teste se comporta nesse ponto. Para fazer isso, defina um ponto de interrupção no comando imediatamente antes daquele a ser examinado.\nPara definir um ponto de interrupção, selecione um comando, clique com o botão direito e no menu de contexto selecione Alternar ponto de interrupção (Toggle Breakpoint, em inglês). Em seguida, clique no botão Executar para executar seu caso de teste do início ao ponto de interrupção.\nÀs vezes também é útil executar um caso de teste de algum lugar no meio para o final ou até um ponto de interrupção após o ponto de partida. Por exemplo, suponha que seu caso de teste primeiro faz login no site e depois executa uma série de testes e você está tentando depurar um desses testes. No entanto, você só precisa fazer o login uma vez, mas precisa continuar executando novamente o seu teste conforme você o desenvolve. Você pode fazer o login uma vez e, em seguida, executar seu caso de teste de um ponto de início colocado após a parte de login do seu caso de teste. Isso vai evitar que você tenha que fazer logout manualmente sempre que executar novamente.\nPara definir um ponto de partida, selecione um comando, clique com o botão direito e do contexto no menu selecione Definir / Limpar Ponto Inicial (Set/Clear Start Point, em inglês). Em seguida, clique no botão Executar para executar o caso de teste começando naquele ponto inicial.\nAvançando por etapas em um caso de teste Para executar um caso de teste, um comando de cada vez (\u0026ldquo;percorrê-lo\u0026rdquo;), siga estes passos:\n  Inicie o caso de teste em executando com o botão Executar na barra de ferramentas.\n  Pare imediatamente o caso de teste em execução com o botão Pausar.\n  Selecione repetidamente o botão Etapa.\n  Botão Localizar O botão Localizar é usado para ver qual elemento da interface do usuário atualmente exibido página da web (no navegador) é usado no comando Selenium atualmente selecionado. Isso é útil ao construir um localizador para o primeiro parâmetro de um comando (consulte a seção sobre: ref:locators \u0026lt;locators-section\u0026gt; no capítulo Comandos do Selenium). Ele pode ser usado com qualquer comando que identifica um elemento de UI em uma página da web, ou seja, click, clickAndWait, type e certos comandos assert e verify, entre outros.\nNa visualização de Tabela, selecione qualquer comando que tenha um parâmetro localizador. Clique no botão Localizar. Agora olhe na página da web: deve haver um retângulo verde brilhante envolvendo o elemento especificado pelo parâmetro localizador.\nCódigo Fonte da página para depuração Muitas vezes, ao depurar um caso de teste, você simplesmente deve olhar para o código fonte da página (o HTML da página da web que você está tentando testar) para determinar um problema. O Firefox torna isso mais fácil. Simplesmente clique com o botão direito na página da web e selecione \u0026lsquo;Exibir-\u0026gt; Código-fonte da página. O HTML é aberto em uma janela separada. Use seu recurso de pesquisa (Editar =\u0026gt; Encontrar) para procurar uma palavra-chave para encontrar o HTML do elemento de UI que você está tentando testar.\nComo alternativa, selecione apenas a parte da página da web para a qual deseja ver o código fonte. Em seguida, clique com o botão direito na página da web e selecione Exibir Código Fonte da Seleção. Neste caso, a janela HTML separada conterá apenas uma pequena quantidade de código fonte, com destaque na parte que representa a sua seleção.\nAssistência de localizador Sempre que a Selenium-IDE registra um argumento do tipo localizador, ela armazena informações adicionais que permitem ao usuário visualizar outros possíveis argumentos do tipo localizador que podem ser usados em seu lugar. Este recurso pode ser muito útil para aprender mais sobre localizadores e muitas vezes é necessário para ajudar a construir um tipo de localizador diferente do tipo que foi registrado.\nEsta assistência do localizador é apresentada na janela Selenium-IDE como um menu suspenso acessível na extremidade direita do campo Destino (Target, em inglês) (somente quando o campo Destino contém um argumento do tipo localizador registrado). Abaixo está uma captura de tela mostrando o conteúdo desse menu suspenso para um comando. Observe que a primeira coluna do menu suspenso fornece localizadores alternativos, enquanto a segunda coluna indica o tipo de cada alternativa.\nProgramando uma suíte de testes Uma suíte de testes é uma coleção de casos de teste que é exibida no painel mais à esquerda na IDE. O painel da suíte de testes pode ser aberto ou fechado manualmente selecionando um pequeno ponto no meio da borda direita do painel (que é a borda esquerda da janela inteira da Selenium-IDE se o painel estiver fechado).\nO painel da suíte de testes será aberto automaticamente quando uma suíte de testes existente é aberta ou quando o usuário seleciona o item Novo Caso de Teste (New Test Case, em inglês) no menu Arquivo. Neste último caso, o novo caso de teste aparecerá imediatamente abaixo do caso de teste anterior.\nA Selenium-IDE também suporta o carregamento de casos de teste pré-existentes usando Arquivo -\u0026gt; Adicionar Caso de Teste. Isso permite que você adicione casos de teste existentes a um novo conjunto de testes.\nUm arquivo de suíte de testes é um arquivo HTML que contém uma tabela de uma coluna. Cada célula de cada linha na seção  contém um link para um caso de teste. O exemplo abaixo é de um conjunto de testes contendo quatro casos de teste:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Sample Selenium Test Suite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table cellpadding=\u0026#34;1\u0026#34; cellspacing=\u0026#34;1\u0026#34; border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;Test Cases for De Anza A-Z Directory Links\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./a.html\u0026#34;\u0026gt;A Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./b.html\u0026#34;\u0026gt;B Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./c.html\u0026#34;\u0026gt;C Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./d.html\u0026#34;\u0026gt;D Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Observação: os arquivos do caso de teste não devem ser colocados no mesmo local do arquivo do conjunto de testes que os invoca. E em sistemas Mac OS e Linux, esse é realmente o caso. No entanto, no momento em que este livro foi escrito, um bug impedia os usuários do Windows de ser capaz de colocar os casos de teste em outro lugar que não com o conjunto de testes que os invoca.\nExtensões de usuário As extensões de usuário são arquivos JavaScript que permitem criar as suas próprias personalizações e recursos para adicionar funcionalidade adicional. Frequentemente, isso está na forma de comandos personalizados, embora esta extensibilidade não se limite a comandos adicionais.\nExistem várias extensões úteis criadas por usuários.\nIMPORTANTE: ESTA SEÇÃO ESTÁ DESATUALIZADA - REVISAREMOS EM BREVE.\n extensões: http://wiki.openqa.org/display/SEL/Contributed+User-Extensions  Extensão goto_sel_ide.js:\nTalvez a mais popular de todas as extensões da Selenium-IDE é aquela que fornece controle de fluxo na forma de loops while e condicionais primitivas. Esta extensão é a goto_sel_ide.js_. Para um exemplo de como usar a funcionalidade fornecida por esta extensão, veja a página criada pelo autor.\nPara instalar esta extensão, coloque o nome do caminho da extensão em seu computador no campo Selenium Core extensions da Selenium-IDE Opções =\u0026gt; Opções =\u0026gt; Geral.\nDepois de selecionar o botão OK, você deve fechar e reabrir a Selenium-IDE para que o arquivo de extensões seja lido. Qualquer mudança que você fizer em uma extensão também exigirá que você feche e reabra a Selenium-IDE.\nInformações sobre como escrever suas próprias extensões podem ser encontradas perto da parte inferior do documento Selenium Reference.\nÀs vezes, pode ser muito útil depurar passo a passo a Selenium IDE e sua Extensão do usuário. O único depurador que parece capaz de depurar as extensões baseadas em XUL / Chrome é o Venkman, que é suportada no Firefox até a versão 32 (incluída). A depuração passo a passo foi verificada para funcionar com Firefox 32 e Selenium IDE 2.9.0.\nFormato Formato, no menu Opções, permite que você selecione uma linguagem para salvar e exibir o caso de teste. O padrão é HTML.\nSe você for usar Selenium-RC para executar seus casos de teste, este recurso é usado para traduzir seu caso de teste em uma linguagem de programação. Selecione a linguagem, por exemplo Java ou PHP, que você usará com Selenium-RC para o desenvolvimento dos seus programas de teste. Em seguida, simplesmente salve o caso de teste usando Arquivo =\u0026gt; Exportar Caso de Teste Como. Seu caso de teste será traduzido para uma série de funções na linguagem que você escolher. Essencialmente, o código do programa que suporta o seu teste é gerado para você por Selenium-IDE.\nAlém disso, observe que se o código gerado não atender às suas necessidades, você pode alterar editando um arquivo de configuração que define o processo de geração. Cada linguagem com suporte possui definições de configuração que podem ser editadas. Isto está em Opções =\u0026gt; Opções =\u0026gt; Formatos.\nExecutando testes da Selenium-IDE em diferentes navegadores Embora o Selenium-IDE só possa executar testes no Firefox, os testes desenvolvidos com Selenium-IDE podem ser executados em outros navegadores, usando uma interface de linha de comando simples que invoca o servidor Selenium-RC. Este tópico é abordado na seção: ref: Executar testes Selenese \u0026lt;html-suite\u0026gt; no capítulo Selenium-RC. A opção de linha de comando -htmlSuite é o recurso específico de interesse.\nSolução de problemas Abaixo está uma lista de pares de imagem / explicação que descrevem fontes de problemas com Selenium-IDE:\nTable view is not available with this format.\nEsta mensagem pode ser exibida ocasionalmente na guia Tabela quando a Selenium IDE é lançada. A solução alternativa é fechar e reabrir a Selenium IDE. Veja a issue 1008. Para maiores informações. Se você é capaz de reproduzir isso de forma confiável, por favor forneça detalhes para que possamos trabalhar em uma correção.\n error loading test case: no command found\nVocê usou File =\u0026gt; Open para tentar abrir um arquivo de suíte de testes. Use File =\u0026gt; Open Test Suite em vez disso.\nUma solicitação de aprimoramento foi levantada para melhorar esta mensagem de erro. Veja a issue 1010.\n Este tipo de erro pode indicar um problema de tempo, ou seja, o elemento especificado por um localizador em seu comando não foi totalmente carregado quando o comando foi executado. Tente colocar um pause 5000 antes do comando para determinar se o problema está realmente relacionado ao tempo. Em caso afirmativo, investigue usando um comando waitFor* ou *AndWait apropriado antes do comando com falha.\n Sempre que sua tentativa de usar a substituição de variável falha, como é o caso para o comando open acima, isso indica que você não criou realmente a variável cujo valor você está tentando acessar. Isto é às vezes devido a colocar a variável no campo Valor quando deve estar no campo Destino ou vice-versa. No exemplo acima, os dois parâmetros para o comando store foram erroneamente colocados na ordem inversa do que é necessário. Para qualquer comando Selenese, o primeiro parâmetro obrigatório deve ir no campo Destino e o segundo parâmetro obrigatório (se houver) deve ir no campo Valor.\n error loading test case: [Exception\u0026hellip; \u0026ldquo;Component returned failure code: 0x80520012 (NS_ERROR_FILE_NOT_FOUND) [nsIFileInputStream.init]\u0026rdquo; nresult: \u0026ldquo;0x80520012 (NS_ERROR_FILE_NOT_FOUND)\u0026rdquo; location: \u0026ldquo;JS frame :: chrome://selenium-ide/content/file-utils.js :: anonymous :: line 48\u0026rdquo; data: no]\nUm dos casos de teste em seu conjunto de testes não pode ser encontrado. Certifique-se de que o caso de teste está realmente localizado onde o conjunto de testes indica que ele está localizado. Além disso, certifique-se de que seus arquivos de caso de teste tenham a extensão .html em seus nomes de arquivo e no arquivo de suíte de testes onde são referenciados.\nUma solicitação de aprimoramento foi levantada para melhorar esta mensagem de erro. Veja a issue 1011.\n O conteúdo do seu arquivo de extensão não foi lido pela Selenium-IDE. Certifique-se de ter especificado o nome do caminho adequado para o arquivo de extensões via Options =\u0026gt; Options =\u0026gt; General no campo Selenium Core extensions. Além disso, a Selenium-IDE deve ser reiniciada após qualquer alteração em um arquivo de extensões ou no conteúdo do campo Selenium Core extensions.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/mock_external_services/","title":"Simulação de serviços externos","tags":[],"description":"","content":"Eliminar as dependências de serviços externos melhorará muito a velocidade e estabilidade de seus testes.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/introduction/about_this_documentation/","title":"Sobre esta documentação","tags":[],"description":"","content":"Essa documentação, como o próprio código, são mantidos 100% por voluntários dentro da comunidade Selenium. Muitos têm usado desde o seu início, mas muitos mais o usam há pouco tempo, e dedicaram seu tempo para ajudar a melhorar a experiência de integração para novos usuários.\nSe houver algum problema com a documentação, queremos saber! A melhor maneira de comunicar um problema é visitar https://github.com/seleniumhq/seleniumhq.github.io/issues e pesquise se o problema já foi ou não arquivado. Se não, fique à vontade para abrir um!\nMuitos membros da comunidade frequentam o canal IRC #selenium em irc.freenode.net. Sinta-se à vontade para entrar e fazer perguntas e se você receber ajuda que você acha que poderia ser útil nessa documentação, certifique-se de adicionar sua contribuição! Podemos atualizar essa documentação, mas é muito mais fácil para todos quando recebemos contribuições de fora dos committers normais.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/support_classes/","title":"Classes de suporte","tags":[],"description":"","content":"As classes de suporte do WebDriver são fornecidas para simplificar a manutenção do seu código. Eles fornecem uma boa abstração para fazer a modelagem de elemento(s) HTML como objetos de domínio mais fáceis, também fornecendo métodos auxiliares para tornar o uso de tais objetos fácil de se pensar. Vamos aprender sobre:\n Estratégias de localizador Eventos LoadableComponent ThreadGuard etc.  Vamos começar:\nThreadGuard  Esta classe está disponível apenas no Java Binding\n ThreadGuard verifica se um driver é chamado apenas da mesma thread que o criou. Problemas de threading, especialmente durante a execução de testes em paralelo, podem ter erros misteriosos e difíceis de diagnosticar. Usar este wrapper evita esta categoria de erros e gerará uma exceção quando isso acontecer.\nO exemplo a seguir simula um conflito de threads:\npublic class DriverClash { //thread main (id 1) criou este driver  private WebDriver protectedDriver = ThreadGuard.protect(new ChromeDriver()); static { System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;\u0026lt;Set path to your Chromedriver\u0026gt;\u0026#34;); } //Thread-1 (id 24) está chamando o mesmo driver causando o conflito  Runnable r1 = () -\u0026gt; {protectedDriver.get(\u0026#34;https://selenium.dev\u0026#34;);}; Thread thr1 = new Thread(r1); void runThreads(){ thr1.start(); } public static void main(String[] args) { new DriverClash().runThreads(); } } O resultado mostrado abaixo:\nException in thread \u0026#34;Thread-1\u0026#34; org.openqa.selenium.WebDriverException: Thread safety error; this instance of WebDriver was constructed on thread main (id 1)and is being accessed by thread Thread-1 (id 24) This is not permitted and *will* cause undefined behaviour Conforme visto no exemplo:\n protectedDriver será criado no tópico principal Usamos Java Runnable para ativar um novo processo e uma nova Thread para executar o processo Ambas as Threads entrarão em conflito porque a thread principal não tem protectedDriver em sua memória. ThreadGuard.protect lançará uma exceção.  Nota: Isso não substitui a necessidade de usar ThreadLocal para gerenciar drivers durante a execução em paralelo.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/worst_practices/test_dependency/","title":"Dependência entre testes","tags":[],"description":"","content":"Uma ideia comum e um equívoco sobre o teste automatizado é sobre uma ordem de testes específica. Seus testes devem ser executados em qualquer ordem, e não depender da conclusão de outros testes para ter sucesso.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/improved_reporting/","title":"Relatórios melhorados","tags":[],"description":"","content":"O Selenium não foi projetado para relatar sobre o status de casos de teste. Aproveitar os recursos de relatórios integrados de frameworks de teste unitários é um bom começo. A maioria dos frameworks de teste unitários podem gerar relatórios formatados em xUnit ou HTML. Relatórios xUnit são populares para importar resultados para um servidor de integração contínua (CI) como Jenkins, Travis, Bamboo, etc. Aqui estão alguns links para obter mais informações sobre resultados de relatórios em vários idiomas.\nNUnit 3 Console Runner\nNUnit 3 Console Command Line\nxUnit getting test results in TeamCity\nxUnit getting test results in CruiseControl.NET\nxUnit getting test results in Azure DevOps\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/legacy_docs/remote_webdriver_server/","title":"Servidor do WebDriver remoto","tags":[],"description":"","content":"O servidor sempre será executado na máquina com o navegador que você deseja testar. O servidor pode ser usado a partir da linha de comando ou por meio de configuração de código.\nIniciando o servidor a partir da linha de comando Depois de fazer o download do selenium-server-standalone-{VERSION}.jar, coloque-o no computador com o navegador que deseja testar. Então, a partir do diretório com o jar, execute o seguinte:\njava -jar selenium-server-standalone-{VERSION}.jar Considerações para executar o servidor O chamador deve encerrar cada sessão adequadamente, chamando ou Selenium#stop() ou WebDriver#quit.\nO selenium-server mantém registros na memória para cada sessão em andamento, que são apagados quando Selenium#stop() ou WebDriver#quit é chamado. E se você se esquecer de encerrar essas sessões, seu servidor pode vazar memória. E se você mantém sessões de duração extremamente longa, você provavelmente precisará parar / sair de vez em quando (ou aumentar a memória com a opção -Xmx jvm).\nTimeouts (a partir da versão 2.21) O servidor tem dois timeouts diferentes, que podem ser definidos da seguinte forma:\njava -jar selenium-server-standalone-{VERSION}.jar -timeout=20 -browserTimeout=60  browserTimeout  Controla por quanto tempo o navegador pode travar (valor em segundos).   timeout  Controla por quanto tempo o cliente pode ficar fora antes que a sessão seja recuperada (valor em segundos).    A propriedade do sistema selenium.server.session.timeout não é mais compatível a partir da versão 2.21.\nObserve que o browserTimeout destina-se a ser um mecanismo de timeout de backup quando o mecanismo de timeout comum falha, e deve ser usado principalmente em ambientes de Grid / servidor para garantir que processos travados / perdidos não permaneçam por muito tempo poluindo o ambiente de execução.\nConfigurando o servidor programaticamente Em teoria, o processo é tão simples quanto mapear o DriverServlet para uma URL, mas também é possível hospedar a página em um formato leve de container, como Jetty, configurado inteiramente em código.\n Baixe o selenium-server.zip e descompacte. Coloque os JARs no CLASSPATH. Crie uma nova classe chamada AppServer. Aqui, estamos usando Jetty, então você precisará baixar isso também:  import org.mortbay.jetty.Connector; import org.mortbay.jetty.Server; import org.mortbay.jetty.nio.SelectChannelConnector; import org.mortbay.jetty.security.SslSocketConnector; import org.mortbay.jetty.webapp.WebAppContext; import javax.servlet.Servlet; import java.io.File; import org.openqa.selenium.remote.server.DriverServlet; public class AppServer { private Server server = new Server(); public AppServer() throws Exception { WebAppContext context = new WebAppContext(); context.setContextPath(\u0026#34;\u0026#34;); context.setWar(new File(\u0026#34;.\u0026#34;)); server.addHandler(context); context.addServlet(DriverServlet.class, \u0026#34;/wd/*\u0026#34;); SelectChannelConnector connector = new SelectChannelConnector(); connector.setPort(3001); server.addConnector(connector); server.start(); } } "},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/","title":"WebDriver","tags":[],"description":"","content":"WebDriver O WebDriver manipula um navegador nativamente, como um usuário faria, seja localmente ou em uma máquina remota usando o servidor Selenium, marca um salto em termos de automação do navegador.\nSelenium WebDriver refere-se a ambas as ligações de linguagem e as implementações do código de controle do navegador individual. Isso é comumente referido como apenas WebDriver.\nSelenium WebDriver é uma recomendação W3C\n  WebDriver é projetado como uma interface de programação simples e mais concisa.\n  WebDriver é uma API compacta orientada a objetos.\n  Ele manipula o navegador de forma eficaz.\n  "},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/js_alerts_prompts_and_confirmations/","title":"Alertas, prompts e confirmações JavaScript","tags":[],"description":"","content":"WebDriver fornece uma API para trabalhar com os três tipos nativos de mensagens pop-up oferecidas pelo JavaScript. Esses pop-ups são estilizados pelo navegador e oferecem personalização limitada.\nAlertas O mais simples deles é referido como um alerta, que mostra um mensagem personalizada e um único botão que dispensa o alerta, rotulado na maioria dos navegadores como OK. Ele também pode ser dispensado na maioria dos navegadores pressionando o botão Fechar, mas isso sempre fará a mesma coisa que o botão OK. Veja um exemplo de alerta .\nO WebDriver pode obter o texto do pop-up e aceitar ou dispensar esses alertas.\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See an example alert\u0026#34;)).click(); //Wait for the alert to be displayed and store it in a variable Alert alert = wait.until(ExpectedConditions.alertIsPresent()); //Store the alert text in a variable String text = alert.getText(); //Press the OK button alert.accept();   # Click the link to activate the alert driver.find_element(By.LINK_TEXT, \u0026#34;See an example alert\u0026#34;).click() # Wait for the alert to be displayed and store it in a variable alert = wait.until(expected_conditions.alert_is_present()) # Store the alert text in a variable text = alert.text # Press the OK button alert.accept()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See an example alert\u0026#34;)).Click(); //Wait for the alert to be displayed and store it in a variable IAlert alert = wait.Until(ExpectedConditions.AlertIsPresent()); //Store the alert text in a variable string text = alert.Text; //Press the OK button alert.Accept();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See an example alert\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Store the alert text in a variable alert_text = alert.text # Press on OK button alert.accept   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See an example alert\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Store the alert text in a variable let alertText = await alert.getText(); //Press the OK button await alert.accept(); // Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See an example alert\u0026#34;)).click() //Wait for the alert to be displayed and store it in a variable val alert = wait.until(ExpectedConditions.alertIsPresent()) //Store the alert text in a variable val text = alert.getText() //Press the OK button alert.accept()     Confirmação Uma caixa de confirmação é semelhante a um alerta, exceto que o usuário também pode escolher cancelar a mensagem. Veja uma amostra de confirmação .\nEste exemplo também mostra uma abordagem diferente para armazenar um alerta:\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample confirm\u0026#34;)).click(); //Wait for the alert to be displayed wait.until(ExpectedConditions.alertIsPresent()); //Store the alert in a variable Alert alert = driver.switchTo().alert(); //Store the alert in a variable for reuse String text = alert.getText(); //Press the Cancel button alert.dismiss();   # Click the link to activate the alert driver.find_element(By.LINK_TEXT, \u0026#34;See a sample confirm\u0026#34;).click() # Wait for the alert to be displayed wait.until(expected_conditions.alert_is_present()) # Store the alert in a variable for reuse alert = driver.switch_to.alert # Store the alert text in a variable text = alert.text # Press the Cancel button alert.dismiss()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See a sample confirm\u0026#34;)).Click(); //Wait for the alert to be displayed wait.Until(ExpectedConditions.AlertIsPresent()); //Store the alert in a variable IAlert alert = driver.SwitchTo().Alert(); //Store the alert in a variable for reuse string text = alert.Text; //Press the Cancel button alert.Dismiss();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See a sample confirm\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Store the alert text in a variable alert_text = alert.text # Press on Cancel button alert.dismiss   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See a sample confirm\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Store the alert text in a variable let alertText = await alert.getText(); //Press the Cancel button await alert.dismiss(); // Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample confirm\u0026#34;)).click() //Wait for the alert to be displayed wait.until(ExpectedConditions.alertIsPresent()) //Store the alert in a variable val alert = driver.switchTo().alert() //Store the alert in a variable for reuse val text = alert.text //Press the Cancel button alert.dismiss()     Prompt Os prompts são semelhantes às caixas de confirmação, exceto que também incluem um texto de entrada. Semelhante a trabalhar com elementos de formulário, você pode usar o sendKeys do WebDriver para preencher uma resposta. Isso substituirá completamente o espaço de texto de exemplo. Pressionar o botão Cancelar não enviará nenhum texto. Veja um exemplo de prompt .\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample prompt\u0026#34;)).click(); //Wait for the alert to be displayed and store it in a variable Alert alert = wait.until(ExpectedConditions.alertIsPresent()); //Type your message alert.sendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button alert.accept();   # Click the link to activate the alert driver.find_element(By.LINK_TEXT, \u0026#34;See a sample prompt\u0026#34;).click() # Wait for the alert to be displayed wait.until(expected_conditions.alert_is_present()) # Store the alert in a variable for reuse alert = Alert(driver) # Type your message alert.send_keys(\u0026#34;Selenium\u0026#34;) # Press the OK button alert.accept()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See a sample prompt\u0026#34;)).Click(); //Wait for the alert to be displayed and store it in a variable IAlert alert = wait.Until(ExpectedConditions.AlertIsPresent()); //Type your message alert.SendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button alert.Accept();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See a sample prompt\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Type a message alert.send_keys(\u0026#34;selenium\u0026#34;) # Press on Ok button alert.accept   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See a sample prompt\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Type your message await alert.sendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button await alert.accept(); //Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample prompt\u0026#34;)).click() //Wait for the alert to be displayed and store it in a variable val alert = wait.until(ExpectedConditions.alertIsPresent()) //Type your message alert.sendKeys(\u0026#34;Selenium\u0026#34;) //Press the OK button alert.accept()     "},{"uri":"https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/avoid_sharing_state/","title":"Evite compartilhamento de estado","tags":[],"description":"","content":"Embora mencionado em vários lugares, vale a pena mencionar novamente. Garanta que os testes são isolados uns dos outros.\n  Não compartilhe dados de teste. Imagine vários testes em que cada um consulta o banco de dados para pedidos válidos antes de escolher um para executar uma ação. Caso dois testes peguem a mesma ordem, provavelmente você obterá um comportamento inesperado.\n  Limpe dados desatualizados no aplicativo que podem ser obtidos por outro teste, por exemplo registros de pedidos inválidos.\n  Crie uma nova instância do WebDriver por teste. Isso ajuda a garantir o isolamento do teste e torna a paralelização mais simples.\n  "},{"uri":"https://www.selenium.dev/documentation/pt-br/worst_practices/performance_testing/","title":"Teste de performance/desempenho","tags":[],"description":"","content":"Teste de desempenho usando Selenium e WebDriver geralmente não é recomendado. Não porque é incapaz, mas porque não é otimizado para o trabalho e é improvável que você obtenha bons resultados.\nPode parecer ideal para teste de desempenho no contexto do usuário, mas um conjunto de testes WebDriver estão sujeitos a muitos pontos de fragilidade externa e interna que estão além do seu controle; por exemplo, velocidade de inicialização do navegador, velocidade dos servidores HTTP, resposta de servidores de terceiros que hospedam JavaScript ou CSS, e a penalidade de instrumentação da própria implementação do WebDriver. A variação nesses pontos causará variação em seus resultados. É difícil separar a diferença entre o desempenho do seu site e o desempenho de recursos externos, e também é difícil dizer qual é a penalidade de desempenho para usar WebDriver no navegador, especialmente se você estiver injetando scripts.\nA outra atração potencial é \u0026ldquo;economizar tempo\u0026rdquo; - execução de testes funcionais e de desempenho ao mesmo tempo. No entanto, os testes funcionais e de desempenho têm objetivos opostos. Para testar a funcionalidade, um testador pode precisar ser paciente e aguarde o carregamento, mas isso irá turvar os resultados do teste de desempenho e vice-versa.\nPara melhorar o desempenho do seu site, você precisará ser capaz de analisar o desempenho geral independente das diferenças de ambiente, identificar práticas de código ruins, repartição do desempenho de recursos individuais (ou seja, CSS ou JavaScript), para saber o que melhorar. Existem ferramentas de teste de desempenho disponíveis que podem fazer este trabalho, que fornecem relatórios e análises, e podem até fazer sugestões de melhorias.\nPacotes de exemplo (código aberto) a serem usados ​​são: JMeter\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/support_packages/working_with_cookies/","title":"Trabalhando com cookies","tags":[],"description":"","content":"Um cookie é um pequeno pedaço de dado enviado de um site e armazenado no seu computador. Os cookies são usados principalmente para reconhecer o usuário e carregar as informações armazenadas.\nA API WebDriver fornece uma maneira de interagir com cookies com métodos integrados:\nAdd Cookie É usado para adicionar um cookie ao contexto de navegação atual. Add Cookie aceita apenas um conjunto de objetos JSON serializáveis definidos. Aqui  é o link para a lista de valores-chave JSON aceitos.\nEm primeiro lugar, você precisa estar no domínio para qual o cookie será valido. Se você está tentando predefinir cookies antes de começar a interagir com um site e sua página inicial é grande / demora um pouco para carregar uma alternativa é encontrar uma página menor no site (normalmente a página 404 é pequena, por exemplo http://example.com/some404page)\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class addCookie { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); // Adds the cookie into current browser context  driver.manage().addCookie(new Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() driver.get(\u0026#34;http://www.example.com\u0026#34;) # Adds the cookie into current browser context driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;})   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace AddCookie { class AddCookie { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Adds the cookie into current browser context  driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; # Adds the cookie into current browser context driver.manage.add_cookie(name: \u0026#34;key\u0026#34;, value: \u0026#34;value\u0026#34;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // set a cookie on the current domain  await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;}); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Adds the cookie into current browser context  driver.manage().addCookie(Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)) } finally { driver.quit() } }     Get Named Cookie Retorna os dados do cookie serializado correspondentes ao nome do cookie entre todos os cookies associados.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class getCookieNamed { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  Cookie cookie1 = driver.manage().getCookieNamed(\u0026#34;foo\u0026#34;); System.out.println(cookie1); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) # Adds the cookie into current browser context driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;bar\u0026#34;}) # Get cookie details with named cookie \u0026#39;foo\u0026#39; print(driver.get_cookie(\u0026#34;foo\u0026#34;))   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace GetCookieNamed { class GetCookieNamed { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  var cookie = driver.Manage().Cookies.GetCookieNamed(\u0026#34;foo\u0026#34;); System.Console.WriteLine(cookie); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;foo\u0026#34;, value: \u0026#34;bar\u0026#34;) # Get cookie details with named cookie \u0026#39;foo\u0026#39; puts driver.manage.cookie_named(\u0026#39;foo\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // set a cookie on the current domain  await driver.manage().addCookie({name:\u0026#39;foo\u0026#39;, value: \u0026#39;bar\u0026#39;}); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  driver.manage().getCookie(\u0026#39;foo\u0026#39;).then(function (cookie) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookie); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)) // Get cookie details with named cookie \u0026#39;foo\u0026#39;  val cookie = driver.manage().getCookieNamed(\u0026#34;foo\u0026#34;) println(cookie) } finally { driver.quit() } }     Get All Cookies Retorna \u0026lsquo;dados de cookie serializados com sucesso\u0026rsquo; para o contexto de navegação atual. Se o navegador não estiver mais disponível, ele retornará um erro.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; import java.util.Set; public class getAllCookies { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); // Add few cookies  driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Get All available cookies  Set\u0026lt;Cookie\u0026gt; cookies = driver.manage().getCookies(); System.out.println(cookies); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Get all available cookies print(driver.get_cookies())   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace GetAllCookies { class GetAllCookies { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Get All available cookies  var cookies = driver.Manage().Cookies.AllCookies; } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # Get all available cookies puts driver.manage.all_cookies ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Add few cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Get all Available cookies  driver.manage().getCookies().then(function (cookies) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookies); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)) driver.manage().addCookie(Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)) // Get All available cookies  val cookies = driver.manage().cookies println(cookies) } finally { driver.quit() } }     Delete Cookie Exclui os dados do cookie que correspondem ao nome do cookie fornecido.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class deleteCookie { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); Cookie cookie1 = new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;); driver.manage().addCookie(cookie1); // delete a cookie with name \u0026#39;test1\u0026#39;  driver.manage().deleteCookieNamed(\u0026#34;test1\u0026#34;); /* Selenium Java bindings also provides a way to delete cookie by passing cookie object of current browsing context */ driver.manage().deleteCookie(cookie1); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Delete a cookie with name \u0026#39;test1\u0026#39; driver.delete_cookie(\u0026#34;test1\u0026#34;)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace DeleteCookie { class DeleteCookie { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); var cookie = new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;); driver.Manage().Cookies.AddCookie(cookie); // delete a cookie with name \u0026#39;test1\u0026#39;\t driver.Manage().Cookies.DeleteCookieNamed(\u0026#34;test1\u0026#34;); // Selenium .net bindings also provides a way to delete  // cookie by passing cookie object of current browsing context  driver.Manage().Cookies.DeleteCookie(cookie); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # delete a cookie with name \u0026#39;test1\u0026#39; driver.manage.delete_cookie(\u0026#39;test1\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Add few cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Delete a cookie with name \u0026#39;test1\u0026#39;  await driver.manage().deleteCookie(\u0026#39;test1\u0026#39;); // Get all Available cookies  driver.manage().getCookies().then(function (cookies) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookies); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)) val cookie1 = Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;) driver.manage().addCookie(cookie1) // delete a cookie with name \u0026#39;test1\u0026#39;  driver.manage().deleteCookieNamed(\u0026#34;test1\u0026#34;) // delete cookie by passing cookie object of current browsing context.  driver.manage().deleteCookie(cookie1) } finally { driver.quit() } }     Delete All Cookies Exclui todos os cookies do contexto de navegação atual.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class deleteAllCookies { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // deletes all cookies  driver.manage().deleteAllCookies(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Deletes all cookies driver.delete_all_cookies()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace DeleteAllCookies { class DeleteAllCookies { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // deletes all cookies  driver.Manage().Cookies.DeleteAllCookies(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # deletes all cookies driver.manage.delete_all_cookies ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Add few cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Delete all cookies  await driver.manage().deleteAllCookies(); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)) driver.manage().addCookie(Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)) // deletes all cookies  driver.manage().deleteAllCookies() } finally { driver.quit() } }     Same-Site Cookie Attribute Permite que um usuário instrua os navegadores a controlar se os cookies são enviados junto com a solicitação iniciada por sites de terceiros. É usado para evitar ataques CSRF (Cross-Site Request Forgery).\nO atributo de cookie Same-Site aceita dois parâmetros como instruções\nStrict: Quando o atributo sameSite é definido como Strict, o cookie não será enviado junto com solicitações iniciadas por sites de terceiros.\nLax: Quando você define um atributo cookie sameSite como Lax, o cookie será enviado junto com uma solicitação GET iniciada por um site de terceiros.\nNota: a partir de agora, esse recurso está disponível no Chrome (versão 80+), Firefox (versão 79+) e funciona com Selenium 4 e versões posteriores.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class cookieTest { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); Cookie cookie = new Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Strict\u0026#34;).build(); Cookie cookie1 = new Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Lax\u0026#34;).build(); driver.manage().addCookie(cookie); driver.manage().addCookie(cookie1); System.out.println(cookie.getSameSite()); System.out.println(cookie1.getSameSite()); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() driver.get(\u0026#34;http://www.example.com\u0026#34;) # Adds the cookie into current browser context with sameSite \u0026#39;Strict\u0026#39; (or) \u0026#39;Lax\u0026#39; driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;, \u0026#39;sameSite\u0026#39;: \u0026#39;Strict\u0026#39;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;, \u0026#39;sameSite\u0026#39;: \u0026#39;Lax\u0026#39;}) cookie1 = driver.get_cookie(\u0026#39;foo\u0026#39;) cookie2 = driver.get_cookie(\u0026#39;foo1\u0026#39;) print(cookie1) print(cookie2)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace SameSiteCookie { class SameSiteCookie { static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { driver.Navigate().GoToUrl(\u0026#34;http://www.example.com\u0026#34;); var cookie1Dictionary = new System.Collections.Generic.Dictionary\u0026lt;string, object\u0026gt;() { { \u0026#34;name\u0026#34;, \u0026#34;test1\u0026#34; }, { \u0026#34;value\u0026#34;, \u0026#34;cookie1\u0026#34; }, { \u0026#34;sameSite\u0026#34;, \u0026#34;Strict\u0026#34; } }; var cookie1 = Cookie.FromDictionary(cookie1Dictionary); var cookie2Dictionary = new System.Collections.Generic.Dictionary\u0026lt;string, object\u0026gt;() { { \u0026#34;name\u0026#34;, \u0026#34;test2\u0026#34; }, { \u0026#34;value\u0026#34;, \u0026#34;cookie2\u0026#34; }, { \u0026#34;sameSite\u0026#34;, \u0026#34;Lax\u0026#34; } }; var cookie2 = Cookie.FromDictionary(cookie2Dictionary); driver.Manage().Cookies.AddCookie(cookie1); driver.Manage().Cookies.AddCookie(cookie2); System.Console.WriteLine(cookie1.SameSite); System.Console.WriteLine(cookie2.SameSite); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; # Adds the cookie into current browser context with sameSite \u0026#39;Strict\u0026#39; (or) \u0026#39;Lax\u0026#39; driver.manage.add_cookie(name: \u0026#34;foo\u0026#34;, value: \u0026#34;bar\u0026#34;, same_site: \u0026#34;Strict\u0026#34;) driver.manage.add_cookie(name: \u0026#34;foo1\u0026#34;, value: \u0026#34;bar\u0026#34;, same_site: \u0026#34;Lax\u0026#34;) puts driver.manage.cookie_named(\u0026#39;foo\u0026#39;) puts driver.manage.cookie_named(\u0026#39;foo1\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // set a cookie on the current domain with sameSite \u0026#39;Strict\u0026#39; (or) \u0026#39;Lax\u0026#39;  await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;, sameSite:\u0026#39;Strict\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;, sameSite:\u0026#39;Lax\u0026#39;}); console.log(await driver.manage().getCookie(\u0026#39;key\u0026#39;)); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;http://www.example.com\u0026#34;) val cookie = Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Strict\u0026#34;).build() val cookie1 = Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Lax\u0026#34;).build() driver.manage().addCookie(cookie) driver.manage().addCookie(cookie1) println(cookie.getSameSite()) println(cookie1.getSameSite()) } finally { driver.quit() } }     "},{"uri":"https://www.selenium.dev/documentation/pt-br/remote_webdriver/","title":"WebDriver Remoto","tags":[],"description":"","content":"WebDriver Remoto Você pode usar o WebDriver remotamente da mesma forma que o usaria localmente. A principal diferença é que um WebDriver remoto precisa ser configurado para que possa executar seus testes em uma máquina separada.\nUm WebDriver remoto é composto por duas peças: um cliente e um servidor. O cliente é o seu teste WebDriver e o servidor é simplesmente um Servlet Java, que pode ser hospedado em qualquer servidor de aplicativo JEE moderno.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/","title":"Diretrizes e recomendações","tags":[],"description":"","content":"Diretrizes e recomendações Uma nota sobre \u0026ldquo;Melhores práticas\u0026rdquo;: evitamos intencionalmente a frase \u0026ldquo;Melhores Práticas\u0026rdquo; nesta documentação. Nenhuma abordagem funciona para todas as situações. Preferimos a ideia de \u0026ldquo;Diretrizes e Recomendações\u0026rdquo;. Nós encorajamos que você leia e decida cuidadosamente quais abordagens funcionarão para você em seu ambiente específico.\nO teste funcional é difícil de acertar por muitos motivos. Como se o estado, a complexidade e as dependências do aplicativo não tornassem o teste suficientemente difícil, lidar com navegadores (especialmente com incompatibilidades entre navegadores) torna a escrita de bons testes um desafio.\nSelenium fornece ferramentas para facilitar a interação funcional do usuário, mas não o ajuda a escrever suítes de teste bem arquitetadas. Neste capítulo, oferecemos conselhos, diretrizes e recomendações sobre como abordar a automação funcional de páginas da web.\nEste capítulo registra os padrões de design de software populares entre muitos dos usuários do Selenium que tiveram sucesso ao longo dos anos.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/test_independency/","title":"Independência de Testes","tags":[],"description":"","content":"Escreva cada teste como sua própria unidade. Escreva os testes de uma forma que não seja dependente de outros testes para concluir:\nDigamos que existe um sistema de gerenciamento de conteúdo com o qual você pode criar algum conteúdo personalizado que então aparece em seu site como um módulo após publicação, e pode levar algum tempo para sincronizar entre o CMS e a aplicação.\nUma maneira errada de testar seu módulo é que o conteúdo seja criado e publicado em um teste e, em seguida, verificar o módulo em outro teste. Este teste não é viável, pois o conteúdo pode não estar disponível imediatamente para o outro teste após a publicação.\nEm vez disso, você pode criar um conteúdo stub que pode ser ligado e desligado dentro do teste e use-o para validar o módulo. Contudo, para a criação de conteúdo, você ainda pode ter um teste separado.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/worst_practices/link_spidering/","title":"Navegação por links","tags":[],"description":"","content":"Usar o WebDriver para navegar por links não é uma prática recomendada. Não porque não pode ser feito, mas porque WebDriver definitivamente não é a ferramenta ideal para isso. O WebDriver precisa de tempo para inicializar, e pode levar vários segundos, até um minuto dependendo de como seu teste é escrito, apenas para chegar à página e atravessar o DOM.\nEm vez de usar o WebDriver para isso, você poderia economizar muito tempo executando um comando curl, ou usando uma biblioteca como BeautifulSoup uma vez que esses métodos não dependem em criar um navegador e navegar para uma página. Você está economizando muito tempo por não usar o WebDriver para essa tarefa.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/http_proxies/","title":"Proxies Http","tags":[],"description":"","content":"Um servidor proxy atua como intermediário para solicitações entre um cliente e um servidor. De forma simples, o tráfego flui através do servidor proxy a caminho do endereço que você solicitou e de volta.\nUm servidor proxy para scripts de automação com Selenium pode ser útil para:\n Capturar o tráfego da rede Simular chamadas de back-end feitas pelo site Acessar o site necessário em uma rede complexa topologias ou restrições / políticas corporativas estritas.  Se você estiver em um ambiente corporativo, e um navegador não consegue se conectar a um URL, isso é provavelmente porque o ambiente precisa de um proxy para ser acessado.\nO Selenium WebDriver fornece uma maneira de configurações de proxy:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.Proxy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.chrome.ChromeOptions; public class proxyTest { public static void main(String[] args) { Proxy proxy = new Proxy(); proxy.setHttpProxy(\u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34;); ChromeOptions options = new ChromeOptions(); options.setCapability(\u0026#34;proxy\u0026#34;, proxy); WebDriver driver = new ChromeDriver(options); driver.get(\u0026#34;https://www.google.com/\u0026#34;); driver.manage().window().maximize(); driver.quit(); } }   from selenium import webdriver PROXY = \u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34; webdriver.DesiredCapabilities.FIREFOX[\u0026#39;proxy\u0026#39;] = { \u0026#34;httpProxy\u0026#34;: PROXY, \u0026#34;ftpProxy\u0026#34;: PROXY, \u0026#34;sslProxy\u0026#34;: PROXY, \u0026#34;proxyType\u0026#34;: \u0026#34;MANUAL\u0026#34;, } with webdriver.Firefox() as driver: # Open URL driver.get(\u0026#34;https://selenium.dev\u0026#34;)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; public class ProxyTest{ public static void Main() { ChromeOptions options = new ChromeOptions(); Proxy proxy = new Proxy(); proxy.Kind = ProxyKind.Manual; proxy.IsAutoDetect = false; proxy.SslProxy = \u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34;; options.Proxy = proxy; options.AddArgument(\u0026#34;ignore-certificate-errors\u0026#34;); IWebDriver driver = new ChromeDriver(options); driver.Navigate().GoToUrl(\u0026#34;https://www.selenium.dev/\u0026#34;); } }   # este código foi escrito com Selenium 4 proxy = Selenium::WebDriver::Proxy.new(http: \u0026#39;\u0026lt;HOST:PORT\u0026gt;\u0026#39;) cap = Selenium::WebDriver::Remote::Capabilities.chrome(proxy: proxy) driver = Selenium::WebDriver.for(:chrome, capabilities: cap) driver.get(\u0026#39;http://google.com\u0026#39;)   let webdriver = require(\u0026#39;selenium-webdriver\u0026#39;); let chrome = require(\u0026#39;selenium-webdriver/chrome\u0026#39;); let proxy = require(\u0026#39;selenium-webdriver/proxy\u0026#39;); let opts = new chrome.Options(); (async function example() { opts.setProxy(proxy.manual({http: \u0026#39;\u0026lt;HOST:PORT\u0026gt;\u0026#39;})); let driver = new webdriver.Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .setChromeOptions(opts) .build(); try { await driver.get(\u0026#34;https://selenium.dev\u0026#34;); } finally { await driver.quit(); } }());   import org.openqa.selenium.Proxy import org.openqa.selenium.WebDriver import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions class proxyTest { fun main() { val proxy = Proxy() proxy.setHttpProxy(\u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34;) val options = ChromeOptions() options.setCapability(\u0026#34;proxy\u0026#34;, proxy) val driver: WebDriver = ChromeDriver(options) driver[\u0026#34;https://www.google.com/\u0026#34;] driver.manage().window().maximize() driver.quit() } }     "},{"uri":"https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/consider_using_a_fluent_api/","title":"Considere usar uma API fluente","tags":[],"description":"","content":"Martin Fowler cunhou o termo \u0026ldquo;API Fluent\u0026rdquo;. Selenium já implementa algo assim em sua classe FluentWait, que é pretende ser uma alternativa à classe padrão Wait. Você pode habilitar o padrão de design de API fluente em seu objeto de página e, em seguida, consulte a página de pesquisa do Google com um snippet de código como este:\ndriver.get( \u0026#34;http://www.google.com/webhp?hl=en\u0026amp;amp;tab=ww\u0026#34; ); GoogleSearchPage gsp = new GoogleSearchPage(); gsp.withFluent().setSearchString().clickSearchButton(); A classe de objeto da página do Google com este comportamento fluente pode ser assim:\npublic class GoogleSearchPage extends LoadableComponent\u0026lt;GoogleSearchPage\u0026gt; { private final WebDriver driver; private GSPFluentInterface gspfi; public class GSPFluentInterface { private GoogleSearchPage gsp; public GSPFluentInterface(GoogleSearchPage googleSearchPage) { gsp = googleSearchPage; } public GSPFluentInterface clickSearchButton() { gsp.searchButton.click(); return this; } public GSPFluentInterface setSearchString( String sstr ) { clearAndType( gsp.searchField, sstr ); return this; } } @FindBy(id = \u0026#34;gbqfq\u0026#34;) private WebElement searchField; @FindBy(id = \u0026#34;gbqfb\u0026#34;) private WebElement searchButton; public GoogleSearchPage(WebDriver driver) { gspfi = new GSPFluentInterface( this ); this.get(); // Se load() falhar, chama isLoaded() até que a página termine de carregar  PageFactory.initElements(driver, this); // Inicializa WebElements na página  } public GSPFluentInterface withFluent() { return gspfi; } public void clickSearchButton() { searchButton.click(); } public void setSearchString( String sstr ) { clearAndType( searchField, sstr ); } @Override protected void isLoaded() throws Error { Assert.assertTrue(\u0026#34;Google search page is not yet loaded.\u0026#34;, isSearchFieldVisible() ); } @Override protected void load() { if ( isSFieldPresent ) { Wait\u0026lt;WebDriver\u0026gt; wait = new WebDriverWait( driver, Duration.ofSeconds(3) ); wait.until( visibilityOfElementLocated( By.id(\u0026#34;gbqfq\u0026#34;) ) ).click(); } } } "},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/page_loading_strategy/","title":"Estratégia de carregamento de página","tags":[],"description":"","content":"Define a estratégia de carregamento de página da sessão atual. Por padrão, quando o Selenium WebDriver carrega uma página, segue a normal pageLoadStrategy. É sempre recomendado parar de baixar outros recursos (como imagens, css, js) quando o carregamento da página leva muito tempo.\nA propriedade document.readyState de um documento descreve o estado de carregamento do documento atual. Por padrão, o WebDriver vai adiar a resposta a uma chamada para driver.get() (ou) driver.navigate().To() até que o estado de documento pronto seja completo\nEm aplicações SPA (como Angular, React, Ember) uma vez que o conteúdo dinâmico já está carregado (ou seja, quando o status de pageLoadStrategy for COMPLETE), clicar em um link ou realizar alguma ação na página não fará uma nova solicitação para o servidor, pois o conteúdo é carregado dinamicamente no lado do cliente sem uma atualização da página.\nOs aplicativos SPA podem carregar muitas visualizações dinamicamente sem quaisquer solicitações do servidor, então pageLoadStrategy sempre mostrará o status COMPLETO até fazemos um novo driver.get () e driver.navigate().To()\nWebDriver pageLoadStrategy suporta os seguintes valores:\nnormal Isso fará com que o Selenium WebDriver espere até que a página inteira seja carregada. Quando definido como normal, o Selenium WebDriver espera até que o disparo do evento load seja retornado.\nPor padrão, normal é definido como navegador se nenhum for fornecido.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;normal\u0026#39; driver = webdriver.Chrome(options=options) # Navegar para Url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.Normal; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;normal\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;normal\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     eager Isso fará com que o Selenium WebDriver espere até que o documento HTML inicial seja completamente carregado e analisado, e descarta o carregamento de CSS, imagens e subframes.\nQuando definido como eager, o Selenium WebDriver espera até que o disparo de evento DOMContentLoaded seja retornado.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.EAGER); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;eager\u0026#39; driver = webdriver.Chrome(options=options) # Navegar para Url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.Eager; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;eager\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;eager\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.EAGER) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     none Quando definido como none, o Selenium WebDriver apenas espera até que a página inicial seja baixada.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.NONE); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;none\u0026#39; driver = webdriver.Chrome(options=options) # Navegar para Url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.None; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;none\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;none\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.NONE) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     "},{"uri":"https://www.selenium.dev/documentation/pt-br/worst_practices/","title":"Piores práticas","tags":[],"description":"","content":"Piores práticas "},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/web_element/","title":"Elemento Web","tags":[],"description":"","content":"WebElement representa um elemento DOM. WebElements podem ser encontrados pesquisando na raiz do documento usando uma instância do WebDriver ou pesquisando em outro WebElement.\nWebDriver API fornece métodos integrados para encontrar WebElements que são baseados em diferentes propriedades, como ID, Nome, Classe, XPath, Seletores CSS, Texto do link, etc.\nEncontrar elemento É usado para encontrar um elemento e retorna a primeira referência WebElement única correspondente, que pode ser usado para ações futuras do elemento\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.get(\u0026#34;http://www.google.com\u0026#34;); // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element WebElement searchBox = driver.findElement(By.name(\u0026#34;q\u0026#34;)); searchBox.sendKeys(\u0026#34;webdriver\u0026#34;);   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Firefox() driver.get(\u0026#34;http://www.google.com\u0026#34;) # Get search box element from webElement \u0026#39;q\u0026#39; using Find Element search_box = driver.find_element(By.NAME, \u0026#34;q\u0026#34;) search_box.send_keys(\u0026#34;webdriver\u0026#34;)   IWebDriver driver = new FirefoxDriver(); driver.Url = \u0026#34;http://www.google.com\u0026#34;; // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element IWebElement searchbox = driver.FindElement(By.Name(\u0026#34;q\u0026#34;)); searchbox.SendKeys(\u0026#34;webdriver\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; # Get search box element from webElement \u0026#39;q\u0026#39; using Find Element search_bar = driver.find_element(name: \u0026#39;q\u0026#39;) # Perform action using WebElement search_bar.send_keys \u0026#39;Webdriver\u0026#39; ensure driver.quit end   let {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); driver = new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); (async function test(){ //Navigate to url await driver.get(\u0026#39;http://www.google.com\u0026#39;); // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element let searchBar = driver.findElement(By.name(\u0026#39;q\u0026#39;)); //Perform action using WebElement await searchBar.sendKeys(\u0026#39;Webdriver\u0026#39;); })();   val driver = FirefoxDriver() driver.get(\u0026#34;http://www.google.com\u0026#34;) // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element val searchBox = driver.findElement(By.name(\u0026#34;q\u0026#34;)) searchBox.sendKeys(\u0026#34;webdriver\u0026#34;)     Encontrar elementos Semelhante a \u0026lsquo;Encontrar Elemento\u0026rsquo;, mas retorna uma lista de WebElements correspondentes. Para usar um determinado WebElement da lista, você precisa percorrer a lista de elementos para executar a ação no elemento selecionado.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; import java.util.List; public class findElementsExample { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); try { driver.get(\u0026#34;https://example.com\u0026#34;); // Get all the elements available with tag name \u0026#39;p\u0026#39;  List\u0026lt;WebElement\u0026gt; elements = driver.findElements(By.tagName(\u0026#34;p\u0026#34;)); for (WebElement element : elements) { System.out.println(\u0026#34;Paragraph text:\u0026#34; + element.getText()); } } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Firefox() # Navigate to Url driver.get(\u0026#34;https://www.example.com\u0026#34;) # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = driver.find_elements(By.TAG_NAME, \u0026#39;p\u0026#39;) for e in elements: print(e.text)   using OpenQA.Selenium; using OpenQA.Selenium.Firefox; using System.Collections.Generic; namespace FindElementsExample { class FindElementsExample { public static void Main(string[] args) { IWebDriver driver = new FirefoxDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Get all the elements available with tag name \u0026#39;p\u0026#39;  IList \u0026lt; IWebElement \u0026gt; elements = driver.FindElements(By.TagName(\u0026#34;p\u0026#34;)); foreach(IWebElement e in elements) { System.Console.WriteLine(e.Text); } } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://www.example.com\u0026#39; # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = driver.find_elements(:tag_name,\u0026#39;p\u0026#39;) elements.each { |e| puts e.text } ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Get all the elements available with tag \u0026#39;p\u0026#39;  let elements = await driver.findElements(By.css(\u0026#39;p\u0026#39;)); for(let e of elements) { console.log(await e.getText()); } } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.firefox.FirefoxDriver fun main() { val driver = FirefoxDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Get all the elements available with tag name \u0026#39;p\u0026#39;  val elements = driver.findElements(By.tagName(\u0026#34;p\u0026#34;)) for (element in elements) { println(\u0026#34;Paragraph text:\u0026#34; + element.text) } } finally { driver.quit() } }     Encontrar Elemento a partir do Elemento É usado para localizar um elemento filho dentro do contexto do elemento pai. Para conseguir isso, o WebElement pai é encadeado com \u0026lsquo;findElement\u0026rsquo; para acessar os elementos filhos\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.get(\u0026#34;http://www.google.com\u0026#34;); WebElement searchForm = driver.findElement(By.tagName(\u0026#34;form\u0026#34;)); WebElement searchBox = searchForm.findElement(By.name(\u0026#34;q\u0026#34;)); searchBox.sendKeys(\u0026#34;webdriver\u0026#34;);   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Firefox() driver.get(\u0026#34;http://www.google.com\u0026#34;) search_form = driver.find_element(By.TAG_NAME, \u0026#34;form\u0026#34;) search_box = search_form.find_element(By.NAME, \u0026#34;q\u0026#34;) search_box.send_keys(\u0026#34;webdriver\u0026#34;)   IWebDriver driver = new FirefoxDriver(); driver.Url = \u0026#34;http://www.google.com\u0026#34;; IWebElement searchForm = driver.FindElement(By.TagName(\u0026#34;form\u0026#34;)); IWebElement searchbox = searchForm.FindElement(By.Name(\u0026#34;q\u0026#34;)); searchbox.SendKeys(\u0026#34;webdriver\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; # Get and store DOM element \u0026#39;\u0026lt;form\u0026gt;\u0026#39; search_form = driver.find_element(name: \u0026#39;f\u0026#39;) # Get search box element from webElement \u0026#39;form\u0026#39; search_bar = search_form.find_element(name: \u0026#39;q\u0026#39;) # Perform action using WebElement search_bar.send_keys \u0026#39;Webdriver\u0026#39; ensure driver.quit end   let {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); driver = new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); (async function test(){ //Navigate to url await driver.get(\u0026#39;http://www.google.com\u0026#39;); //Get and store DOM element \u0026#39;\u0026lt;form\u0026gt;\u0026#39; let searchForm = driver.findElement(By.name(\u0026#39;f\u0026#39;)); //Get search box element from webElement \u0026#39;form\u0026#39; let searchBar = searchForm.findElement(By.name(\u0026#39;q\u0026#39;)); //Perform action using WebElement await searchBar.sendKeys(\u0026#39;Webdriver\u0026#39;); })();   val driver = FirefoxDriver() driver.get(\u0026#34;http://www.google.com\u0026#34;) val searchForm = driver.findElement(By.tagName(\u0026#34;form\u0026#34;)) val searchBox = searchForm.findElement(By.name(\u0026#34;q\u0026#34;)) searchBox.sendKeys(\u0026#34;webdriver\u0026#34;)     Encontrar Elementos a partir do Elemento É usado para localizar a lista de WebElements filhos correspondentes dentro do contexto do elemento pai. Para conseguir isso, o WebElement pai é encadeado com \u0026lsquo;findElements\u0026rsquo; para acessar os elementos filho\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import java.util.List; public class findElementsFromElement { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;https://example.com\u0026#34;); // Get element with tag name \u0026#39;div\u0026#39;  WebElement element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)); // Get all the elements available with tag name \u0026#39;p\u0026#39;  List\u0026lt;WebElement\u0026gt; elements = element.findElements(By.tagName(\u0026#34;p\u0026#34;)); for (WebElement e : elements) { System.out.println(e.getText()); } } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() driver.get(\u0026#34;https://www.example.com\u0026#34;) # Get element with tag name \u0026#39;div\u0026#39; element = driver.find_element(By.TAG_NAME, \u0026#39;div\u0026#39;) # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = element.find_elements(By.TAG_NAME, \u0026#39;p\u0026#39;) for e in elements: print(e.text)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using System.Collections.Generic; namespace FindElementsFromElement { class FindElementsFromElement { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Get element with tag name \u0026#39;div\u0026#39;  IWebElement element = driver.FindElement(By.TagName(\u0026#34;div\u0026#34;)); // Get all the elements available with tag name \u0026#39;p\u0026#39;  IList \u0026lt; IWebElement \u0026gt; elements = element.FindElements(By.TagName(\u0026#34;p\u0026#34;)); foreach(IWebElement e in elements) { System.Console.WriteLine(e.Text); } } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to URL driver.get \u0026#39;https://www.example.com\u0026#39; # Get element with tag name \u0026#39;div\u0026#39; element = driver.find_element(:tag_name,\u0026#39;div\u0026#39;) # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = element.find_elements(:tag_name,\u0026#39;p\u0026#39;) elements.each { |e| puts e.text } ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Get element with tag name \u0026#39;div\u0026#39;  let element = driver.findElement(By.css(\u0026#34;div\u0026#34;)); // Get all the elements available with tag name \u0026#39;p\u0026#39;  let elements = await element.findElements(By.css(\u0026#34;p\u0026#34;)); for(let e of elements) { console.log(await e.getText()); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Get element with tag name \u0026#39;div\u0026#39;  val element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)) // Get all the elements available with tag name \u0026#39;p\u0026#39;  val elements = element.findElements(By.tagName(\u0026#34;p\u0026#34;)) for (e in elements) { println(e.text) } } finally { driver.quit() } }     Coletar elemento ativo É usado para rastrear (ou) localizar o elemento DOM que tem o foco no contexto de navegação atual.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class activeElementTest { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.findElement(By.cssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).sendKeys(\u0026#34;webElement\u0026#34;); // Get attribute of current active element  String attr = driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); System.out.println(attr); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() driver.get(\u0026#34;https://www.google.com\u0026#34;) driver.find_element(By.CSS_SELECTOR, \u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;).send_keys(\u0026#34;webElement\u0026#34;) # Get attribute of current active element attr = driver.switch_to.active_element.get_attribute(\u0026#34;title\u0026#34;) print(attr)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace ActiveElement { class ActiveElement { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://www.google.com\u0026#34;); driver.FindElement(By.CssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).SendKeys(\u0026#34;webElement\u0026#34;); // Get attribute of current active element  string attr = driver.SwitchTo().ActiveElement().GetAttribute(\u0026#34;title\u0026#34;); System.Console.WriteLine(attr); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.google.com\u0026#39; driver.find_element(css: \u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;).send_keys(\u0026#39;webElement\u0026#39;) # Get attribute of current active element attr = driver.switch_to.active_element.attribute(\u0026#39;title\u0026#39;) puts attr ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); await driver.get(\u0026#39;https://www.google.com\u0026#39;); await driver.findElement(By.css(\u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;)).sendKeys(\u0026#34;webElement\u0026#34;); // Get attribute of current active element  let attr = await driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); console.log(`${attr}`) })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://www.google.com\u0026#34;) driver.findElement(By.cssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).sendKeys(\u0026#34;webElement\u0026#34;) // Get attribute of current active element  val attr = driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;) print(attr) } finally { driver.quit() } }     Elemento está ativado Este método é usado para verificar se o elemento conectado está habilitado ou desabilitado em uma página da web. Retorna um valor booleano, True se o elemento conectado estiver ativado no contexto de navegação atual, caso contrário, retorna False.\nJava Python C# Ruby JavaScript Kotlin //navigates to url  driver.get(\u0026#34;https://www.google.com/\u0026#34;); //returns true if element is enabled else returns false  boolean value = driver.findElement(By.name(\u0026#34;btnK\u0026#34;)).isEnabled();   # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Returns true if element is enabled else returns false value = driver.find_element(By.NAME, \u0026#39;btnK\u0026#39;).is_enabled()   // Navigate to Url driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store the WebElement IWebElement element = driver.FindElement(By.Name(\u0026#34;btnK\u0026#34;)); // Prints true if element is enabled else returns false System.Console.WriteLine(element.Enabled);   # Navigate to url driver.get \u0026#39;http://www.google.com/\u0026#39; # Returns true if element is enabled else returns false ele = driver.find_element(name: \u0026#39;btnK\u0026#39;).enabled?   // Navigate to url await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Resolves Promise and returns boolean value let element = await driver.findElement(By.name(\u0026#34;btnK\u0026#34;)).isEnabled();   //navigates to url  driver.get(\u0026#34;https://www.google.com/\u0026#34;) //returns true if element is enabled else returns false  val attr = driver.findElement(By.name(\u0026#34;btnK\u0026#34;)).isEnabled()     Elemento está selecionado Este método determina se o elemento referenciado é Selected ou não. Este método é amplamente utilizado em caixas de seleção, botões de opção, elementos de entrada e elementos de opção.\nRetorna um valor booleano, true se o elemento referenciado for selected no contexto de navegação atual, caso contrário, retorna false.\nJava Python C# Ruby JavaScript Kotlin //navigates to url  driver.get(\u0026#34;https://the-internet.herokuapp.com/checkboxes\u0026#34;); //returns true if element is checked else returns false  boolean value = driver.findElement(By.cssSelector(\u0026#34;input[type=\u0026#39;checkbox\u0026#39;]:first-of-type\u0026#34;)).isSelected();   # Navigate to url driver.get(\u0026#34;https://the-internet.herokuapp.com/checkboxes\u0026#34;) # Returns true if element is checked else returns false value = driver.find_element(By.CSS_SELECTOR, \u0026#34;input[type=\u0026#39;checkbox\u0026#39;]:first-of-type\u0026#34;).is_selected()   // Navigate to Url driver.Navigate().GoToUrl(\u0026#34;https://the-internet.herokuapp.com/checkboxes\u0026#34;); // Returns true if element ins checked else returns false bool value = driver.FindElement(By.CssSelector(\u0026#34;input[type=\u0026#39;checkbox\u0026#39;]:last-of-type\u0026#34;)).Selected;   # Navigate to url driver.get \u0026#39;https://the-internet.herokuapp.com/checkboxes\u0026#39; # Returns true if element is checked else returns false ele = driver.find_element(css: \u0026#34;input[type=\u0026#39;checkbox\u0026#39;]:last-of-type\u0026#34;).selected?   // Navigate to url await driver.get(\u0026#39;https://the-internet.herokuapp.com/checkboxes\u0026#39;); // Returns true if element ins checked else returns false let res = await driver.findElement(By.css(\u0026#34;input[type=\u0026#39;checkbox\u0026#39;]:last-of-type\u0026#34;)).isSelected();   //navigates to url  driver.get(\u0026#34;https://the-internet.herokuapp.com/checkboxes\u0026#34;) //returns true if element is checked else returns false  val attr = driver.findElement(By.cssSelector(\u0026#34;input[type=\u0026#39;checkbox\u0026#39;]:first-of-type\u0026#34;)).isSelected()     Coletar TagName do elemento É usado para buscar o TagName do elemento referenciado que tem o foco no contexto de navegação atual.\nJava Python C# Ruby JavaScript Kotlin //navigates to url  driver.get(\u0026#34;https://www.example.com\u0026#34;); //returns TagName of the element  String value = driver.findElement(By.cssSelector(\u0026#34;h1\u0026#34;)).getTagName();   # Navigate to url driver.get(\u0026#34;https://www.example.com\u0026#34;) # Returns TagName of the element attr = driver.find_element(By.CSS_SELECTOR, \u0026#34;h1\u0026#34;).tag_name   // Navigate to Url driver.Navigate().GoToUrl(\u0026#34;https://www.example.com\u0026#34;); // Returns TagName of the element string attr = driver.FindElement(By.CssSelector(\u0026#34;h1\u0026#34;)).TagName;   # Navigate to url driver.get \u0026#39;https://www.example.com\u0026#39; # Returns TagName of the element attr = driver.find_element(css: \u0026#34;h1\u0026#34;).tag_name   // Navigate to URL await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Returns TagName of the element let value = await driver.findElement(By.css(\u0026#39;h1\u0026#39;)).getTagName();   //navigates to url  driver.get(\u0026#34;https://www.example.com\u0026#34;) //returns TagName of the element  val attr = driver.findElement(By.cssSelector(\u0026#34;h1\u0026#34;)).getTagName()     Coletar retângulo do elemento É usado para buscar as dimensões e coordenadas do elemento referenciado.\nO corpo de dados buscado contém os seguintes detalhes:\n Posição do eixo X a partir do canto superior esquerdo do elemento posição do eixo y a partir do canto superior esquerdo do elemento Altura do elemento Largura do elemento  Java Python C# Ruby JavaScript Kotlin // Navigate to url driver.get(\u0026#34;https://www.example.com\u0026#34;); // Returns height, width, x and y coordinates referenced element Rectangle res = driver.findElement(By.cssSelector(\u0026#34;h1\u0026#34;)).getRect(); // Rectangle class provides getX,getY, getWidth, getHeight methods System.out.println(res.getX());   # Navigate to url driver.get(\u0026#34;https://www.example.com\u0026#34;) # Returns height, width, x and y coordinates referenced element res = driver.find_element(By.CSS_SELECTOR, \u0026#34;h1\u0026#34;).rect   // Navigate to Url driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); var res = driver.FindElement(By.CssSelector(\u0026#34;h1\u0026#34;)); // Return x and y coordinates referenced element System.Console.WriteLine(res.Location); // Returns height, width System.Console.WriteLine(res.Size);   # Navigate to url driver.get \u0026#39;https://www.example.com\u0026#39; # Returns height, width, x and y coordinates referenced element res = driver.find_element(css: \u0026#34;h1\u0026#34;).rect   // Navigate to url await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Returns height, width, x and y coordinates referenced element let element = await driver.findElement(By.css(\u0026#34;h1\u0026#34;)).getRect();   // Navigate to url driver.get(\u0026#34;https://www.example.com\u0026#34;) // Returns height, width, x and y coordinates referenced element val res = driver.findElement(By.cssSelector(\u0026#34;h1\u0026#34;)).rect // Rectangle class provides getX,getY, getWidth, getHeight methods println(res.getX())     Coletar valor CSS do elemento Recupera o valor da propriedade de estilo computado especificada de um elemento no contexto de navegação atual.\nJava Python C# Ruby JavaScript Kotlin // Navigate to Url driver.get(\u0026#34;https://www.example.com\u0026#34;); // Retrieves the computed style property \u0026#39;color\u0026#39; of linktext String cssValue = driver.findElement(By.linkText(\u0026#34;More information...\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;);   # Navigate to Url driver.get(\u0026#39;https://www.example.com\u0026#39;) # Retrieves the computed style property \u0026#39;color\u0026#39; of linktext cssValue = driver.findElement(By.LINK_TEXT, \u0026#34;More information...\u0026#34;).value_of_css_property(\u0026#39;color\u0026#39;)   // Navigate to Url driver.Navigate().GoToUrl(\u0026#34;https://www.example.com\u0026#34;); // Retrieves the computed style property \u0026#39;color\u0026#39; of linktext String cssValue = driver.FindElement(By.LinkText(\u0026#34;More information...\u0026#34;)).GetCssValue(\u0026#34;color\u0026#34;);   # Navigate to Url driver.get \u0026#39;https://www.example.com\u0026#39; # Retrieves the computed style property \u0026#39;color\u0026#39; of linktext cssValue = driver.find_element(:link_text, \u0026#39;More information...\u0026#39;).css_value(\u0026#39;color\u0026#39;)   // Navigate to Url await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Retrieves the computed style property \u0026#39;color\u0026#39; of linktext let cssValue = await driver.findElement(By.linkText(\u0026#34;More information...\u0026#34;)).getCssValue(\u0026#39;color\u0026#39;);   // Navigate to Url driver.get(\u0026#34;https://www.example.com\u0026#34;) // Retrieves the computed style property \u0026#39;color\u0026#39; of linktext val cssValue = driver.findElement(By.linkText(\u0026#34;More information...\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;)     Coletar texto do elemento Recupera o texto renderizado do elemento especificado.\nJava Python C# Ruby JavaScript Kotlin // Navigate to url driver.get(\u0026#34;https://example.com\u0026#34;); // Retrieves the text of the element String text = driver.findElement(By.cssSelector(\u0026#34;h1\u0026#34;)).getText();   # Navigate to url driver.get(\u0026#34;https://www.example.com\u0026#34;) # Retrieves the text of the element text = driver.find_element(By.CSS_SELECTOR, \u0026#34;h1\u0026#34;).text   // Please provide a pr for code sample    # Navigate to url driver.get \u0026#39;https://www.example.com\u0026#39; # Retrieves the text of the element text = driver.find_element(:css, \u0026#39;h1\u0026#39;).text   // Navigate to URL await driver.get(\u0026#39;http://www.example.com\u0026#39;); // retrieves the text of the element let text = await driver.findElement(By.css(\u0026#39;h1\u0026#39;)).getText();   // Navigate to URL driver.get(\u0026#34;https://www.example.com\u0026#34;) // retrieves the text of the element val text = driver.findElement(By.cssSelector(\u0026#34;h1\u0026#34;)).getText()     "},{"uri":"https://www.selenium.dev/documentation/pt-br/grid/","title":"Grid","tags":[],"description":"","content":"Grid Selenium Grid permite a execução de scripts WebDriver em máquinas remotas (virtuais ou reais) por meio de comandos de roteamento enviados pelo cliente para instâncias remotas do navegador. Seu objetivo é fornecer uma maneira fácil de executar testes em paralelo em várias máquinas.\nSelenium Grid nos permite executar testes em paralelo em várias máquinas e gerenciar diferentes versões e configurações do navegador centralmente (em vez de em cada teste individual).\nA Selenium Grid não é uma bala de prata. Ela resolve um subconjunto de problemas comuns de delegação e distribuição, mas não irá, por exemplo, gerenciar sua infraestrutura, e pode não atender às suas necessidades específicas.\nObserve que a Grid 3 não é mais compatível e o projeto Selenium recomenda usar a Grid 4\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/fresh_browser_per_test/","title":"Navegador novo por teste","tags":[],"description":"","content":"Comece cada teste a partir de um estado limpo conhecido. Idealmente, ligue uma nova máquina virtual para cada teste. Se ligar uma nova máquina virtual não for prático, pelo menos inicie um novo WebDriver para cada teste. Para Firefox, inicie um WebDriver com seu perfil conhecido.\nFirefoxProfile profile = new FirefoxProfile(new File(\u0026#34;pathToFirefoxProfile\u0026#34;)); WebDriver driver = new FirefoxDriver(profile); "},{"uri":"https://www.selenium.dev/documentation/pt-br/support_packages/chrome_devtools/","title":"Chrome Devtools","tags":[],"description":"","content":"As versões alfa do Selenium 4 têm aguardado suporte nativo para o protocolo Chrome DevTools por meio da interface \u0026ldquo;DevTools\u0026rdquo;. Isso nos ajuda a obter propriedades de desenvolvimento do Chrome, como cache de aplicativo, busca, rede, desempenho, criador de perfil, tempo de recurso, segurança e domínios de CDP de destino, etc.\nChrome DevTools é um conjunto de ferramentas de desenvolvedor da web integradas diretamente no navegador Google Chrome. DevTools pode ajudá-lo a editar páginas dinamicamente e diagnosticar problemas rapidamente, o que, em última análise, ajuda a criar sites melhores e mais rápidos.\nEmulando Geolocalização: Alguns aplicativos têm diferentes recursos e funcionalidades em diferentes locais. Automatizar esses aplicativos é difícil porque é difícil emular as localizações geográficas no navegador usando o Selenium. Mas com a ajuda de Devtools, podemos facilmente emulá-los. O trecho de código abaixo demonstra isso.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.devtools.DevTools; public void geoLocationTest(){ ChromeDriver driver = new ChromeDriver(); Map coordinates = new HashMap() {{ put(\u0026#34;latitude\u0026#34;, 50.2334); put(\u0026#34;longitude\u0026#34;, 0.2334); put(\u0026#34;accuracy\u0026#34;, 1); }}; driver.executeCdpCommand(\u0026#34;Emulation.setGeolocationOverride\u0026#34;, coordinates); driver.get(\u0026#34;\u0026lt;your site url\u0026gt;\u0026#34;); }   from selenium import webdriver from selenium.webdriver.chrome.service import Service def geoLocationTest(): driver = webdriver.Chrome() Map_coordinates = dict({ \u0026#34;latitude\u0026#34;: 41.8781, \u0026#34;longitude\u0026#34;: -87.6298, \u0026#34;accuracy\u0026#34;: 100 }) driver.execute_cdp_cmd(\u0026#34;Emulation.setGeolocationOverride\u0026#34;, Map_coordinates) driver.get(\u0026#34;\u0026lt;your site url\u0026gt;\u0026#34;)   using System.Threading.Tasks; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.DevTools; // Replace the version to match the Chrome version using OpenQA.Selenium.DevTools.V87.Emulation; namespace dotnet_test { class Program { public static void Main(string[] args) { GeoLocation().GetAwaiter().GetResult(); } public static async Task GeoLocation() { ChromeDriver driver = new ChromeDriver(); DevToolsSession devToolsSession = driver.CreateDevToolsSession(); var geoLocationOverrideCommandSettings = new SetGeolocationOverrideCommandSettings(); geoLocationOverrideCommandSettings.Latitude = 51.507351; geoLocationOverrideCommandSettings.Longitude = -0.127758; geoLocationOverrideCommandSettings.Accuracy = 1; await devToolsSession .GetVersionSpecificDomains\u0026lt;OpenQA.Selenium.DevTools.V87.DevToolsSessionDomains\u0026gt;() .Emulation .SetGeolocationOverride(geoLocationOverrideCommandSettings); driver.Url = \u0026#34;\u0026lt;your site url\u0026gt;\u0026#34;; } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Latitude and longitude of Tokyo, Japan coordinates = { latitude: 35.689487, longitude: 139.691706, accuracy: 100 } driver.execute_cdp(\u0026#39;Emulation.setGeolocationOverride\u0026#39;, coordinates) driver.get \u0026#39;https://www.google.com/search?q=selenium\u0026#39; ensure driver.quit end   // Please raise a PR to add code sample    import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.devtools.DevTools fun main() { val driver = ChromeDriver() val coordinates : HashMap\u0026lt;String, Any\u0026gt; = HashMap\u0026lt;String, Any\u0026gt; () coordinates.put(\u0026#34;latitude\u0026#34;, 50.2334) coordinates.put(\u0026#34;longitude\u0026#34;, 0.2334) coordinates.put(\u0026#34;accuracy\u0026#34;, 1) driver.executeCdpCommand(\u0026#34;Emulation.setGeolocationOverride\u0026#34;, coordinates) driver.get(\u0026#34;https://www.google.com\u0026#34;) }     Register Basic Auth: Some applications require to keep some pages behind an auth and most of the time to keep things simple, a developer uses Basic Auth. With Selenium and devtools integration, you can automate the input of basic auth credentials whenever they arise.\nJava Python C# Ruby JavaScript Kotlin Predicate\u0026lt;URI\u0026gt; uriPredicate = uri -\u0026gt; uri.getHost().contains(\u0026#34;your-domain.com\u0026#34;); ((HasAuthentication) driver).register(uriPredicate, UsernameAndPassword.of(\u0026#34;admin\u0026#34;, \u0026#34;password\u0026#34;)); driver.get(\u0026#34;https://your-domain.com/login\u0026#34;);   # Please raise a PR to add code sample   # Please raise a PR to add code sample   # Please raise a PR to add code sample   const pageCdpConnection = await driver.createCDPConnection(\u0026#39;page\u0026#39;) await driver.register(\u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;, pageCdpConnection) await driver.get(server.url())   # Please raise a PR to add code sample     Listen to DOM events on a web page Using Selenium\u0026rsquo;s integration with CDP, one can listen to the DOM events and register callbacks to process the DOM event.\nJava Python C# Ruby JavaScript Kotlin # Please raise a PR to add code sample   # Please raise a PR to add code sample   # Please raise a PR to add code sample   # Please raise a PR to add code sample   const cdpConnection = await driver.createCDPConnection(\u0026#39;page\u0026#39;) await driver.logMutationEvents(cdpConnection, function(event) { assert.equal(event[\u0026#39;attribute_name\u0026#39;], \u0026#39;style\u0026#39;) assert.equal(event[\u0026#39;current_value\u0026#39;], \u0026#39;\u0026#39;) assert.equal(event[\u0026#39;old_value\u0026#39;], \u0026#39;display:none;\u0026#39;) }) await driver.get(test.Pages.dynamicPage) let element = driver.findElement({id: \u0026#39;reveal\u0026#39;}) await element.click() let revealed = driver.findElement({id: \u0026#39;revealed\u0026#39;}); await driver.wait(until.elementIsVisible(revealed), 5000);   # Please raise a PR to add code sample     Listen to JS Exceptions on a web page Using Selenium\u0026rsquo;s integration with CDP, one can listen to the JS Exceptions and register callbacks to process the exception details.\nJava Python C# Ruby JavaScript Kotlin # Please raise a PR to add code sample   # Please raise a PR to add code sample   # Please raise a PR to add code sample   # Please raise a PR to add code sample   const cdpConnection = await driver.createCDPConnection(\u0026#39;page\u0026#39;) await driver.onLogException(cdpConnection, function(event) { assert.equal(event[\u0026#39;exceptionDetails\u0026#39;][\u0026#39;stackTrace\u0026#39;][\u0026#39;callFrames\u0026#39;][0][\u0026#39;functionName\u0026#39;], \u0026#39;onmouseover\u0026#39;) }) await driver.get(test.Pages.javascriptPage) let element = driver.findElement({id: \u0026#39;throwing-mouseover\u0026#39;}) await element.click()   # Please raise a PR to add code sample     Listen to console.log events on a web page Using Selenium\u0026rsquo;s integration with CDP, one can listen to the console.log events and register callbacks to process the event.\nJava Python C# Ruby JavaScript Kotlin # Please raise a PR to add code sample   # Please raise a PR to add code sample   # Please raise a PR to add code sample   # Please raise a PR to add code sample   const cdpConnection = await driver.createCDPConnection(\u0026#39;page\u0026#39;) await driver.onLogEvent(cdpConnection, function(event) { assert.equal(event[\u0026#39;args\u0026#39;][0][\u0026#39;value\u0026#39;], \u0026#39;here\u0026#39;) }) await driver.executeScript(\u0026#39;console.log(\u0026#34;here\u0026#34;)\u0026#39;)   # Please raise a PR to add code sample     "},{"uri":"https://www.selenium.dev/documentation/pt-br/driver_idiosyncrasies/","title":"Idiossincrasias do driver","tags":[],"description":"","content":"Idiossincrasias do driver "},{"uri":"https://www.selenium.dev/documentation/pt-br/webdriver/keyboard/","title":"Teclado","tags":[],"description":"","content":"Keyboard representa um evento do teclado. As ações do teclado são executadas usando uma interface de baixo nível que nos permite fornecer entrada de dispositivo virtualizado para o navegador da web.\nsendKeys O sendKeys digita uma sequência de teclas no elemento DOM, mesmo se uma sequência de teclas modificadoras for encontrada. Aqui está a lista de possíveis teclas que WebDriver suporta.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.Keys;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.firefox.FirefoxDriver;\rpublic class HelloSelenium {\rpublic static void main(String[] args) {\rWebDriver driver = new FirefoxDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;);\r// Enter text \u0026#34;q\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;q\u0026#34; + Keys.ENTER);\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Firefox()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element(By.NAME, \u0026#34;q\u0026#34;).send_keys(\u0026#34;webdriver\u0026#34; + Keys.ENTER)\r \rusing (var driver = new FirefoxDriver())\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;webdriver\u0026#34; + Keys.Enter);\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :firefox\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;webdriver\u0026#39;, :return\rensure\rdriver.quit\rend\r \rconst {Builder, By, Key} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Enter text \u0026#34;webdriver\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;webdriver\u0026#39;, Key.ENTER);\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.firefox.FirefoxDriver\rfun main() {\rval driver = FirefoxDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Enter text \u0026#34;q\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;q\u0026#34; + Keys.ENTER)\r} finally {\rdriver.quit()\r}\r}\r \r  keyDown O keyDown é usado para simular a ação de pressionar uma tecla modificadora (CONTROL, SHIFT, ALT)\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new ChromeDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;);\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;webdriver\u0026#34; + Keys.ENTER);\rActions actionProvider = new Actions(driver);\rAction keydown = actionProvider.keyDown(Keys.CONTROL).sendKeys(\u0026#34;a\u0026#34;).build();\rkeydown.perform();\r} finally {\rdriver.quit();\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Chrome()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element(By.NAME, \u0026#34;q\u0026#34;).send_keys(\u0026#34;webdriver\u0026#34; + Keys.ENTER)\r# Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r webdriver.ActionChains(driver).key_down(Keys.CONTROL).send_keys(\u0026#34;a\u0026#34;).perform()\r \rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;webdriver\u0026#34; + Keys.Enter);\r// Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r Actions actionProvider = new Actions(driver);\rIAction keydown = actionProvider.KeyDown(Keys.Control).SendKeys(\u0026#34;a\u0026#34;).Build();\rkeydown.Perform();\r}\rfinally\r{\rdriver.Quit();\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;webdriver\u0026#39;, :return\r# Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r driver.action.key_down(:control).send_keys(\u0026#39;a\u0026#39;).perform\rensure\rdriver.quit\rend\r \r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Enter text \u0026#34;webdriver\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;webdriver\u0026#39;, Key.ENTER);\r// Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r await driver.actions().keyDown(Key.CONTROL).sendKeys(\u0026#39;a\u0026#39;).perform();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.chrome.ChromeDriver\rimport org.openqa.selenium.interactions.Actions\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;webdriver\u0026#34; + Keys.ENTER)\rval action = Actions(driver)\r// Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r action.keyDown(Keys.CONTROL).sendKeys(\u0026#34;a\u0026#34;).build().perform()\r} finally {\rdriver.quit()\r}\r}\r \r  keyUp O keyUp é usado para simular a liberação de uma tecla (ou) de uma tecla modificadora (CONTROL, SHIFT, ALT)\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.Keys;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.WebElement;\rimport org.openqa.selenium.firefox.FirefoxDriver;\rimport org.openqa.selenium.interactions.Actions;\rpublic class HelloSelenium {\rpublic static void main(String[] args) {\rWebDriver driver = new FirefoxDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;);\rActions action = new Actions(driver);\r// Store google search box WebElement\r WebElement search = driver.findElement(By.name(\u0026#34;q\u0026#34;));\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.keyDown(Keys.SHIFT).sendKeys(search,\u0026#34;qwerty\u0026#34;).keyUp(Keys.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).perform();\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Chrome()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Store google search box WebElement\r search = driver.find_element(By.NAME, \u0026#34;q\u0026#34;)\raction = webdriver.ActionChains(driver)\r# Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.key_down(Keys.SHIFT).send_keys_to_element(search, \u0026#34;qwerty\u0026#34;).key_up(Keys.SHIFT).send_keys(\u0026#34;qwerty\u0026#34;).perform()\r \rusing OpenQA.Selenium;\rusing OpenQA.Selenium.Chrome;\rusing OpenQA.Selenium.Interactions;\rnamespace HelloSelenium\r{\rclass HelloSelenium\r{\rpublic static void Main(string[] args)\r{\rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\rActions action = new Actions(driver);\r// Store google search box WebElement\r IWebElement search = driver.FindElement(By.Name(\u0026#34;q\u0026#34;));\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.KeyDown(Keys.Shift).SendKeys(search, \u0026#34;qwerty\u0026#34;).KeyUp(Keys.Shift).SendKeys(\u0026#34;qwerty\u0026#34;).Perform();\r}\rfinally {\rdriver.Quit();\r}\r}\r}\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Store google search box WebElement\r search = driver.find_element(name: \u0026#39;q\u0026#39;)\r# Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r driver.action.key_down(:shift).send_keys(search,\u0026#39;qwerty\u0026#39;).key_up(:shift).send_keys(\u0026#34;qwerty\u0026#34;).perform\rensure\rdriver.quit\rend\r \rconst {Builder, By, Key} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Store google search box WebElement\r let search = driver.findElement(By.name(\u0026#39;q\u0026#39;));\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r await driver.actions().click(search).keyDown(Key.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).keyUp(Key.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).perform();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.chrome.ChromeDriver\rimport org.openqa.selenium.interactions.Actions\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Store google search box WebElement\r val search = driver.findElement(By.name(\u0026#34;q\u0026#34;))\rval action = Actions(driver)\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.keyDown(Keys.SHIFT).sendKeys(search, \u0026#34;qwerty\u0026#34;).keyUp(Keys.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).build().perform()\r} finally {\rdriver.quit()\r}\r}\r \r  clear Limpa o conteúdo de um elemento editável. Isso é aplicado apenas para os elementos que são editáveis e interativos, caso contrário, o Selenium retorna o erro (invalid element state (ou) Element not interactable)\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.WebElement;\rimport org.openqa.selenium.chrome.ChromeDriver;\rpublic class clear {\rpublic static void main(String[] args) {\rWebDriver driver = new ChromeDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://www.google.com\u0026#34;);\r// Store \u0026#39;SearchInput\u0026#39; element\r WebElement searchInput = driver.findElement(By.name(\u0026#34;q\u0026#34;));\rsearchInput.sendKeys(\u0026#34;selenium\u0026#34;);\r// Clears the entered text\r searchInput.clear();\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rdriver = webdriver.Chrome()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Store \u0026#39;SearchInput\u0026#39; element\r SearchInput = driver.find_element(By.NAME, \u0026#34;q\u0026#34;)\rSearchInput.send_keys(\u0026#34;selenium\u0026#34;)\r# Clears the entered text\r SearchInput.clear()\r \rusing OpenQA.Selenium;\rusing OpenQA.Selenium.Chrome;\rusing System;\rnamespace SnipetProjectDelete\r{\rclass Program\r{\rstatic void Main(string[] args)\r{\rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(@\u0026#34;https://www.google.com\u0026#34;);\r// Store \u0026#39;SearchInput\u0026#39; element\r IWebElement searchInput = driver.FindElement(By.Name(\u0026#34;q\u0026#34;));\rsearchInput.SendKeys(\u0026#34;selenium\u0026#34;);\r// Clears the entered text\r searchInput.Clear();\r}\rfinally\r{\rdriver.Quit();\r}\r}\r}\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# store \u0026#39;search_input\u0026#39; element\r search_input = driver.find_element(name: \u0026#39;q\u0026#39;)\rsearch_input.send_keys(\u0026#39;selenium\u0026#39;)\r# Clears the entered text\r search_input.clear\rensure\rdriver.quit\rend\r \rconst {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Store \u0026#39;SearchInput\u0026#39; element\r let searchInput = driver.findElement(By.name(\u0026#39;q\u0026#39;));\rawait searchInput.sendKeys(\u0026#34;selenium\u0026#34;);\r// Clears the entered text\r await searchInput.clear();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.chrome.ChromeDriver\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://www.google.com\u0026#34;)\r// Store \u0026#39;searchInput\u0026#39; element\r val searchInput = driver.findElement(By.name(\u0026#34;q\u0026#34;))\rsearchInput.sendKeys(\u0026#34;selenium\u0026#34;)\r// Clears the entered text\r searchInput.clear()\r} finally {\rdriver.quit()\r}\r}\r \r  "},{"uri":"https://www.selenium.dev/documentation/pt-br/support_packages/","title":"Pacotes de suporte","tags":[],"description":"","content":"Pacotes de suporte "},{"uri":"https://www.selenium.dev/documentation/pt-br/legacy_docs/","title":"Legado","tags":[],"description":"","content":"Legado Nesta seção você pode encontrar toda a documentação relacionada aos componentes legados do Selenium. Isso deve ser mantido puramente por razões históricas e não como um incentivo para o uso obsoleto componentes.\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/front_matter/","title":"Prefácio","tags":[],"description":"","content":"Prefácio "},{"uri":"https://www.selenium.dev/documentation/pt-br/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://www.selenium.dev/documentation/pt-br/contributing/","title":"Contribuindo com o Site e Documentação do Selenium","tags":[],"description":"","content":"Selenium é um grande projeto de software, seu site e documentação são fundamentais para entender como as coisas funcionam e aprender maneiras eficazes de explorar seu potencial.\nEste projeto contém o site e a documentação do Selenium. Isto é um esforço contínuo (não direcionado a nenhuma versão específica) para fornecer informações atualizadas sobre como usar o Selenium de forma eficaz, como se envolver e como contribuir para o Selenium.\nAs contribuições para o site e documentação seguem o processo descrito na seção abaixo sobre contribuições. Você deveria passar algum tempo familiarizando-se com a documentação lendo mais sobre isso.\n O projeto Selenium recebe contribuições de todos. Há um várias maneiras de ajudar:\nReportar um problema Ao relatar um novo problema ou comentar sobre problemas existentes, por favor certifique-se de que as discussões estão relacionadas a questões técnicas concretas sobre o software Selenium, seu site e/ou documentação.\nTodos os componentes do Selenium mudam bastante rápido ao longo do tempo, então este pode fazer com que a documentação fique desatualizada. Se você observar que este é o caso, como mencionado, não hesite em criar um problema para isso. Também pode ser possível que você saiba como atualizar a documentação, então, envie-nos um Pull Request com a alteração.\nSe você não tem certeza se o que encontrou é um problema ou não, pergunte através dos canais de comunicação descritos em https://selenium.dev/support.\nContribuições O projeto Selenium dá as boas-vindas a novos contribuidores. Indivíduos fazendo contribuições significativas e valiosas ao longo do tempo são transformados em Committers e recebem acesso de commit ao projeto.\nEste guia irá guiá-lo através do processo de contribuição.\nPasso 1: Fork Faça um fork do projeto no Github e faça checkout na sua cópia localmente.\n% git clone git@github.com:seleniumhq/seleniumhq.github.io.git % cd seleniumhq.github.io Dependências: Hugo Usamos Hugo para construir e renderizar o site e documentação. Para verificar tudo localmente antes mesmo de fazer qualquer alteração, por favor instale Hugo, familiarize-se com ele e execute o servidor local para renderizar o site localmente (instruções detalhadas podem ser encontradas no próximos passos).\nPasso 2: Branch Crie uma branch e comece a hackear:\n% git checkout -b my-feature-branch Praticamos o desenvolvimento baseado em HEAD, o que significa que todas as mudanças são aplicadas diretamente no topo do trunk.\nPasso 3: Faça mudanças O repositório contém o site e documentação, que são dois projetos Hugo separados. Se você quiser fazer alterações no site, trabalhe no diretório site_source_files. Para ver uma prévia ao vivo de suas alterações, execute hugo server no diretório raiz do site.\n% cd site_source_files % hugo server Para fazer alterações na documentação, vá para o diretório docs_source_files.\n% cd docs_source_files % hugo server A documentação é traduzida para vários idiomas e as traduções são baseadas no conteúdo em inglês. Ao alterar um arquivo, certifique-se de realizar a mudanças em todos os outros arquivos traduzidos também. Isso pode ser diferente dependendo sobre a mudança, por exemplo:\n Se você adicionar um exemplo de código ao arquivo browser_manipulation.en.md, também adicione-o a browser_manipulation.es.md, browser_manipulation.ef.md, browser_manipulation.ja.md, e todos os outros arquivos traduzidos. Se você encontrar uma tradução que possa ser melhorada, altere apenas o arquivo traduzido. Se você estiver adicionando uma nova tradução de idioma, adicione os novos arquivos com o sufixo apropriado. Não há necessidade de traduzir tudo para enviar um PR, pode ser feito iterativamente. Não se esqueça de verificar algumas configurações necessárias de valores no arquivo config.toml. Se você fizer alterações de texto na versão em inglês, substitua a mesma seção em os arquivos traduzidos com sua alteração (sim, em inglês), e adicione o seguinte observe na parte superior do arquivo.  {{% notice info %}} \u0026lt;i class=\u0026#34;fas fa-language\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; Page being translated from English to {LANGUAGE}. Do you speak {LANGUAGE}? Help us to translate it by sending us pull requests! {{% /notice %}} Passo 4: Commit Primeiro, certifique-se de que o git saiba seu nome e endereço de e-mail:\n% git config --global user.name \u0026#39;Santa Claus\u0026#39; % git config --global user.email \u0026#39;santa@example.com\u0026#39; Escrever boas mensagens de commit é importante. Uma mensagem de confirmação deve descrever o que mudou, por que e conter referência de problemas corrigidos (se houver). Siga estas diretrizes ao escrever um:\n A primeira linha deve ter cerca de 50 caracteres ou menos e conter uma breve da descrição da mudança. Mantenha a segunda linha em branco. Quebra todas as outras linhas em 72 colunas. Incluir Fixes # N, onde N é o número do problema que o commit corrige se houver.  Uma boa mensagem de confirmação pode ter a seguinte aparência:\nexplain commit normatively in one line Body of commit message is a few lines of text, explaining things in more detail, possibly giving some background about the issue being fixed, etc. The body of the commit message can be several paragraphs, and please do proper word-wrap and keep columns shorter than about 72 characters or so. That way `git log` will show things nicely even when it is indented. Fixes #141 A primeira linha deve ser significativa, pois é o que as pessoas veem quando executam git shortlog ou git log --oneline.\nPasso 5: Rebase Use git rebase (não git merge) para sincronizar seu trabalho de tempos em tempos.\n% git fetch upstream % git rebase upstream/trunk Passo 6: Teste Lembre-se sempre de executar o servidor local, com isso, você pode ter certeza de que suas alterações não prejudicaram nada.\nPasso 7: Push % git push origin my-feature-branch Acesse https://github.com/yourusername/seleniumhq.github.io.git e clique em Pull Request e preencha o formulário. Por favor indique que você assinou o CLA (consulte a Etapa 7).\nOs Pull Requests geralmente são revisados em alguns dias. Se houver comentários a abordar, aplique suas alterações em novos commits (de preferência fixups) e envie para a mesma branch.\nPasso 8: Integração Quando a revisão do código for concluída, um committer integrará seu PR no branch de tronco do repositório. Porque gostamos de manter um histórico linear no trunk, nós normalmente iremos dar Squash \u0026amp; Rebase no histórico da sua branch.\nComunicação Todos os detalhes sobre como se comunicar com os colaboradores do projeto e a comunidade em geral podem ser encontrados em https://selenium.dev/support\n"},{"uri":"https://www.selenium.dev/documentation/pt-br/","title":"O Projeto Selenium de Automação de Navegadores","tags":[],"description":"","content":"O Projeto Selenium de Automação de Navegadores Selenium é um projeto que abrange uma variedade de ferramentas e bibliotecas que permitem e suportam a automação de navegadores da web.\nEle fornece extensões para emular a interação do usuário com os navegadores, um servidor de distribuição para escalonar a alocação do navegador, e a infraestrutura para implementações da Especificação W3C WebDriver que permite escrever código intercambiável para todos os principais navegadores da web.\nEste projeto é possível graças a colaboradores voluntários que dedicam milhares de horas de seu próprio tempo, e disponibilizaram o código-fonte disponível gratuitamente para qualquer um usar, aproveitar e melhorar.\nSelenium reúne criadores de navegadores, engenheiros e entusiastas para promover uma discussão aberta sobre a automação da plataforma da web. O projeto organiza uma conferência anual para ensinar e nutrir a comunidade.\nNo núcleo do Selenium está WebDriver, uma interface para escrever conjuntos de instruções que podem ser executados alternadamente em muitos navegadores. Aqui está uma das instruções mais simples que você pode fazer:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.Keys; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; import org.openqa.selenium.support.ui.WebDriverWait; import static org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated; import java.time.Duration; public class HelloSelenium { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10)); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); WebElement firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\u0026#34;h3\u0026#34;))); System.out.println(firstResult.getAttribute(\u0026#34;textContent\u0026#34;)); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support.expected_conditions import presence_of_element_located #Este exemplo requer o Selenium WebDriver 3.13 ou mais novo with webdriver.Firefox() as driver: wait = WebDriverWait(driver, 10) driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.find_element(By.NAME, \u0026#34;q\u0026#34;).send_keys(\u0026#34;cheese\u0026#34; + Keys.RETURN) first_result = wait.until(presence_of_element_located((By.CSS_SELECTOR, \u0026#34;h3\u0026#34;))) print(first_result.get_attribute(\u0026#34;textContent\u0026#34;))   using System; using OpenQA.Selenium; using OpenQA.Selenium.Firefox; using OpenQA.Selenium.Support.UI; class HelloSelenium { static void Main() { using(IWebDriver driver = new FirefoxDriver()) { WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10)); driver.Navigate().GoToUrl(\u0026#34;https://www.google.com/ncr\u0026#34;); driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;cheese\u0026#34; + Keys.Enter); wait.Until(driver =\u0026gt;driver.FindElement(By.CssSelector(\u0026#34;h3\u0026#34;)).Displayed); IWebElement firstResult = driver.FindElement(By.CssSelector(\u0026#34;h3\u0026#34;)); Console.WriteLine(firstResult.GetAttribute(\u0026#34;textContent\u0026#34;)); } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox wait = Selenium::WebDriver::Wait.new(timeout: 10) begin driver.get \u0026#39;https://google.com/ncr\u0026#39; driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;cheese\u0026#39;, :return first_result = wait.until { driver.find_element(css: \u0026#39;h3\u0026#39;) } puts first_result.attribute(\u0026#39;textContent\u0026#39;) ensure driver.quit end   const {Builder, By, Key, until} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Enter text \u0026#34;cheese\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;  await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;cheese\u0026#39;, Key.ENTER); let firstResult = await driver.wait(until.elementLocated(By.css(\u0026#39;h3\u0026#39;)), 10000); console.log(await firstResult.getAttribute(\u0026#39;textContent\u0026#39;)); } finally{ driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.Keys import org.openqa.selenium.firefox.FirefoxDriver import org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated import org.openqa.selenium.support.ui.WebDriverWait import java.time.Duration fun main() { val driver = FirefoxDriver() val wait = WebDriverWait(driver, Duration.ofSeconds(10)) try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER) val firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\u0026#34;h3\u0026#34;))) println(firstResult.getAttribute(\u0026#34;textContent\u0026#34;)) } finally { driver.quit() } }     Veja o Tour rápido para uma explicação completa do que acontece nos bastidores quando você executa este código. Você deve continuar para a documentação narrativa para entender como você pode instalar e usar o Selenium como uma ferramenta de automação de teste com sucesso, e escalar testes simples como este para executar em ambientes grandes e distribuídos em vários navegadores, em vários sistemas operacionais diferentes.\nIntrodução Se você é um usuário novo de Selenium, temos alguns recursos que podem te ajudar a agilizar o seu aprendizado.\n Tour rápido  WebDriver IDE Grid    "},{"uri":"https://www.selenium.dev/documentation/pt-br/tags/","title":"Tags","tags":[],"description":"","content":""}]