<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Diretrizes e recomendações on Documentação do Selenium</title><link>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/</link><description>Recent content in Diretrizes e recomendações on Documentação do Selenium</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><copyright>2013-{year}</copyright><atom:link href="https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/index.xml" rel="self" type="application/rss+xml"/><item><title>Modelos de objetos de página</title><link>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/page_object_models/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/page_object_models/</guid><description>Objeto de página é um padrão de design que se tornou popular na automação de teste para melhorar a manutenção de teste e reduzir a duplicação de código. Um objeto de página é uma classe orientada a objetos que serve como uma interface para uma página de seu AUT. Os testes então usam os métodos desta classe de objeto de página sempre que precisam interagir com a interface do usuário dessa página.</description></item><item><title>Linguagem específica de domínio (DSL)</title><link>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/domain_specific_language/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/domain_specific_language/</guid><description>Uma linguagem específica de domínio (DSL) é um sistema que fornece ao usuário um meio expressivo de resolver um problema. Ele permite a um usuário interagir com o sistema em seus termos - não apenas na linguagem do programador.
Seus usuários, em geral, não se importam com a aparência do seu site. Eles não preocupam-se com a decoração, animações ou gráficos. Eles deseja usar seu sistema para empurrar seus novos funcionários através do processo com dificuldade mínima; eles querem reservar uma viagem para o Alasca; eles querem configurar e comprar unicórnios com desconto.</description></item><item><title>Gerando estado da aplicação</title><link>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/generating_application_state/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/generating_application_state/</guid><description>Selenium não deve ser usado para preparar um caso de teste. Tudo as ações repetitivas e preparações para um caso de teste devem ser feitas por meio de outros métodos. Por exemplo, a maioria das IUs da web tem autenticação (por exemplo, um formulário de login). Eliminar o login via navegador da web antes de cada teste irá melhorar a velocidade e estabilidade do teste. Um método deve ser criado para obter acesso à AUT* (por exemplo, usando uma API para fazer login e definir um cookie).</description></item><item><title>Simulação de serviços externos</title><link>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/mock_external_services/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/mock_external_services/</guid><description>Eliminar as dependências de serviços externos melhorará muito a velocidade e estabilidade de seus testes.</description></item><item><title>Relatórios melhorados</title><link>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/improved_reporting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/improved_reporting/</guid><description>O Selenium não foi projetado para relatar sobre o status de casos de teste. Aproveitar os recursos de relatórios integrados de frameworks de teste unitários é um bom começo. A maioria dos frameworks de teste unitários podem gerar relatórios formatados em xUnit ou HTML. Relatórios xUnit são populares para importar resultados para um servidor de integração contínua (CI) como Jenkins, Travis, Bamboo, etc. Aqui estão alguns links para obter mais informações sobre resultados de relatórios em vários idiomas.</description></item><item><title>Evite compartilhamento de estado</title><link>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/avoid_sharing_state/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/avoid_sharing_state/</guid><description>Embora mencionado em vários lugares, vale a pena mencionar novamente. Garanta que os testes são isolados uns dos outros.
Não compartilhe dados de teste. Imagine vários testes em que cada um consulta o banco de dados para pedidos válidos antes de escolher um para executar uma ação. Caso dois testes peguem a mesma ordem, provavelmente você obterá um comportamento inesperado.
Limpe dados desatualizados no aplicativo que podem ser obtidos por outro teste, por exemplo registros de pedidos inválidos.</description></item><item><title>Independência de Testes</title><link>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/test_independency/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/test_independency/</guid><description>Escreva cada teste como sua própria unidade. Escreva os testes de uma forma que não seja dependente de outros testes para concluir:
Digamos que existe um sistema de gerenciamento de conteúdo com o qual você pode criar algum conteúdo personalizado que então aparece em seu site como um módulo após publicação, e pode levar algum tempo para sincronizar entre o CMS e a aplicação.
Uma maneira errada de testar seu módulo é que o conteúdo seja criado e publicado em um teste e, em seguida, verificar o módulo em outro teste.</description></item><item><title>Considere usar uma API fluente</title><link>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/consider_using_a_fluent_api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/consider_using_a_fluent_api/</guid><description>Martin Fowler cunhou o termo &amp;ldquo;API Fluent&amp;rdquo;. Selenium já implementa algo assim em sua classe FluentWait, que é pretende ser uma alternativa à classe padrão Wait. Você pode habilitar o padrão de design de API fluente em seu objeto de página e, em seguida, consulte a página de pesquisa do Google com um snippet de código como este:
driver.get( &amp;#34;http://www.google.com/webhp?hl=en&amp;amp;amp;tab=ww&amp;#34; ); GoogleSearchPage gsp = new GoogleSearchPage(); gsp.withFluent().setSearchString().clickSearchButton(); A classe de objeto da página do Google com este comportamento fluente pode ser assim:</description></item><item><title>Navegador novo por teste</title><link>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/fresh_browser_per_test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/fresh_browser_per_test/</guid><description>Comece cada teste a partir de um estado limpo conhecido. Idealmente, ligue uma nova máquina virtual para cada teste. Se ligar uma nova máquina virtual não for prático, pelo menos inicie um novo WebDriver para cada teste. Para Firefox, inicie um WebDriver com seu perfil conhecido.
FirefoxProfile profile = new FirefoxProfile(new File(&amp;#34;pathToFirefoxProfile&amp;#34;)); WebDriver driver = new FirefoxDriver(profile);</description></item></channel></rss>