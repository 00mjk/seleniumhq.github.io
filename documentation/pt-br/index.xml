<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>O Projeto Selenium de Automação de Navegadores on Documentação do Selenium</title><link>https://www.selenium.dev/documentation/pt-br/</link><description>Recent content in O Projeto Selenium de Automação de Navegadores on Documentação do Selenium</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><copyright>2013-{year}</copyright><atom:link href="https://www.selenium.dev/documentation/pt-br/index.xml" rel="self" type="application/rss+xml"/><item><title>Autenticação de Dois Fatores (2FA)</title><link>https://www.selenium.dev/documentation/pt-br/worst_practices/two_factor_authentication/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/worst_practices/two_factor_authentication/</guid><description>A autenticação de dois fatores, conhecida como 2FA, é um mecanismo de autorização onde a senha de uso único (OTP) é gerada usando aplicativos móveis &amp;ldquo;Autenticadores&amp;rdquo;, como &amp;ldquo;Google Authenticator&amp;rdquo;, &amp;ldquo;Microsoft Authenticator&amp;rdquo; etc., ou por SMS, e-mail para autenticação. Automatizar isso perfeitamente e consistentemente é um grande desafio no Selenium. Existem algumas maneiras para automatizar este processo. Mas essa será outra camada em cima de nossos testes Selenium e não protegidos também.</description></item><item><title>Captchas</title><link>https://www.selenium.dev/documentation/pt-br/worst_practices/captchas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/worst_practices/captchas/</guid><description>CAPTCHA, abreviação de Completely Automated Public Turing test to tell Computers and Humans Apart, foi projetado explicitamente para impedir a automação, portanto, não tente! Existem duas estratégias principais para contornar as verificações CAPTCHA:
Desative CAPTCHAs em seu ambiente de teste Adicione um hook para permitir que os testes ignorem o CAPTCHA</description></item><item><title>Componentes</title><link>https://www.selenium.dev/documentation/pt-br/grid/grid_3/components_of_a_grid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/grid/grid_3/components_of_a_grid/</guid><description>Hub Intermediário e gerente Aceita solicitações para executar testes Recebe instruções do cliente e as executa remotamente nos nós Gerencia tópicos Um Hub é um ponto central para onde todos os seus testes são enviados. Cada Selenium Grid consiste em exatamente um hub. O hub precisa estar acessível dos respectivos clientes (ou seja, servidor de CI, máquina do desenvolvedor etc.) O hub irá conectar um ou mais nós aos quais os testes serão delegados.</description></item><item><title>Componentes</title><link>https://www.selenium.dev/documentation/pt-br/grid/grid_4/components_of_a_grid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/grid/grid_4/components_of_a_grid/</guid><description>Roteador O roteador se encarrega de encaminhar a solicitação para o componente correto.
É o ponto de entrada da Grid, todas as solicitações externas serão recebidas por ele. O roteador se comporta de maneira diferente dependendo da solicitação. Se for uma nova sessão, o roteador irá encaminhá-la para o enfileirador de sessão, que irá adicioná-la a nova fila de sessão. O Enfileirador de Sessão irá disparar um evento através do Event Bus.</description></item><item><title>Direitos autorais e atribuições</title><link>https://www.selenium.dev/documentation/pt-br/front_matter/copyright_and_attributions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/front_matter/copyright_and_attributions/</guid><description>A Documentação do Selenium Copyright &amp;copy; 2013-2021 , Software Freedom Conservancy.
Todo esforço foi feito para tornar esta documentação a mais completa e precisa possível, mas nenhuma garantia ou adequação está implícita. As informações fornecidas são &amp;ldquo;no estado em que se encontram&amp;rdquo;. Os autores e a editora não terão qualquer responsabilidade para com qualquer pessoa ou entidade com relação a quaisquer perdas ou danos decorrentes das informações contidas neste livro. Nenhuma responsabilidade de patente é assumida com relação ao uso das informações aqui contidas.</description></item><item><title>Entendendo os componentes</title><link>https://www.selenium.dev/documentation/pt-br/webdriver/understanding_the_components/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/webdriver/understanding_the_components/</guid><description>Construir um conjunto de testes usando WebDriver exigirá que você entenda e use efetivamente uma série de componentes diferentes. Como com tudo em software, pessoas diferentes usam termos diferentes para a mesma ideia. Abaixo está uma análise de como os termos são usados nesta descrição.
Terminologia API: interface de programação de aplicativo. Este é o conjunto de &amp;ldquo;comandos&amp;rdquo; que você usa para manipular o WebDriver. Biblioteca: um módulo de código que contém as APIs e o código necessário para implementá-los.</description></item><item><title>Instalando bibliotecas do Selenium</title><link>https://www.selenium.dev/documentation/pt-br/selenium_installation/installing_selenium_libraries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/selenium_installation/installing_selenium_libraries/</guid><description>Primeiro você precisa instalar as ligações Selenium para seu projeto de automação. O processo de instalação de bibliotecas depende da linguagem que você escolher usar.
Java A instalação de bibliotecas Selenium para Java pode ser feita usando Maven. Adicione a dependência selenium-java em seu pom.xml:
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.seleniumhq.selenium&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;selenium-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.X&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; A dependência selenium-java suporta a execução de sua automação com todos os navegadores com suporte Selenium. Se você quiser fazer testes apenas em um navegador específico, você pode adicionar a dependência para esse navegador em seu arquivo pom.</description></item><item><title>Modelos de objetos de página</title><link>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/page_object_models/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/page_object_models/</guid><description>Objeto de página é um padrão de design que se tornou popular na automação de teste para melhorar a manutenção de teste e reduzir a duplicação de código. Um objeto de página é uma classe orientada a objetos que serve como uma interface para uma página de seu AUT. Os testes então usam os métodos desta classe de objeto de página sempre que precisam interagir com a interface do usuário dessa página.</description></item><item><title>Navegadores</title><link>https://www.selenium.dev/documentation/pt-br/getting_started_with_webdriver/browsers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/getting_started_with_webdriver/browsers/</guid><description>Navegadores comerciais O framework Selenium oferece suporte oficial aos seguintes navegadores:
Navegador Mantenedor Versões Suportadas Chrome Chromium Todas as versões Firefox Mozilla 54 ou mais nova Edge Microsoft 84 ou mais nova Internet Explorer Selenium 6 ou mais nova Opera Opera Chromium / Presto 10.5 ou mais nova Safari Apple 10 ou mais nova Navegadores especializados Também existe um conjunto de navegadores especializados por aí normalmente usados em ambientes de desenvolvimento.</description></item><item><title>O projeto Selenium e ferramentas</title><link>https://www.selenium.dev/documentation/pt-br/introduction/the_selenium_project_and_tools/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/introduction/the_selenium_project_and_tools/</guid><description>Selenium controla navegadores Selenium é muitas coisas mas, em sua essência, é um conjunto de ferramentas para automação de navegador da web que usa as melhores técnicas disponíveis para controlar remotamente as instâncias do navegador e emular a interação do usuário com o navegador.
Ele permite que os usuários simulem atividades comuns realizadas por usuários finais; inserir texto em campos, selecionando valores suspensos e caixas de seleção, e clicar em links em documentos.</description></item><item><title>Objetivos e funcionalidades principais</title><link>https://www.selenium.dev/documentation/pt-br/grid/purposes_and_main_functionalities/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/grid/purposes_and_main_functionalities/</guid><description> Ponto de entrada central para todos os testes Gerenciamento e controle dos nós / ambiente onde os navegadores rodam Escalonamento Executar testes em paralelo Teste de plataforma cruzada Balanceamento de carga</description></item><item><title>Recursos compartilhados</title><link>https://www.selenium.dev/documentation/pt-br/driver_idiosyncrasies/shared_capabilities/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/driver_idiosyncrasies/shared_capabilities/</guid><description>Para criar uma nova sessão por Selenium WebDriver, a extremidade local deve fornecer os recursos básicos para a extremidade remota. A extremidade remota usa o mesmo conjunto de recursos para cria uma sessão e descreve os recursos da sessão atual.
WebDriver fornece recursos que cada controle extremidade remota irá/deverá apoiar a implementação. A seguir estão os recursos que o WebDriver suporta:
browserName: Este recurso é usado para definir o browserName para uma determinada sessão.</description></item><item><title>Selenium 1 (Selenium RC)</title><link>https://www.selenium.dev/documentation/pt-br/legacy_docs/selenium_rc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/legacy_docs/selenium_rc/</guid><description>Introdução Selenium RC foi o principal projeto da Selenium por muito tempo, antes da fusão WebDriver / Selenium trazer o Selenium 2, uma ferramenta mais poderosa. Vale ressaltar que não há mais suporte para Selenium 1.
Como o Selenium RC funciona Primeiro, vamos descrever como os componentes do Selenium RC operam e o papel que cada um desempenha na execução de seus scripts de teste.
Componentes do RC Os componentes do Selenium RC são:</description></item><item><title>Tour rápido</title><link>https://www.selenium.dev/documentation/pt-br/getting_started/quick/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/getting_started/quick/</guid><description>Selenium não é só uma ferramenta ou API, mas sim uma composição de várias ferramentas.
WebDriver Se você está começando com automação de testes de um site de desktop ou site para celular, então vai usar as APIs WebDriver. O WebDriver usa APIs de automação de navegador disponibilizadas por fornecedores de navegador para o controlar e executar testes. É como se um usuário real o estivesse operando. Como o WebDriver não exige que sua API seja compilada com o código do aplicativo, não é intrusivo.</description></item><item><title>Cliente do WebDriver remoto</title><link>https://www.selenium.dev/documentation/pt-br/remote_webdriver/remote_webdriver_client/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/remote_webdriver/remote_webdriver_client/</guid><description>Para executar um cliente WebDriver remoto, primeiro precisamos nos conectar ao RemoteWebDriver. Fazemos isso apontando a URL para o endereço do servidor que está executando nossos testes. Para personalizar nossa configuração, definimos os recursos desejados. Abaixo está um exemplo de como instanciar um objeto WebDriver remoto apontando para nosso servidor remoto da web, www.example.com, executando nossos testes no Firefox.
Java Python C# Ruby JavaScript Kotlin FirefoxOptions firefoxOptions = new FirefoxOptions(); WebDriver driver = new RemoteWebDriver(new URL(&amp;#34;http://www.</description></item><item><title>Configurando a sua</title><link>https://www.selenium.dev/documentation/pt-br/grid/grid_3/setting_up_your_own_grid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/grid/grid_3/setting_up_your_own_grid/</guid><description>Para usar Selenium Grid, você precisa manter sua própria infraestrutura para os nós. Como isso pode ser um esforço pesado e intenso, muitas organizações usam provedores IaaS como Amazon EC2 e Google Compute para fornecer essa infraestrutura.
Outras opções incluem o uso de provedores como Sauce Labs ou Testing Bot que fornecem uma Selenium Grid como um serviço na nuvem. Certamente também é possível executar nós em seu próprio hardware. Este capítulo entrará em detalhes sobre a opção de executar sua própria Grid, completo com sua própria infraestrutura de nós.</description></item><item><title>Configurando a sua</title><link>https://www.selenium.dev/documentation/pt-br/grid/grid_4/setting_up_your_own_grid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/grid/grid_4/setting_up_your_own_grid/</guid><description>Diferentes modos de configuração de Grid no Selenium 4: Standalone Hub and Node Distributed Docker Modo Standalone: O novo Selenium Server Jar contém tudo que você precisa para executar uma Grid. É também o modo mais fácil de ligar uma Selenium Grid. Por padrão, o servidor estará escutando em http://localhost:4444, e essa é a URL para a qual você deve apontar seus testes RemoteWebDriver. O servidor detectará os drivers disponíveis que podem ser usados no PATH do sistema</description></item><item><title>Convenções tipográficas</title><link>https://www.selenium.dev/documentation/pt-br/front_matter/typographical_conventions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/front_matter/typographical_conventions/</guid><description>Capitalização de títulos Deve-se evitar a capitalização do título, como Um Título Muito Estiloso, e em vez disso, use Um título muito estiloso. Letras maiúsculas gratuitas, ou caixa do título, muitas vezes mostram um mal-entendido - ou um desprezo por - convenções ortográficas. Preferimos o que é conhecido como sentence case, com uma única inicial maiúscula para iniciar cabeçalhos.
Comprimento da linha Ao editar o código fonte da documentação, que é escrito em HTML puro, limite o comprimento das linhas a cerca de 72 caracteres.</description></item><item><title>Downloads de arquivo</title><link>https://www.selenium.dev/documentation/pt-br/worst_practices/file_downloads/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/worst_practices/file_downloads/</guid><description>Embora seja possível iniciar um download clicando em um link com um navegador sob o controle do Selenium, a API não expõe o progresso do download, tornando-o menos do que ideal para testar arquivos baixados. Isso ocorre porque o download de arquivos não é considerado um aspecto importante de emular a interação do usuário com a plataforma da web. Em vez disso, encontre o link usando Selenium (e todos os cookies necessários) e passe este cookie para uma biblioteca de solicitação HTTP como libcurl.</description></item><item><title>Drivers e plugins de terceiros</title><link>https://www.selenium.dev/documentation/pt-br/getting_started_with_webdriver/third_party_drivers_and_plugins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/getting_started_with_webdriver/third_party_drivers_and_plugins/</guid><description>Selenium pode ser estendido com o uso de plug-ins. Aqui estão alguns plugins criados e mantidos por terceiros. Para obter mais informações sobre como para criar seu próprio plugin ou listá-lo, consulte a documentação.
Observe que esses plug-ins não são suportados, mantidos, hospedados ou endossados pelo projeto Selenium. Além disso, esteja ciente de que os plug-ins listados abaixo não são necessariamente licenciados sob a Licença Apache v.2.0. Alguns dos plug-ins estão disponíveis em outro software de código aberto e gratuito licença; outros estão disponíveis apenas sob licença proprietária.</description></item><item><title>Instalando binários do WebDriver</title><link>https://www.selenium.dev/documentation/pt-br/selenium_installation/installing_webdriver_binaries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/selenium_installation/installing_webdriver_binaries/</guid><description>Para executar seu projeto e controlar o navegador, você precisa ter binários WebDriver específicos do navegador instalados.
Baixe o binário WebDriver suportado pelo seu navegador e coloque-o no System PATH.</description></item><item><title>Linguagem específica de domínio (DSL)</title><link>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/domain_specific_language/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/domain_specific_language/</guid><description>Uma linguagem específica de domínio (DSL) é um sistema que fornece ao usuário um meio expressivo de resolver um problema. Ele permite a um usuário interagir com o sistema em seus termos - não apenas na linguagem do programador.
Seus usuários, em geral, não se importam com a aparência do seu site. Eles não preocupam-se com a decoração, animações ou gráficos. Eles deseja usar seu sistema para empurrar seus novos funcionários através do processo com dificuldade mínima; eles querem reservar uma viagem para o Alasca; eles querem configurar e comprar unicórnios com desconto.</description></item><item><title>Migrando do RC para WebDriver</title><link>https://www.selenium.dev/documentation/pt-br/legacy_docs/migrating_from_rc_to_webdriver/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/legacy_docs/migrating_from_rc_to_webdriver/</guid><description>Como migrar para o Selenium WebDriver Uma pergunta comum ao adotar o Selenium 2 é qual é a coisa certa a fazer ao adicionar novos testes a um conjunto existente de testes? Usuários que são novos no framework podem começar usando as novas APIs WebDriver para escrever seus testes. Mas e os usuários que já possuem suítes de testes existentes? Este guia é projetado para demonstrar como migrar seus testes existentes para as novas APIs, permitindo que todos os novos testes sejam escritos usando os novos recursos oferecidos pelo WebDriver.</description></item><item><title>Quando usar a Grid</title><link>https://www.selenium.dev/documentation/pt-br/grid/when_to_use_grid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/grid/when_to_use_grid/</guid><description>De modo geral, há dois motivos pelos quais você pode querer usar a Grid.
Para executar seus testes em vários navegadores, várias versões de navegador, e navegadores executados em diferentes sistemas operacionais. Para reduzir o tempo que leva para o conjunto de testes concluir uma aprovação no teste. A Grid é usada para acelerar a execução dos testes usando várias máquinas para executar testes em paralelo. Por exemplo, se você tiver um conjunto de 100 testes, mas você configurou o Grid para suportar 4 máquinas diferentes (VMs ou máquinas físicas separadas) para executar esses testes, seu conjunto de testes será concluído em (aproximadamente) um quarto do tempo, do que se você executasse seus testes sequencialmente em uma única máquina.</description></item><item><title>Recursos específicos do Driver</title><link>https://www.selenium.dev/documentation/pt-br/driver_idiosyncrasies/driver_specific_capabilities/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/driver_idiosyncrasies/driver_specific_capabilities/</guid><description>Firefox Definindo recursos usando FirefoxOptions FirefoxOptions é a nova forma de definir recursos para o Navegador Firefox e geralmente deve ser usado em detrimento de DesiredCapabilities.
Java Python C# Ruby JavaScript Kotlin FirefoxOptions options = new FirefoxOptions(); options.addPreference(&amp;#34;network.proxy.type&amp;#34;, 0); driver = new RemoteWebDriver(options); from selenium.webdriver.firefox.options import Options options = Options() options.headless = True driver = webdriver.Firefox(options=options) var options = new FirefoxOptions(); options.Proxy.Kind = ProxyKind.Direct; var driver = new FirefoxDriver(options); require &amp;#39;selenium-webdriver&amp;#39; opts = Selenium::WebDriver::Firefox::Options.</description></item><item><title>Requerimentos do driver</title><link>https://www.selenium.dev/documentation/pt-br/webdriver/driver_requirements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/webdriver/driver_requirements/</guid><description>Por meio do WebDriver, o Selenium oferece suporte a todos os principais navegadores do mercado como Chrom(ium), Firefox, Internet Explorer, Opera e Safari. Sempre que possível, o WebDriver dirige o navegador usando o suporte integrado do navegador para automação, embora nem todos os navegadores tenham suporte oficial para controle remoto.
O objetivo do WebDriver é emular a interação de um usuário real com o navegador o mais próximo possível. Isso é possível em vários níveis em diferentes navegadores.</description></item><item><title>Sobre automação de testes</title><link>https://www.selenium.dev/documentation/pt-br/introduction/on_test_automation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/introduction/on_test_automation/</guid><description>Primeiro, comece perguntando a si mesmo se você realmente precisa ou não de um navegador. As probabilidades são de que, em algum ponto, se você estiver trabalhando em um aplicativo da web complexo, você precisará abrir um navegador e realmente testá-lo.
No entanto, os testes funcionais do usuário final, como os testes Selenium, são caros para executar. Além disso, eles normalmente exigem infraestrutura substancial para ser executado de forma eficaz. É uma boa regra sempre se perguntar se o que você deseja testar pode ser feito usando abordagens de teste mais leves, como testes de unidade ou com uma abordagem de nível inferior.</description></item><item><title>Trabalhando com cores</title><link>https://www.selenium.dev/documentation/pt-br/support_packages/working_with_colours/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/support_packages/working_with_colours/</guid><description>Ocasionalmente, você desejará validar a cor de algo como parte de seus testes; o problema é que as definições de cores na web não são constantes. Não seria bom se houvesse uma maneira fácil de comparar uma representação HEX de uma cor com uma representação RGB de uma cor, ou uma representação RGBA de uma cor com uma representação HSLA de uma cor?
Não se preocupe. Existe uma solução: a classe Color!</description></item><item><title>Códigos de respostas HTTP</title><link>https://www.selenium.dev/documentation/pt-br/worst_practices/http_response_codes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/worst_practices/http_response_codes/</guid><description>Para algumas configurações de navegador no Selenium RC, Selenium atuou como um proxy entre o navegador e o site sendo automatizado. Isso significa que todo o tráfego do navegador que passou pelo Selenium poderia ser capturado ou manipulado. O método captureNetworkTraffic() pretendia capturar todo o tráfego de rede entre o navegador e o site sendo automatizado, incluindo códigos de resposta HTTP.
Selenium WebDriver é uma abordagem completamente diferente para a automação do navegador, preferindo agir mais como um usuário.</description></item><item><title>Gerando estado da aplicação</title><link>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/generating_application_state/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/generating_application_state/</guid><description>Selenium não deve ser usado para preparar um caso de teste. Tudo as ações repetitivas e preparações para um caso de teste devem ser feitas por meio de outros métodos. Por exemplo, a maioria das IUs da web tem autenticação (por exemplo, um formulário de login). Eliminar o login via navegador da web antes de cada teste irá melhorar a velocidade e estabilidade do teste. Um método deve ser criado para obter acesso à AUT* (por exemplo, usando uma API para fazer login e definir um cookie).</description></item><item><title>HTML runner</title><link>https://www.selenium.dev/documentation/pt-br/legacy_docs/html-runner/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/legacy_docs/html-runner/</guid><description>Selenium HTML-runner permite que você execute suítes de teste da linha de comando. Suítes de teste são exportações de HTML do Selenium IDE ou ferramentas compatíveis.
Informação comum Combinação de lançamentos de geckodriver / firefox / selenium-html-runner são importantes. Pode haver um software matriz de compatibilidade em algum lugar. selenium-html-runner executa apenas suítes de teste (não casos de teste - por exemplo, uma exportação do Monitis Transaction Monitor). Certifique-se de cumprir isso.</description></item><item><title>Instalando o servidor Standalone</title><link>https://www.selenium.dev/documentation/pt-br/selenium_installation/installing_standalone_server/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/selenium_installation/installing_standalone_server/</guid><description>Se você planeja usar Grid, você deve baixar o arquivo selenium-server-standalone JAR. Todos os componentes estão disponíveis via selenium-server. O JAR Standalone contém tudo, incluindo o servidor Selenium remoto e as ligações do lado do cliente. Isso significa que se você usar o jar selenium-server-standalone em seu projeto, você não precisa adicionar selenium-java ou um jar específico do navegador.
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.seleniumhq.selenium&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;selenium-server&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.X&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;</description></item><item><title>Localizando elementos</title><link>https://www.selenium.dev/documentation/pt-br/webdriver/locating_elements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/webdriver/locating_elements/</guid><description>Localizando elementos Uma das técnicas mais fundamentais para aprender ao usar o WebDriver é como encontrar elementos na página. WebDriver oferece uma série de tipos de seletores embutidos, entre eles encontrar um elemento por seu atributo de ID:
Java Python C# Ruby JavaScript Kotlin WebElement cheese = driver.findElement(By.id(&amp;#34;cheese&amp;#34;)); driver.find_element(By.ID, &amp;#34;cheese&amp;#34;) IWebElement element = driver.FindElement(By.Id(&amp;#34;cheese&amp;#34;)); cheese = driver.find_element(id: &amp;#39;cheese&amp;#39;) const cheese = driver.findElement(By.id(&amp;#39;cheese&amp;#39;)); val cheese: WebElement = driver.</description></item><item><title>Manipulação do Browser</title><link>https://www.selenium.dev/documentation/pt-br/webdriver/browser_manipulation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/webdriver/browser_manipulation/</guid><description>Ruby Ruby não está instalado por padrão no Windows. Baixe a versão mais recente e execute o instalador. Você podedeixar todas as configurações com os valores padrão, exceto na tela Installation Destination and Optional Tasks verifique onde você precisa marca a caixa de seleção Add Ruby executables to your PATH. Para utilizar qualquer navegador, você deve instalar a gem de Ruby selenium-webdriver. Para instalá-lo, abra o prompt de comando e digite isto:</description></item><item><title>Suporte a buscas em GraphQL</title><link>https://www.selenium.dev/documentation/pt-br/grid/grid_4/graphql_support/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/grid/grid_4/graphql_support/</guid><description>GraphQL é uma linguagem de consulta para APIs e um runtime para atender a essas consultas com seus dados existentes. Ele dá aos usuários o poder de pedir exatamente o que precisam e nada mais.
Enums Enums representam possíveis conjuntos de valores para um campo.
Por exemplo, o objeto Node possui um campo chamado status. O estado é um enum (especificamente, do tipo Status) porque pode ser UP, DRAINING ou UNAVAILABLE.</description></item><item><title>Tipos de teste</title><link>https://www.selenium.dev/documentation/pt-br/introduction/types_of_testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/introduction/types_of_testing/</guid><description>Teste de aceitação Este tipo de teste é feito para determinar se um recurso ou sistema atende às expectativas e requisitos do cliente. Este tipo de teste geralmente envolve cooperação ou feedback do cliente, sendo uma atividade de validação que responde a pergunta:
Estamos construindo o produto certo?.
Para aplicações web, a automação desse teste pode ser feita diretamente com o Selenium, simulando o comportamento esperado do usuário. Esta simulação pode ser feita por gravação / reprodução ou por meio dos diferentes idiomas suportados, conforme explicado nesta documentação.</description></item><item><title>Trabalhando com elementos select</title><link>https://www.selenium.dev/documentation/pt-br/support_packages/working_with_select_elements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/support_packages/working_with_select_elements/</guid><description>Os elementos select podem exigir um pouco de código padrão para serem automatizados. Para reduzir isso e tornar seus testes mais limpos, existe uma Classe Select no pacote de suporte do Selenium. Para usá-lo, você precisará da seguinte instrução de importação:
Java Python C# Ruby JavaScript Kotlin import org.openqa.selenium.support.ui.Select; from selenium.webdriver.support.select import Select using OpenQA.Selenium.Support.UI include Selenium::WebDriver::Support // This feature is not implemented - Help us by sending a pr to implement this feature import org.</description></item><item><title>WebDriver Bidi APIs</title><link>https://www.selenium.dev/documentation/pt-br/webdriver/bidi_apis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/webdriver/bidi_apis/</guid><description>Page being translated from English to Portuguese. Do you speak Portuguese? Help us to translate it by sending us pull requests!
In Selenium 4, new Evented APIs were introduced that allow users to be able to capture events from the browser as they happen rather than using the traditional approach of Request/Response that WebDriver has used for other APIs.
Internally WebDriver will create a WebSocket connection to the browser for events and commands to be transmitted.</description></item><item><title>Ações do mouse em detalhe</title><link>https://www.selenium.dev/documentation/pt-br/support_packages/mouse_and_keyboard_actions_in_detail/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/support_packages/mouse_and_keyboard_actions_in_detail/</guid><description>Mouse representa um evento do mouse. Ações do mouse são realizadas usando interface de baixo nível que nos permite fornecer ação de entrada de dispositivo virtualizado para o navegador da web.
clickAndHold Ele se moverá para o elemento e clicar (sem soltar) no meio do elemento fornecido.
Java Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class clickAndHold { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url driver.</description></item><item><title>Esperas</title><link>https://www.selenium.dev/documentation/pt-br/webdriver/waits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/webdriver/waits/</guid><description>Geralmente, pode-se dizer que o WebDriver tem uma API de blocante. Porque é uma biblioteca fora de processo que instrui ao navegador o que fazer, e porque a plataforma web tem uma natureza intrinsecamente assíncrona, O WebDriver não rastreia o estado ativo em tempo real do DOM. Isso traz alguns desafios que discutiremos aqui.
Por experiência, a maioria dos problemas intermitentes que surgem do uso de Selenium e WebDriver estão conectados a condições de corrida que ocorrem entre o navegador e as instruções do usuário.</description></item><item><title>Login via Gmail, email e Facebook</title><link>https://www.selenium.dev/documentation/pt-br/worst_practices/gmail_email_and_facebook_logins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/worst_practices/gmail_email_and_facebook_logins/</guid><description>Por vários motivos, fazer login em sites como Gmail e Facebook usando do WebDriver não é recomendado. Além de ser contra os termos de uso desses sites (onde você corre o risco de ter a conta encerrada), é lento e não confiável.
A prática ideal é usar as APIs que os provedores de e-mail oferecem, ou no caso do Facebook, o serviço de ferramentas para desenvolvedores que expõe uma API para criar contas de teste, amigos e assim por diante.</description></item><item><title>Rotas da Grid</title><link>https://www.selenium.dev/documentation/pt-br/grid/grid_4/grid_endpoints/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/grid/grid_4/grid_endpoints/</guid><description>Grid Status da Grid O status da Grid fornece o estado atual da grid. Consiste em detalhes sobre cada nó registrado. Para cada nó, o status inclui informações sobre a disponibilidade, sessões e slots do nó.
cURL GET &amp;#39;http://localhost:4444/status&amp;#39; No modo Standalone, o URL da Grid é o endereço do servidor Standalone.
No modo Hub-Node, a URL da Grid é o endereço do servidor Hub.
No modo totalmente distribuído, a URL da Grid é o endereço do servidor do roteador.</description></item><item><title>Selenium IDE Legado</title><link>https://www.selenium.dev/documentation/pt-br/legacy_docs/selenium_ide/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/legacy_docs/selenium_ide/</guid><description>Introdução A Selenium-IDE (Integrated Development Environment) é a ferramenta que você usa para desenvolver seus casos de teste Selenium. É um plug-in do Firefox fácil de usar e é geralmente a maneira mais eficiente de desenvolver casos de teste. Ela também contém um menu de contexto que permite que você primeiro selecione um elemento de UI do navegador atualmente exibido na página e, em seguida, selecione de uma lista de comandos Selenium com parâmetros predefinidos de acordo com o contexto do elemento de UI selecionado.</description></item><item><title>Simulação de serviços externos</title><link>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/mock_external_services/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/mock_external_services/</guid><description>Eliminar as dependências de serviços externos melhorará muito a velocidade e estabilidade de seus testes.</description></item><item><title>Sobre esta documentação</title><link>https://www.selenium.dev/documentation/pt-br/introduction/about_this_documentation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/introduction/about_this_documentation/</guid><description>Essa documentação, como o próprio código, são mantidos 100% por voluntários dentro da comunidade Selenium. Muitos têm usado desde o seu início, mas muitos mais o usam há pouco tempo, e dedicaram seu tempo para ajudar a melhorar a experiência de integração para novos usuários.
Se houver algum problema com a documentação, queremos saber! A melhor maneira de comunicar um problema é visitar https://github.com/seleniumhq/seleniumhq.github.io/issues e pesquise se o problema já foi ou não arquivado.</description></item><item><title>Classes de suporte</title><link>https://www.selenium.dev/documentation/pt-br/webdriver/support_classes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/webdriver/support_classes/</guid><description>As classes de suporte do WebDriver são fornecidas para simplificar a manutenção do seu código. Eles fornecem uma boa abstração para fazer a modelagem de elemento(s) HTML como objetos de domínio mais fáceis, também fornecendo métodos auxiliares para tornar o uso de tais objetos fácil de se pensar. Vamos aprender sobre:
Estratégias de localizador Eventos LoadableComponent ThreadGuard etc. Vamos começar:
ThreadGuard Esta classe está disponível apenas no Java Binding</description></item><item><title>Dependência entre testes</title><link>https://www.selenium.dev/documentation/pt-br/worst_practices/test_dependency/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/worst_practices/test_dependency/</guid><description>Uma ideia comum e um equívoco sobre o teste automatizado é sobre uma ordem de testes específica. Seus testes devem ser executados em qualquer ordem, e não depender da conclusão de outros testes para ter sucesso.</description></item><item><title>Relatórios melhorados</title><link>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/improved_reporting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/improved_reporting/</guid><description>O Selenium não foi projetado para relatar sobre o status de casos de teste. Aproveitar os recursos de relatórios integrados de frameworks de teste unitários é um bom começo. A maioria dos frameworks de teste unitários podem gerar relatórios formatados em xUnit ou HTML. Relatórios xUnit são populares para importar resultados para um servidor de integração contínua (CI) como Jenkins, Travis, Bamboo, etc. Aqui estão alguns links para obter mais informações sobre resultados de relatórios em vários idiomas.</description></item><item><title>Servidor do WebDriver remoto</title><link>https://www.selenium.dev/documentation/pt-br/legacy_docs/remote_webdriver_server/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/legacy_docs/remote_webdriver_server/</guid><description>O servidor sempre será executado na máquina com o navegador que você deseja testar. O servidor pode ser usado a partir da linha de comando ou por meio de configuração de código.
Iniciando o servidor a partir da linha de comando Depois de fazer o download do selenium-server-standalone-{VERSION}.jar, coloque-o no computador com o navegador que deseja testar. Então, a partir do diretório com o jar, execute o seguinte:
java -jar selenium-server-standalone-{VERSION}.</description></item><item><title>Alertas, prompts e confirmações JavaScript</title><link>https://www.selenium.dev/documentation/pt-br/webdriver/js_alerts_prompts_and_confirmations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/webdriver/js_alerts_prompts_and_confirmations/</guid><description>WebDriver fornece uma API para trabalhar com os três tipos nativos de mensagens pop-up oferecidas pelo JavaScript. Esses pop-ups são estilizados pelo navegador e oferecem personalização limitada.
Alertas O mais simples deles é referido como um alerta, que mostra um mensagem personalizada e um único botão que dispensa o alerta, rotulado na maioria dos navegadores como OK. Ele também pode ser dispensado na maioria dos navegadores pressionando o botão Fechar, mas isso sempre fará a mesma coisa que o botão OK.</description></item><item><title>Evite compartilhamento de estado</title><link>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/avoid_sharing_state/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/avoid_sharing_state/</guid><description>Embora mencionado em vários lugares, vale a pena mencionar novamente. Garanta que os testes são isolados uns dos outros.
Não compartilhe dados de teste. Imagine vários testes em que cada um consulta o banco de dados para pedidos válidos antes de escolher um para executar uma ação. Caso dois testes peguem a mesma ordem, provavelmente você obterá um comportamento inesperado.
Limpe dados desatualizados no aplicativo que podem ser obtidos por outro teste, por exemplo registros de pedidos inválidos.</description></item><item><title>Teste de performance/desempenho</title><link>https://www.selenium.dev/documentation/pt-br/worst_practices/performance_testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/worst_practices/performance_testing/</guid><description>Teste de desempenho usando Selenium e WebDriver geralmente não é recomendado. Não porque é incapaz, mas porque não é otimizado para o trabalho e é improvável que você obtenha bons resultados.
Pode parecer ideal para teste de desempenho no contexto do usuário, mas um conjunto de testes WebDriver estão sujeitos a muitos pontos de fragilidade externa e interna que estão além do seu controle; por exemplo, velocidade de inicialização do navegador, velocidade dos servidores HTTP, resposta de servidores de terceiros que hospedam JavaScript ou CSS, e a penalidade de instrumentação da própria implementação do WebDriver.</description></item><item><title>Trabalhando com cookies</title><link>https://www.selenium.dev/documentation/pt-br/support_packages/working_with_cookies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/support_packages/working_with_cookies/</guid><description>Um cookie é um pequeno pedaço de dado enviado de um site e armazenado no seu computador. Os cookies são usados principalmente para reconhecer o usuário e carregar as informações armazenadas.
A API WebDriver fornece uma maneira de interagir com cookies com métodos integrados:
Add Cookie É usado para adicionar um cookie ao contexto de navegação atual. Add Cookie aceita apenas um conjunto de objetos JSON serializáveis definidos. Aqui é o link para a lista de valores-chave JSON aceitos.</description></item><item><title>Independência de Testes</title><link>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/test_independency/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/test_independency/</guid><description>Escreva cada teste como sua própria unidade. Escreva os testes de uma forma que não seja dependente de outros testes para concluir:
Digamos que existe um sistema de gerenciamento de conteúdo com o qual você pode criar algum conteúdo personalizado que então aparece em seu site como um módulo após publicação, e pode levar algum tempo para sincronizar entre o CMS e a aplicação.
Uma maneira errada de testar seu módulo é que o conteúdo seja criado e publicado em um teste e, em seguida, verificar o módulo em outro teste.</description></item><item><title>Navegação por links</title><link>https://www.selenium.dev/documentation/pt-br/worst_practices/link_spidering/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/worst_practices/link_spidering/</guid><description>Usar o WebDriver para navegar por links não é uma prática recomendada. Não porque não pode ser feito, mas porque WebDriver definitivamente não é a ferramenta ideal para isso. O WebDriver precisa de tempo para inicializar, e pode levar vários segundos, até um minuto dependendo de como seu teste é escrito, apenas para chegar à página e atravessar o DOM.
Em vez de usar o WebDriver para isso, você poderia economizar muito tempo executando um comando curl, ou usando uma biblioteca como BeautifulSoup uma vez que esses métodos não dependem em criar um navegador e navegar para uma página.</description></item><item><title>Proxies Http</title><link>https://www.selenium.dev/documentation/pt-br/webdriver/http_proxies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/webdriver/http_proxies/</guid><description>Um servidor proxy atua como intermediário para solicitações entre um cliente e um servidor. De forma simples, o tráfego flui através do servidor proxy a caminho do endereço que você solicitou e de volta.
Um servidor proxy para scripts de automação com Selenium pode ser útil para:
Capturar o tráfego da rede Simular chamadas de back-end feitas pelo site Acessar o site necessário em uma rede complexa topologias ou restrições / políticas corporativas estritas.</description></item><item><title>Considere usar uma API fluente</title><link>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/consider_using_a_fluent_api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/consider_using_a_fluent_api/</guid><description>Martin Fowler cunhou o termo &amp;ldquo;API Fluent&amp;rdquo;. Selenium já implementa algo assim em sua classe FluentWait, que é pretende ser uma alternativa à classe padrão Wait. Você pode habilitar o padrão de design de API fluente em seu objeto de página e, em seguida, consulte a página de pesquisa do Google com um snippet de código como este:
driver.get( &amp;#34;http://www.google.com/webhp?hl=en&amp;amp;amp;tab=ww&amp;#34; ); GoogleSearchPage gsp = new GoogleSearchPage(); gsp.withFluent().setSearchString().clickSearchButton(); A classe de objeto da página do Google com este comportamento fluente pode ser assim:</description></item><item><title>Estratégia de carregamento de página</title><link>https://www.selenium.dev/documentation/pt-br/webdriver/page_loading_strategy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/webdriver/page_loading_strategy/</guid><description>Define a estratégia de carregamento de página da sessão atual. Por padrão, quando o Selenium WebDriver carrega uma página, segue a normal pageLoadStrategy. É sempre recomendado parar de baixar outros recursos (como imagens, css, js) quando o carregamento da página leva muito tempo.
A propriedade document.readyState de um documento descreve o estado de carregamento do documento atual. Por padrão, o WebDriver vai adiar a resposta a uma chamada para driver.get() (ou) driver.</description></item><item><title>Elemento Web</title><link>https://www.selenium.dev/documentation/pt-br/webdriver/web_element/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/webdriver/web_element/</guid><description>WebElement representa um elemento DOM. WebElements podem ser encontrados pesquisando na raiz do documento usando uma instância do WebDriver ou pesquisando em outro WebElement.
WebDriver API fornece métodos integrados para encontrar WebElements que são baseados em diferentes propriedades, como ID, Nome, Classe, XPath, Seletores CSS, Texto do link, etc.
Encontrar elemento É usado para encontrar um elemento e retorna a primeira referência WebElement única correspondente, que pode ser usado para ações futuras do elemento</description></item><item><title>Navegador novo por teste</title><link>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/fresh_browser_per_test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/guidelines_and_recommendations/fresh_browser_per_test/</guid><description>Comece cada teste a partir de um estado limpo conhecido. Idealmente, ligue uma nova máquina virtual para cada teste. Se ligar uma nova máquina virtual não for prático, pelo menos inicie um novo WebDriver para cada teste. Para Firefox, inicie um WebDriver com seu perfil conhecido.
FirefoxProfile profile = new FirefoxProfile(new File(&amp;#34;pathToFirefoxProfile&amp;#34;)); WebDriver driver = new FirefoxDriver(profile);</description></item><item><title>Chrome Devtools</title><link>https://www.selenium.dev/documentation/pt-br/support_packages/chrome_devtools/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/support_packages/chrome_devtools/</guid><description>As versões alfa do Selenium 4 têm aguardado suporte nativo para o protocolo Chrome DevTools por meio da interface &amp;ldquo;DevTools&amp;rdquo;. Isso nos ajuda a obter propriedades de desenvolvimento do Chrome, como cache de aplicativo, busca, rede, desempenho, criador de perfil, tempo de recurso, segurança e domínios de CDP de destino, etc.
Chrome DevTools é um conjunto de ferramentas de desenvolvedor da web integradas diretamente no navegador Google Chrome. DevTools pode ajudá-lo a editar páginas dinamicamente e diagnosticar problemas rapidamente, o que, em última análise, ajuda a criar sites melhores e mais rápidos.</description></item><item><title>Teclado</title><link>https://www.selenium.dev/documentation/pt-br/webdriver/keyboard/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/webdriver/keyboard/</guid><description>Keyboard representa um evento do teclado. As ações do teclado são executadas usando uma interface de baixo nível que nos permite fornecer entrada de dispositivo virtualizado para o navegador da web.
sendKeys O sendKeys digita uma sequência de teclas no elemento DOM, mesmo se uma sequência de teclas modificadoras for encontrada. Aqui está a lista de possíveis teclas que WebDriver suporta.
Java Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;
import org.</description></item><item><title>Contribuindo com o Site e Documentação do Selenium</title><link>https://www.selenium.dev/documentation/pt-br/contributing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/documentation/pt-br/contributing/</guid><description>Selenium é um grande projeto de software, seu site e documentação são fundamentais para entender como as coisas funcionam e aprender maneiras eficazes de explorar seu potencial.
Este projeto contém o site e a documentação do Selenium. Isto é um esforço contínuo (não direcionado a nenhuma versão específica) para fornecer informações atualizadas sobre como usar o Selenium de forma eficaz, como se envolver e como contribuir para o Selenium.
As contribuições para o site e documentação seguem o processo descrito na seção abaixo sobre contribuições.</description></item></channel></rss>